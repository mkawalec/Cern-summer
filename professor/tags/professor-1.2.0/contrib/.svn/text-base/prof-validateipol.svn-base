#!/usr/bin/env python
"""\
Usage:  %prog --datadir DATADIR --ipol-method IPOLMETHOD --runsfile RUNSFILE --weights WEIGHTS

Validate interpolations by comparing the spread from different
interpolations with the experimental error.
"""

import sys
import professor.user as prof

from professor.tools import shell
shell.usePrettyTraceback()
shell.setProcessName("prof-validateipol")

from optparse import OptionParser
parser = OptionParser(usage=__doc__)
parser.add_option("-R", "--runsfile", "--runcombs", dest="runsfile",
                  default="runcombs.dat",
                  help="File with run combinations to use: space separated, 1 "
                  "combination per line. [default: %default]")
parser.add_option("--titles",
        action = "store_true",
        dest = "printtitles",
        default = False,
        help = "Print histogram titles instead of paths. [default is off]")
parser.add_option("-s", "--max-ratio",
        metavar = "RATIO",
        dest = "maxratio",
        type = float,
        default = 1.0,
        help = "The maximal ratio of ipol spread/ref spread."
               " [default: %default]")
parser.add_option("--pf", "--paramsfile",
        metavar = "PARAMETERPOINT",
        dest = "paramsfile",
        help = "File with the parameter values.")
parser.add_option("--pv", "--paramsvector",
        metavar = "PARAMETERPOINT",
        dest = "paramsvector",
        help = "Parameter values as comma-separated list. E.g."
               " PAR1=42.0,PAR2=0.23 .")

prof.addDataCLOptions(parser, ref=True, mc=False, ipol=True, scan=False)
prof.addIpolCLOptions(parser)
prof.addLoggingCLOptions(parser)

opts, args = parser.parse_args()
prof.log.setPriority(opts)
prof.writeGuideLine()

## Get a DataProxy object (core object for tuning)
dataproxy = prof.DataProxy.mkFromCLOptions(opts)

## Check the central parameter file/vector and the parameter range.
params = None
if opts.paramsvector is not None and opts.paramsfile is not None:
    prof.log.error("Both options --paramsfile and --paramsvector given:"
                   " Cannot decide, please give only one option!")
    sys.exit(1)
elif opts.paramsvector is not None:
    params = prof.ParameterPoint.mkFromString(opts.paramsvector)
elif opts.paramsfile is not None:
    params = prof.ParameterPoint.mkFromFile(opts.paramsfile)


## Get the specified interpolation class. We're only interested in the order
## of the polynomial to construct the file name of the ipol pickles. This is
## not necessarily the exact interpolation method used. I.e. IpolCls will
## always refer to the pure-Python implementation but the pickled files
## might contain the Weave version.
try:
    IpolCls = prof.getInterpolationClass(opts.ipolmethod, False)
    prof.log.info("Using %s polynomial for interpolation." % (IpolCls.method))
except Exception, e:
    prof.log.error("Problem getting interpolation method: %s" % e)
    prof.log.error("Exiting!")
    sys.exit(1)

## Load run combinations
prof.log.debug("Using %s as runsfile" % (opts.runsfile))
try:
    runfile = open(opts.runsfile, "r")
except Exception, e:
    prof.log.error("Error while opening run combination file %s: %s" %
                   (opts.runsfile, e))
    sys.exit(1)
allrcs = [line.split() for line in runfile.readlines()]
runfile.close()
prof.log.info("Loaded %i run combinations from %s" %
              (len(allrcs), opts.runsfile))

## Select the observables we want to use for our tune.
try:
    allobs = prof.WeightManager.mkFromFile(opts.observablefile).observables
except Exception, e:
    prof.log.error("Problem when reading observable file: %s" % (e))
    prof.log.error("Exiting!")
    sys.exit(1)
prof.log.debug("Loaded observable file from %s: %s" % (opts.observablefile, allobs))

# Some variables that are initialized in the for-loop.
# {binid => [ipol values]}
ipolspread = None
binids = None
first = True

prof.log.info("Calculating spread from %i run combinations" % (len(allrcs)))
for i, rc in enumerate(allrcs):
    tunedata = dataproxy.getTuneData(withref=True, useipol=IpolCls, useruns=rc, useobs=allobs)

    # Do some initializations
    if first:
        prof.log.debug("Initialized spread container")
        ipolspread = dict()
        for binid in tunedata.iterkeys():
            ipolspread[binid] = list()

        binids = sorted(tunedata.keys())
        first = False

    if params is None:
        params = tunedata.values()[0].ipol.center
        prof.log.debug("Evaluating interpolations with parameters:\n"
                       "%s" % (params))

    for binid, binprop in tunedata.iteritems():
        ipolval = binprop.ipol.getValue(params)
        ipolspread[binid].append(ipolval)
    prof.log.debug("Finished run combination %i/%i" % (i+1, len(allrcs)))


refdata = dataproxy.getTuneData(withref=True, withmc=False,
                                useipol=None, useobs=allobs)

pp = prof.PlotParser()

currentobs = None
faultybins = False
allbinsok = True
first = True
for binid in binids:
    obs, idx = dataproxy.splitBinID(binid)

    # we're treating a new observable
    if obs != currentobs:
        if not first:
            if faultybins:
                print
            else:
                print "  ok"
        else:
            first = False
        faultybins = False
        currentobs = obs
        if not opts.printtitles:
            print currentobs,
        else:
            print pp.getHeaders(currentobs)["Title"],

    m = min(ipolspread[binid])
    M = max(ipolspread[binid])
    ref = refdata[binid].refbin
    refspread = ref.yerrplus + ref.yerrminus

    # if ipolspread/refspread > 1.0 
    if (M - m)/refspread > opts.maxratio:
        print "  %d" % (idx),
        faultybins = True
        allbinsok = False

if faultybins:
    print
else:
    print "  ok"

if allbinsok:
    print
    print "All bins of the above observables are OK"
else:
    print
    print "Some bins have a large interpolation spread"
