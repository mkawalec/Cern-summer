#!/usr/bin/env python2.5
usage = """

examples:
    getruncombs results.pkl\n
    getruncombs -m DATA/mc -C "0,1:30,100"

"""

import sys, os, logging
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")
from optparse import OptionParser
from professor.tools import permut, messages
from professor.minimize import result

parser = OptionParser(usage=usage)
parser.add_option("-m", "--mcdir", dest="MCDIR", default=None,
        help="specify a directory of monte carlo runs"
        )
parser.add_option("-C", "--ncombs", dest="COMBS", default=(0,1),
        help="specify the steering parameters for xrandomuniquecombinations"
        )
parser.add_option("-o", "--outfile", dest="OUTFILE", default="runcombs.dat",
        help="specify the output file-name"
        )
(opts, args) = parser.parse_args()

sys.stdout.write(messages.guideline)
sys.stdout.flush()

def getRunsFromMCDir(mcdir):
    """ parse a directory and check for existing used_params and out.aida
        files and append the runnumber if both exist
    """
    runs = []
    for run in os.listdir(mcdir):
        runoutdir = os.path.join(mcdir, str(run))
        runoutdir = os.path.abspath(runoutdir)
        if not os.path.isdir(runoutdir):
            continue

        ## allow for both filenames to be recognized
        outhistofile = os.path.join(runoutdir, 'out.aida')
        if not os.path.exists(outhistofile):
            outhistofile = os.path.join(runoutdir, 'histos.aida')

        outparamsfile = os.path.join(runoutdir, 'used_params')
        if not os.access(outhistofile, os.R_OK) or not os.access(outparamsfile, os.R_OK):
            logging.warning("Can't read histo or params files for run %s... skipping" % str(run))
            continue
        else:
            runs.append(run)
    return runs

def getRunCombsFromXPart(items, combinations):
    """ create runcombinations using xrandomUniquCombinations """
    temp = []
    for comb in combinations:
        for runcomb in permut.xrandomUniqueCombinations(items, len(items) - int(comb[0]), int(comb[1])):
            temp.append(getCmbLine(runcomb))
    return temp

def getRunCombsFromResults(rlist):
    """ get all the used runcombinations from a results file """
    temp = []
    for res in rlist:
        temp.append(getCmbLine(res.runs))
    return temp

def getCmbLine(items):
    """ helper function that creates lines suitable for writing to file """
    cmbline =""
    for i in items:
        cmbline += "%s "%i
    cmbline += "\n"
    return cmbline

def writeRunCombfile(runs):
    """ write out the runcombinations, one combination per line """
    f=open(opts.OUTFILE, "w")
    for line in runs:
        f.write(line)
    f.close()


if opts.MCDIR is not None:
    avail_runs = sorted(getRunsFromMCDir(opts.MCDIR))
    combinations = [comb.split(",") for comb in opts.COMBS.split(":")]
    runcombs = getRunCombsFromXPart(avail_runs, combinations)
else:
    try:
        R = result.ResultList.fromPickle(args[0])
    except:
        logging.error("could not read results file")
        sys.exit(1)
    runcombs = getRunCombsFromResults(R)

writeRunCombfile(runcombs)
logging.info("written runcombinations to %s"%opts.OUTFILE)
