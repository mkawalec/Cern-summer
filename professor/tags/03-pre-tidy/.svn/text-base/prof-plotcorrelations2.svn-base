#!/usr/bin/env python
"""%prog [options] results.pkl [...]

Plot parameter-parameter correlations minimisation result files.

Either the covariance estimate for the minimisation with the most runs used
for interpolation (as returned from the minimiser) or the sample covariance
estimator is used to calculate the correlation coefficients.

The plots file names follow this naming scheme:
    OUTDIR/NAME-ESTIMATE.pdf
where OUTDIR is the given output dir, NAME is the basename of the result
file's path without the extension and ESTIMATE is either 'sample' or
'minimiser', i.e. the origin of the estimation.
"""

import sys
import os
import logging
import optparse
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")

import numpy
# TODO(25.Sep.2009): Is this still true?
# import matplotlib     # These two lines must be called before import pylab
# matplotlib.use('Agg') # to prevent memory leakage
from matplotlib import pyplot, cm

from professor import minimize
from professor.tools import messages

params = {
        'backend':'pdf',
        'figure.dpi': 300,
        'text.fontsize': 16,
        'legend.fontsize': 8,
        'axes.titlesize': 16,
        'axes.labelsize': 16,
        'xtick.labelsize': 16,
        'ytick.labelsize': 16,
        'lines.markersize':7,
        'figure.subplot.left' : 0.32,
        'figure.subplot.right' : 0.98,
        'figure.subplot.top' : 0.98,
        'figure.subplot.bottom' : 0.36,
        'text.usetex': False
        }
pyplot.rcParams.update(params)

parser = optparse.OptionParser(usage = __doc__)
parser.add_option("-o", "--outdir",
        help = "Output directory for correlation plots. (default: %default)")
parser.add_option("-t", "--tex",
        action = "store_true",
        help = "Print out latex table code to stdout for each correlation"
            " plot.")
parser.add_option("--SC", "--no-sample-correlation",
        dest = "usesample",
        action = "store_false",
        help = "Do not plot the sample correlation estimates")
parser.add_option("--mc", "--minimiser-correlation",
        dest = "useminimiser",
        action = "store_true",
        help = "Plot the minimiser correlation estimates for the run"
            " combination with maximal number of runs.")
parser.set_defaults(outdir = "correlations",
        tex = False,
        usesample = True,
        useminimiser = False
        )
opts, args = parser.parse_args()

if len(args) == 0:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: No result files given!")
    sys.exit(1)

sys.stdout.write(messages.guideline)
sys.stdout.flush()

if os.path.exists(opts.outdir):
    if (not os.path.isdir(opts.outdir)
            or not os.access(opts.outdir, os.R_OK|os.X_OK)):
        sys.stderr.write("Error: output directory is not a directory or has"
                " bad permissions: %s" % (opts.output))
        sys.exit(1)
else:
    print "Creating output directory: %s" % (opts.outdir)
    os.makedirs(opts.outdir)

def plotCorrelations(fig, paramnames, corr):
    # grid for pseudo color plots
    X, Y = numpy.meshgrid(numpy.arange(len(paramnames) + 1),
                          numpy.arange(len(paramnames) + 1))
    sub = fig.add_subplot(1,1,1)
    # Reverse the y direction (i.e. axis 0 for the pcolor call) to get
    # variances on the 1st diagonal. A transpose is not necessary here.
    col = sub.pcolor(X, Y, corr[::-1], vmin=-1.0, vmax=1.0, cmap=cm.RdBu_r)
    colbar = fig.colorbar(col)
    sub.set_xticks(numpy.arange(len(paramnames)) + 0.5)
    sub.set_xticklabels(paramnames, rotation=305,
            horizontalalignment="left")
    sub.set_yticks(numpy.arange(len(paramnames)) + 0.5)
    # sub.set_yticklabels(paramnames)
    # y tick labels are reversed.
    sub.set_yticklabels(paramnames[::-1])

def writeLatexTable(stream, params, corr):
    # fix some tex issues with SHERPA parameter names
    params = map(lambda s: s.replace("_", r"\_"), params)
    params = map(lambda s: s.replace("^", r"\^{}"), params)
    # head of table
    stream.write(r"\begin{tabular}{l|*{%i}{c}}" % (len(params))
            + "\n")
    stream.write(" & " + " & ".join(params) + r" \\\hline" "\n")
    for i, p1 in enumerate(params):
        stream.write(p1)
        for j, p2 in enumerate(params):
            if j < i:
                stream.write(" & -- ")
            else:
                stream.write(" & %.2f" % (corr[i,j]))
        stream.write(r"\\" + "\n")
    stream.write(r"\end{tabular}" + "\n")


for path in args:
    logging.info("Working on file %s..." % (path))
    fbase = os.path.splitext(os.path.basename(path))[0]
    reslist = minimize.ResultList.fromPickle(path)
    paramnames = reslist.getParamNames()
    if opts.usesample:
        fpath = os.path.join(opts.outdir,
                fbase + "-sample.pdf")
        corr = reslist.getSampleCorrelations()
        fig = pyplot.figure(1, facecolor="w")
        plotCorrelations(fig, paramnames, corr)
        pyplot.savefig(fpath)
        fig.clf()
        logging.info("  saved sample correlations to %s" % (fpath))
        if opts.tex:
            sys.stdout.write("%% Table for sample correlations of results in"
                    " %s\n" % (path))
            writeLatexTable(sys.stdout, paramnames, corr)

    if opts.useminimiser:
        fpath = os.path.join(opts.outdir,
                fbase + "-minimiser.pdf")
        maxnumruns = max(reslist.getRunCounts())
        t = filter(lambda res: len(res.runs) == maxnumruns, reslist)
        if len(t) > 1:
            logging.warn("%i results with maximal number of runs (%i) in"
                    " file %s!" % (len(t), maxnumruns, path))
            logging.warn("Using the first result only!")
        corr = t[0].getCorrelMatrix()
        fig = pyplot.figure(1, facecolor="w")
        plotCorrelations(fig, paramnames, corr)
        pyplot.savefig(fpath)
        fig.clf()
        logging.info("  saved minimiser correlations to %s" % (fpath))
        if opts.tex:
            sys.stdout.write("%% Table for minimiser correlations of results"
                    " in %s\n" % (path))
            writeLatexTable(sys.stdout, paramnames, corr)
