#! /usr/bin/env python

"""%prog

Create pdf plots in the given directory and the given file mode.

Usage:
    %prog [options] PLOTMODE RESULT.XML:"label1" [RESULT2.XML:"label2" ...]

    PLOTMODE sets the type of the created plots:
        - chi2: Creates chi^2 vs. parameter result plots. One plot for each
                parameter and each given results file.
        - compare: Creates paramter result vs. observable set plots. One
                   plot for each parameter.

    RESULT.XML a result file created by prof-tune. If you are plotting
    results for different sets of observables, the results for each set
    should be in separate files (RESULT2.XML ...)

Use --help to get information for all options.

TODO: file naming scheme
"""

import sys, os, itertools, numpy, matplotlib, matplotlib.pyplot, logging
import optparse
import logging
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")

from professor.tools import formulas, parameter, messages
from professor.minimize import ResultList

try:
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed([])
except:
    logging.info("Ipython shell not available.")

params = {
        'backend':'pdf',
        'axes.labelsize': 22,
        'text.fontsize': 22,
        'legend.fontsize': 26,
        'axes.titlesize': 22,
        'xtick.labelsize': 22,
        'ytick.labelsize': 22,
        'text.usetex': True,
        'figure.dpi': 600,
        'figure.subplot.left' : 0.12,
        'figure.subplot.right' : 0.995,
        'figure.subplot.bottom' : 0.1,
        'figure.subplot.top' : 0.979,
        'lines.markersize':7,
        'text.latex.preamble' :  ['\usepackage{amsmath}', '\usepackage{hepunits}']
        #'text.latex.preamble' :  ['\usepackage{amsmath}', '\usepackage{mathpazo}', '\usepackage{hepunits}']
        }

matplotlib.pyplot.rcParams.update(params)

parser = optparse.OptionParser(usage = __doc__)
parser.add_option("--logy",
        dest = "logy",
        action = "store_true",
        help = "Log scaled chi^2 axis when PLOTMODE is chi2.")
parser.add_option("--liny",
        dest = "logy",
        action = "store_false",
        help = "Linear scaled chi^2 axis when PLOTMODE is chi2. (default)")
parser.add_option("--ndof",
        dest = "ndof",
        action = "store_true",
        help = "Plot chi^2/ndof instead of chi^2 when PLOTMODE is chi2."
               " (default)")
parser.add_option("--no-ndof",
        dest = "ndof",
        action = "store_false",
        help = "Plot chi^2 instead of chi^2/ndof when PLOTMODE is chi2.")
parser.add_option("--outdir",
        help = "The directory were the plots are saved. (default: %default)")
parser.add_option("--best",
        help = "Best estimate result file")
parser.add_option("--paramsfile",
        help = "The file that contains the parameters for prof-runrivet")
parser.add_option("--bw",
        dest = "bw",
        action = "store_true",
        help = "produce b/w safe plots, e.g. suitable for publications")
parser.add_option("--color",
        dest = "bw",
        action = "store_false",
        help = "produce color plots (default)")

parser.set_defaults(
        logy = False,
        ndof = True,
        outdir = "./",
        bw = False,
        best=None)

opts, args = parser.parse_args()

sys.stdout.write(messages.guideline)
sys.stdout.flush()

## Load/check data and commandline.
try:
    plotmode = args[0]
    resultpaths = args[1:]
except IndexError:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Bad number of arguments!\n")
    sys.exit(1)

if plotmode not in ("chi2", "compare", "chi2dist"):
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Given plotmode is not supported. Use chi2"
                     ", compare or chi2dist!\n")
    sys.exit(1)

# Check existence of outdir
outdir = opts.outdir
if not os.path.isdir(outdir):
    logging.info("created directory %s"%outdir)
    os.mkdir(outdir)

# Load parameter-file
try:
    par_boundaries = parameter.readParameterFile(opts.paramsfile)
except:
    par_boundaries = None

# Load results to a [observable set name]->[result list] dict.
resdict = {}
if len(resultpaths) == 0:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: No result files given!\n")
    sys.exit(1)
for p in resultpaths:
    try:
        rfile, name = p.split(":")
    except ValueError:
        logging.info("no plot label specified for %s, using filename instead"%p)
        name = os.path.splitext(os.path.basename(p))[0]
        rfile = p
    reslist = ResultList.fromPickle(rfile)
    #reslist.isValid()
    resdict[name] = reslist

if opts.best is not None:
    try:
        bestres = ResultList.fromPickle(opts.best)[0]
    except:
        print "best estimate result not valid"
        pass

logy = opts.logy
ndof = opts.ndof


## Define some plotting routines.
def getColors(keys, reverse=True):
    colorcycle = itertools.cycle(['b', 'k', 'r', 'g'])
    if opts.bw:
        colorcycle = itertools.cycle(['k', '.8', '.95'])
    d = {}
    for k in sorted(keys, reverse=reverse):
        d[k] = colorcycle.next()
    return d

def getMarkers(keys):
    linecycle = itertools.cycle(["s","o","x"])
    d = {}
    for k in sorted(keys, reverse=False):
        d[k] = linecycle.next()
    return d

def getLinestyles(keys):
    linecycle = itertools.cycle(["solid", "dashed", "dotted", "dashdot", "-o"])
    d = {}
    for k in sorted(keys, reverse=False):
        d[k] = linecycle.next()
    return d

def getOffsets(keys):
    linecycle = itertools.cycle([0.2,0.0,0.2,0.3])
    d = {}
    for k in sorted(keys, reverse=False):
        d[k] = linecycle.next()
    return d


def getZorders(keys):
    linecycle = itertools.cycle([10,11,12,13,14,15])
    d = {}
    for k in sorted(keys, reverse=True):
        d[k] = linecycle.next()
    return d

def getMRData(reslist, paramname, alsosort="byFlags"):
    ## Group MinRun objects together by num_runs
    data, catalogue = {}, {}
    for mr in reslist:
        num_runs = len(mr.runs)
        if not data.has_key(num_runs):
            data[num_runs] = []
        data[num_runs].append(mr)


    if alsosort == "byFlags":
        ## Group results further depending on flags set
        pindex = reslist[0].getIndex(paramname)
        for num_runs, mrs in sorted(data.iteritems()):

            ## Split points by whether they are inside all param ranges
            params = { "IN":[], "OUT":[], "ON_LIMIT":[] }
            perrs =  { "IN":[], "OUT":[], "ON_LIMIT":[] }
            chi2s =  { "IN":[], "OUT":[], "ON_LIMIT":[] }
            for mr in mrs:
                if mr.HITLIMIT_FLAG:
                    if len(mr.parunscaled) > pindex:
                        params["ON_LIMIT"].append( mr.parunscaled[pindex] )
                    if len(mr.errunscaled) > pindex:
                        perrs["ON_LIMIT"].append( mr.errunscaled[pindex] )
                    chi2s["ON_LIMIT"].append( mr.chi2 / mr.ndof )
                else:
                    if not mr.OUTSIDE_FLAG:
                        if len(mr.parunscaled) > pindex:
                                params["IN"].append( mr.parunscaled[pindex] )
                        if len(mr.errunscaled) > pindex:
                                perrs["IN"].append( mr.errunscaled[pindex] )
                        chi2s["IN"].append( mr.chi2 / mr.ndof )
                    else:
                        if len(mr.parunscaled) > pindex:
                            params["OUT"].append( mr.parunscaled[pindex] )
                        if len(mr.errunscaled) > pindex:
                            perrs["OUT"].append( mr.errunscaled[pindex] )
                        chi2s["OUT"].append( mr.chi2 / mr.ndof )
            catalogue[num_runs] = {"params" : params, "perrs" : perrs,
                    "chi2s" : chi2s}
    elif alsosort == "byIpolMethods":
        ## Group results further depending on flags set
        pindex = reslist[0].getIndex(paramname)
        for num_runs, mrs in sorted(data.iteritems()):

            ## Split points by IpolMethod used
            params, perrs, chi2s = {}, {}, {}
            for method in reslist.getIpolMethods():
                params[method] = []
                perrs[method]  = []
                chi2s[method]  = []
            for mr in mrs:
                if len(mr.parunscaled) > pindex:
                    params[mr.getIpolMethod()].append( mr.parunscaled[pindex] )
                if len(mr.errunscaled) > pindex:
                    perrs[mr.getIpolMethod()].append( mr.errunscaled[pindex] )
                chi2s[mr.getIpolMethod()].append( mr.chi2 / mr.ndof )
            catalogue[num_runs] = {"params" : params, "perrs" : perrs,
                        "chi2s" : chi2s}
    else:
        logging.error("Sorting by '%s' not available."%str(alsosort))
    return catalogue


def plotChi2ForListAndParam(fig, reslist, paramname):
    """Plot chi^2 vs. parameter result for one result list and observable
    set.

    This creates one plot.
    """
    logging.info("Now processing %s."%paramname)

    data = getMRData(reslist, paramname, "byIpolMethods")

    # this is a list, the mrs were sorted by
    sortedby = data[data.keys()[0]][data[data.keys()[0]].keys()[0]].keys()

    # this is for having one legend label per combination only
    nlegends = {}
    for n in data.keys():
        nlegends[n] ={}
        for s in sortedby:
            nlegends[n][s] = 0

    colordict = getColors(data.keys())
    markerdict= getMarkers(sortedby)

    pmin = pmax = None

    ## Plot chi2 vs. param value
    fig.clear()
    sub = fig.add_subplot(1,1,1)
    if logy:
        sub.set_yscale("log")



    for num_runs, cat in sorted(data.iteritems()):

        ## Get drawing colours, and alphaize the out-of-range version
        #colorcode = colordict[num_runs]
        #inrange_color = matplotlib.colors.ColorConverter().to_rgb(colorcode)
        #outrange_color = [c + 0.5*(1-c) for c in inrange_color]
        #colors = { "IN" : inrange_color, "OUT" : outrange_color,
                #"ON_LIMIT" : inrange_color}

        ### Set markers to distinguish results that hit parameter limits
        #markers = { "IN" : ".", "OUT" : ".",
                #"ON_LIMIT" : "x"}

        for n, i in enumerate(sortedby): #["OUT", "IN", "ON_LIMIT"]):
            if not cat["params"][i]:
                continue

            ## For the xlims
            if pmin is None or min(cat["params"][i]) < pmin:
                pmin = min(cat["params"][i])
            if pmax is None or max(cat["params"][i]) > pmax:
                pmax = max(cat["params"][i])

            #kwargs = {"marker" : markers[i], "linestyle":"",
                      #"color" : colors[i],
                      #"label" : "$N_\\mathrm{runs} = %i\\:\\mathrm{(%s)}$" % (
                          #num_runs, (i.lower()).replace("_","\\,")) }

            ## Draw more-runs results on top of fewer-runs ones
            zorder = num_runs + n
            for m in xrange(len(cat["params"][i])):
                if nlegends[num_runs][i] == 0:
                    label = "$N_\\mathrm{runs} = %i\\:\\mathrm{(%s)}$" % (
                              num_runs, (i.lower()).replace("_","\\,"))
                else:
                    label=None

                kwargs = {"marker" : markerdict[i], "linestyle":"",
                          "color" : colordict[num_runs],
                          "label" : label }
                try:
                    j, k, l = sub.errorbar(cat["params"][i][m], cat["chi2s"][i][m],
                            xerr=cat["perrs"][i][m][0], zorder=zorder, **kwargs)
                except:
                    logging.warning("Not plotting errorbar (N=%i, type=%s)."%(num_runs, i))
                    sub.plot([cat["params"][i][m]], [cat["chi2s"][i][m]], zorder=zorder,
                            **kwargs)
                nlegends [num_runs][i] +=1

    ## 
    if opts.best is not None:
        bestchi2 = bestres.chi2/bestres.ndof
        bestpval = bestres.parunscaled[bestres.getIndex(paramname)]
        #try:
            #j, k, l = sub.errorbar(cat["params"][i][m], cat["chi2s"][i][m],
                    #xerr=cat["perrs"][i][m][0], zorder=zorder, **kwargs)
        #except:
            #logging.warning("Not plotting errorbar (N=%i, type=%s)."%(num_runs, i))
        sub.plot([bestpval], [bestchi2], zorder=5000, label=r"$\mathrm{Best\:tuning\: estimate}$", color="k",
                marker="*", markersize=15, ls=" ")

    ## Plot vertical lines at the parameter-sampling-boundaries
    if par_boundaries is not None:
        sub.axvline(x=par_boundaries[paramname][0], ls=':', c='g')
        sub.axvline(x=par_boundaries[paramname][1], ls=':', c='g',
                    label="$\\mathrm{Sampling\\:boundaries}$", zorder=0)
    else:
        logging.warning("%s: no parameter boundaries are being "%paramname
                + "plotted; be careful how you interpret the plots!")



    ## Set sensible xlims
    if par_boundaries is not None:
        lows = [par_boundaries[paramname][0], pmin]
        highs = [par_boundaries[paramname][1], pmax]
    else:
        lows = [pmin]
        highs =[pmax]

    nicenPlotLimits(sub, lows, highs, 'x')
    sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()

    sub.set_xlabel("$\\mathrm{%s}$" % paramname)
    #if paramname in ["PARP(64)", "PARP(79)", "PARP(90)"]:
    if ndof:
        sub.set_ylabel("$\\chi^2/N_{\\mathrm{df}}$")
    else:
        sub.set_ylabel("$\\chi^2$", rotation=0)

    if paramname == "PARP(78)":
        try:
            l = sub.legend(loc=1, labelspacing=0.02, handletextpad=0.04, numpoints=1)
        except:
            l = sub.legend(loc=1)
        if l is not None:
            l.get_frame().set_edgecolor('w')
            l.set_alpha(0.1)
            l.set_zorder(20)
    return sub

def stringsStartwith(alist, token):
    """ returns True if all the string in alist start with the same token """
    for item in alist:
        if not len(item.split(token)) == 2:
            return False
        else:
            continue
    return True

def sortResults(reslist):
    resdict = {}
    for im in reslist.getIpolMethods():
        resdict[im] = {}

    for mr in reslist:
        method = mr.getIpolMethod()
        nruns = len(mr.runs)
        if not nruns in resdict[method].keys():
            resdict[method][nruns] = []
        resdict[method][nruns].append(mr)
    return resdict

def plotCompareForParam(fig, paramname, identifier='results'):
    setnames = sorted(resdict.keys())

    fig.clear()
    # these are for the y-limits of the subplot
    mins = []
    maxs = []
    all = []
    sub = fig.add_subplot(111)
    pmin = pmax = None

    # workaround to remove legend duplicates
    legendtags = {}
    for rset in resdict.keys():
        for run_num in resdict[rset].getRunCounts():
            legendtags[run_num] = {}
            for method in resdict[rset].getIpolMethods():
                legendtags[run_num][method] = 0

    print legendtags
    xtickpos = []
    for j, setname in enumerate(setnames):
        allofset = []
        reslist = resdict[setname]
        pindex = reslist[0].getIndex(paramname)

        x = j + 1.
        xtickpos.append(x)

        data = getMRData(reslist, paramname, "byIpolMethods")

        sortedby = data[data.keys()[0]][data[data.keys()[0]].keys()[0]].keys()

        offsets=getOffsets(sortedby)
        markerdict= getMarkers(sortedby)
        colordict = getColors(data.keys())

        for num_runs, cat in reversed(sorted(data.iteritems())):
            for n, i in enumerate(sortedby):
                if not cat["params"][i]:
                    continue
                for m in xrange(len(cat["params"][i])):
                    if legendtags[num_runs][i] == 0:
                        label = "$N_\\mathrm{runs} = %i\\:\\mathrm{(%s)}$" % (
                                  num_runs, (i.lower()).replace("_","\\,"))
                    else:
                        label=None

                    kwargs = {"marker" : markerdict[i], "linestyle":"",
                              "color" : colordict[num_runs],
                              "label" : label }

                    ## For the xlims
                    if pmin is None or min(cat["params"][i]) < pmin:
                        pmin = min(cat["params"][i])
                    if pmax is None or max(cat["params"][i]) > pmax:
                        pmax = max(cat["params"][i])


                    ## Draw more-runs results on top of fewer-runs ones
                    zorder = num_runs + n
                    if num_runs == 393 and i == "quadratic":
                        sub.plot((x+0.1)*numpy.ones(len(cat["params"][i])), cat["params"][i],
                                zorder=zorder, **kwargs)
                        legendtags[num_runs][i] +=1
                    else:
                        sub.plot((x+offsets[i])*numpy.ones(len(cat["params"][i])), cat["params"][i],
                                zorder=zorder, **kwargs)
                        legendtags[num_runs][i] +=1

    # plot horizontal lines at the param-sampling-boundaries
    if par_boundaries is not None:
        sub.axhline(y=par_boundaries[paramname][0], ls=':', c='g')
        sub.axhline(y=par_boundaries[paramname][1], ls=':', c='g',
                label="$\\mathrm{Sampling\\:boundaries}$")

    sub.set_ylabel("$\\mathrm{%s}$"%(paramname))
    sub.set_xticks(xtickpos)#range(1, len(setnames) + 1))
    def wrap(string):
        return "$\\mathrm{"+string+"}$"
    clean_setnames = [k.replace("_","\\:") for k in setnames]
    sub.set_xticklabels(map(wrap,clean_setnames), rotation=0, y=-0.05, ha="center")
    sub.set_xlim(0, len(setnames)+ 1)

    ## Set sensible ylims
    if par_boundaries is not None:
        lows = [par_boundaries[paramname][0], pmin]
        highs = [par_boundaries[paramname][1], pmax]
    else:
        lows = [pmin]
        highs =[pmax]

    nicenPlotLimits(sub, lows, highs, 'y')
    # set useful y-limits, so that the horizontal lines are displayed nicely
    #if not par_boundaries is None:
        #lows = [par_boundaries[paramname][0], min(mins)]
        #highs = [par_boundaries[paramname][1], max(maxs)]
    #else:
        #lows = [min(mins)]
        #highs =[max(maxs)]

        #nicenPlotLimits(sub, lows, highs, 'y')

    #sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()

    sub.get_xaxis().set_ticks_position("none")
    
    if paramname == "PARP(78)":
        try:
            l = sub.legend(loc=1, labelspacing=0.02, handletextpad=0.04, numpoints=1)
            l.get_frame().set_edgecolor('w')
            l.set_alpha(.1)
            l.set_zorder(20)
        except AttributeError:
            pass
    return sub

def plotChi2Dist(fig, resdict):
    sub = fig.add_subplot(111)
    lows, highs = [], []

    temp =[]
    singles = []
    for rl in resdict.values():
        if not len(rl) == 1:
            for mr in rl:
                temp.append(mr)
        else:
            singles.append(rl[0])
    allres = ResultList(temp)
    singleres = ResultList(singles)

    results_sorted = sortResults(allres)
    singles_sorted = sortResults(singleres)

    colors = getColors(results_sorted.keys(), False)


    combinations = {}
    for k, v in results_sorted.iteritems():
        combinations[k] = []
        for n in v.keys():
            if not n in combinations[k]:
                combinations[k].append(n)
    for k, v in singles_sorted.iteritems():
        if not combinations.has_key(k):
            combinations[k] = []
        for n in v.keys():
            if not n in combinations[k]:
                combinations[k].append(n)

    for im, nrdict in sorted(results_sorted.iteritems()):
        styles = getLinestyles(sorted(combinations[im]))
        for nr, mrlist in nrdict.iteritems():
            if opts.ndof:
                chis = [mr.chi2/mr.ndof for mr in mrlist]
                sub.set_xlabel(r"$\chi^2/N_\text{df}$")
            else:
                chis = [mr.chi2 for mr in mrlist]
                sub.set_xlabel(r"$\chi^2$")
            lows.append(min(chis))
            highs.append(max(chis))
            sub.hist(chis, histtype="step",
                    label=r"$N_\text{runs}=%s,\:(\text{%s ipol})$"%(str(nr), im),
                    ec=colors[im], ls = styles[nr], lw=2)

    for im, nrdict in sorted(singles_sorted.iteritems()):
        styles = getLinestyles(sorted(combinations[im]))
        for nr, mrlist in nrdict.iteritems():
            if opts.ndof:
                chis = [mr.chi2/mr.ndof for mr in mrlist]
                sub.set_xlabel(r"$\chi^2/N_\text{df}$")
            else:
                chis = [mr.chi2 for mr in mrlist]
                sub.set_xlabel(r"$\chi^2$")
            lows.append(min(chis))
            highs.append(max(chis))
            sub.axvline(chis[0],
                    label=r"$N_\text{runs}=%s,\:(\text{%s ipol})$"%(str(nr), im),
                    color=colors[im], ls = styles[nr], lw=2)

    l = sub.legend(loc=0, labelspacing=0.02, handletextpad=0.04)
    l.get_frame().set_edgecolor('w')
    l.set_alpha(.1)
    l.set_zorder(20)

    nicenPlotLimits(sub, lows, 1.1*numpy.array(highs),"x")

    sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()

    return sub

def getResultsByNRuns(reslist):
    ## Group MinRun objects together by num_runs
    data = {}
    for mr in reslist:
        num_runs = len(mr.runs)
        if not data.has_key(num_runs):
            data[num_runs] = []
        data[num_runs].append(mr)
    return data

def nicenPlotLimits(sub, lows, highs, axis):
    try:
        dist = abs(lows[0] - highs[1])
        newmin = min(lows)  - .1*dist
        newmax = max(highs) + .1*dist
    except (IndexError, TypeError):
        newmin = min(lows)
        newmax = max(highs)
    if axis == "x":
        sub.set_xlim(xmax=newmax)
        sub.set_xlim(xmin=newmin)
    elif axis == "y":
        sub.set_ylim(ymax=newmax)
        sub.set_ylim(ymin=newmin)
    else:
        raise StandardError("axis has to be either 'x' or 'y'")



if __name__ == "__main__":

    if plotmode == "chi2":
        # Plot and save chi^2 vs. parameter for all observable sets and
        # parameters.
        for setname, reslist in resdict.iteritems():
            for paramname in reslist.getParamNames():
                fig = matplotlib.pyplot.figure(facecolor='w')
                sub = plotChi2ForListAndParam(fig, reslist, paramname)
                safename = setname.replace(" ","").replace(",","")
                fig.savefig("%s/chi2_%s_%s.%s" % (outdir, paramname, safename,matplotlib.pyplot.rcParams.get('backend') ))

    elif plotmode == "compare":
        pnames = resdict.values()[0].getParamNames()
        fig = matplotlib.pyplot.figure()
        for pname in pnames:
            plotCompareForParam(fig, pname)
            fig.savefig("%s/compare_%s.%s" % (outdir, pname, matplotlib.pyplot.rcParams.get('backend')))
    elif plotmode == "chi2dist":
        fig = matplotlib.pyplot.figure(facecolor='w')
        plotChi2Dist(fig, resdict)
        fig.savefig("%s/chi2distribution.%s" % (outdir,matplotlib.pyplot.rcParams.get('backend') ))

    else:
        sys.stderr.write(conf.getHelp())
        sys.stderr.write("Error: Given plot mode '%s' is not supported. Use chi2 or compare!\n" % plotmode)
        sys.exit(1)
