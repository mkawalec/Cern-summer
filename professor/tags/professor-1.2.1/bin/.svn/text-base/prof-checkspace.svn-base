#! /usr/bin/env python

"""\
Usage: %prog [options] [args ...]

Plot distribution of anchor points in parameter space.

        example:    %prog --mcdir mc
                    %prog --mcdir mc PARAM_X
                    %prog --mcdir mc PARAM_X PARAM_Y
                    %prog --mcdir mc all

If pyVisual is installed a 3D viewer is available:

                    %prog --mcdir mc --visual

Navigate through the sub-spaces using the buttons 'a', 'w' and 'd'.

In general, points are drawn blue if the parameter- and corresp. histogram
file exist. Points are frawn red in all other cases.

Optionally you can provide a file with parameter-ranges via --ranges.

"""

import os, sys
import pylab, numpy
import professor.user as prof

HAVEVISUAL = True
try:
    from visual import *
except ImportError:
    HEVEVISUAL = False
    prof.log.info("Error while importing python Visual -- 3D unavailable")

# Some pylab plot options
params = {
        'axes.labelsize': 7,
        'text.fontsize': 8,
        'legend.fontsize': 7,
        'xtick.labelsize': 5,
        'ytick.labelsize': 8,
        'text.usetex': False,
        }
pylab.rcParams.update(params)


## Parse command line
import optparse
parser = optparse.OptionParser(usage=__doc__, version=prof.version)
## Add standard options
prof.addDataCLOptions(parser, mc=True, ipol=False, scan=False)
#parser.add_option("--outdir", dest="OUTDIR", default=".",
                  #help="Store plots in this folder")
parser.add_option("--hname", dest="HNAME", default="out.aida",
                  help="File that the histos are stored in")
parser.add_option("--pname", dest="PNAME", default="used_params",
                  help="File that the used params are stored in")
parser.add_option("--ranges", dest="RANGES", default=None,
                  help="File with sampling boundaries")
parser.add_option("--visual", dest="VISUAL", default=False,
                  action="store_true",
                  help="Draw parameter-space occupancy in 3D using pyVisual")
prof.addLoggingCLOptions(parser)
prof.addOutputCLOptions(parser)
opts, args = parser.parse_args()

## Check if specified outdir exists and create it otherwise.
if not opts.VISUAL:
    outdir = os.path.join(opts.OUTDIR, "checkspace")
    prof.log.debug("Using %s for sampling output." % outdir)
    prof.io.makeDir(outdir)

## Turn on debugging and print initial messages
prof.writeGuideLine()

## Build DataProxy
dataproxy = prof.DataProxy.mkFromCLOptions(opts, checkAIDA=False)
mcdata = dataproxy.getMCData()


def plotParamDistributions(params):
    """
    Create 1D parameter distribution plot for all parameters in list params.
    """
    ## create figure and set size depending on nr of params
    fig = pylab.figure(facecolor='w')
    fig.set_figwidth(6)
    fig.set_figheight(len(params)*.15*fig.get_figwidth())

    ## create subplot for each param and plot params distribution in it
    for num, param in enumerate(params):
        if not param == "PROF_SCAN_PARAM":
            sub=fig.add_subplot(len(params), 1, num+1)
            plotSingleParamsDistribution(sub, param)

    ## adjust subplots, create title, save figure to file
    fig.subplots_adjust(left=0.15, right=0.85, bottom=0.1, top=0.9, wspace=0.8, hspace=.9)
    pylab.figtext(.5,.95, "Distribution of the anchor points", ha="center")
    fname = os.path.join(outdir, 'anchordist.pdf')
    pylab.savefig(fname)
    prof.log.info("Plot stored as %s" % fname)


def plotSingleParamsDistribution(sub, param):
    """
    1D plot(s): Iterate over all parameters and plot vertical lines at their value.
    Values from the failed runs are plotted in red, all others in blue
    """
    X_good = numpy.array(pdict[param])
    X_fail = numpy.array(fdict[param])

    sub.plot(X_good, numpy.zeros(len(X_good)), color='b', marker='|', ls=' ')
    sub.plot(X_fail, numpy.zeros(len(X_fail)), color='r', marker='|', ls=' ')

    ## green vertical lines at the param sampling boundaries
    sub.axvline(x=boundaries[param][1], ls='-', c='g', linewidth=0.2)
    sub.axvline(x=boundaries[param][0], ls='-', c='g', linewidth=0.2)

    ## xlimits at the param sampling boundaries
    sub.set_xlim(xmax=boundaries[param][1])
    sub.set_xlim(xmin=boundaries[param][0])

    ## turn off bounding box, ticks, ticklabels
    sub.set_frame_on(False)
    xtl = sub.xaxis.get_ticklines()
    for t in xtl:
        t.set_visible(False)
    ytl = sub.yaxis.get_ticklines()
    for t in ytl:
        t.set_visible(False)
    sub.set_yticklabels(())
    sub.set_yticks(( ))

    ## set sensible xticks
    xlabels=numpy.linspace(boundaries[param][0], boundaries[param][1], 5)
    sub.set_xticks(xlabels)
    sub.set_xticklabels(map(str, xlabels))

    ## set xlabel
    sub.set_xlabel(param)

def scatterParams(par1, par2):
    """ Produce 2D parameter-scatter plots for params par1 and par2
    """
    if not par1 and par2 in params:
        prof.log.error("Parameter names %s and %s are not among the available ones: %s" % (par1, par2, params))
        sys.exit(2)

    prof.log.debug("Creating scatter plot for params %s and %s" % (par1, par2))

    fig = pylab.figure(facecolor='w')
    sub = fig.add_subplot(1,1,1)
    sub.set_xlabel(par1)
    sub.set_ylabel(par2)

    X_good = numpy.array(pdict[par1])
    X_fail = numpy.array(fdict[par1])
    Y_good = numpy.array(pdict[par2])
    Y_fail = numpy.array(fdict[par2])

    sub.plot(X_good, Y_good, color='k', marker='o', ls=' ')
    sub.plot(X_fail, Y_fail, color='r', marker='o', ls=' ')


    sub.set_xlim(xmax=boundaries[par1][1])
    sub.set_xlim(xmin=boundaries[par1][0])

    sub.set_ylim(ymax=boundaries[par2][1])
    sub.set_ylim(ymin=boundaries[par2][0])
    pylab.figtext(.5,.95, "Scatter plot of anchor points", ha="center")
    fname = os.path.join(outdir, "%s-%s.pdf" % (par1, par2))
    pylab.savefig(fname)
    prof.log.info("Plot stored as %s" % fname)

def visualise3D():
    """ Setup the parameter axes, call 3D-draw command and wait for keyboard
    input
    """
    prof.log.info("Navigate through the sub-spaces using the buttons 'a', 'w' and 'd'.")
    prof.log.info("The origin is identical with the lower boundaries")
    global d
    global good
    global bad
    global labels
    good = []
    bad = []
    labels = []
    d = display(width=600, height=600, background=color.white)
    d.title = "Prof-X: interactive parameter (sub-) space eXplorer (N=%i)"%len(names)

    # Viewing direction when opening display for the first time
    d.forward = norm(vector(-1,-1,-2))

    # These are the axes
    for ax in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:
        arrow(axis=vector(ax), shaftwidth=0.0001, color=color.black)

    ## Draw parameter (sub) space for first three parameters
    # Use some integers to be able to swap parameter sub-spaces
    # easily
    ax_x = 0
    ax_y = 1
    ax_z = 2
    active = [names[ax_x], names[ax_y], names[ax_z]]
    drawParameterSpace(active)

    while True:
        ## Read keyboard input for warping into a different parameter sub-space
        k = d.kb.getkey()
        if k == "a":
            ax_x += 1
            active[0] = names[ax_x%len(names)]
            clearStage()
            drawParameterSpace(active)
        if k == "w":
            ax_y += 1
            active[1] = names[ax_y%len(names)]
            clearStage()
            drawParameterSpace(active)
        if k == "d":
            ax_z += 1
            active[2] = names[ax_z%len(names)]
            clearStage()
            drawParameterSpace(active)

def clearStage():
    """ Make all labels and spheres invisible in 3D mode"""
    for l in [good, bad, labels]:
        for t in l:
            t.visible = 0

def drawParameterSpace(params):
    """ Main function for 3D, draws 3D parameter occupancy for the three
    parameters given in the list params.
    """
    # Draw axes-labels
    labels.append(label(pos=(0, 0, 1), text="%s (%.3f ... %.3f)"%(
                params[0], boundaries[params[0]][0], boundaries[params[0]][1]),
                xoffset=-1, line=0)
                )
    labels.append(label(pos=(0, 1, 0), text="%s (%.3f ... %.3f)"%(
                params[1], boundaries[params[1]][0], boundaries[params[1]][1]),
                xoffset=1, line=0)
                )
    labels.append(label(pos=(1, 0, 0), text="%s (%.3f ... %.3f)"%(
                params[2], boundaries[params[2]][0], boundaries[params[2]][1]),
                xoffset=1, line=0)
                )

    # We need to stretch the points first such that the boundaries are equal
    # to values 0 ... 1 and then draw them
    def stretch(p, param):
        L = abs(boundaries[param][1]-boundaries[param][0])
        xrel = abs(p - boundaries[param][0])/L
        return xrel

    X_good = [stretch(p, params[0]) for p in pdict[params[0]]]
    X_fail = [stretch(f, params[0]) for f in fdict[params[0]]]
    Y_good = [stretch(p, params[1]) for p in pdict[params[1]]]
    Y_fail = [stretch(f, params[1]) for f in fdict[params[1]]]
    Z_good = [stretch(p, params[2]) for p in pdict[params[2]]]
    Z_fail = [stretch(f, params[2]) for f in fdict[params[2]]]

    # Plot balls
    for i in xrange(len(X_good)):
        ball = sphere(pos=(X_good[i], Y_good[i], Z_good[i]), radius=0.01)
        ball.color = (0, 0, 1)
        good.append(ball)
    for i in xrange(len(X_fail)):
        ball = sphere(pos=(X_fail[i], Y_fail[i], Z_fail[i]), radius=0.01)
        ball.color = (1, 0, 0)
        bad.append(ball)

## Find failed runs
failedruns = list()
for r in mcdata.availableruns:
    aida = os.path.join(opts.MCDIR, r, opts.HNAME)
    if os.path.isfile(aida) and os.path.getsize(aida) > 0:
        continue
    else:
        failedruns.append(r)

## Prepare two dictionaries for storing parameter name :: list pairs
names = mcdata.getParameterNames()
pdict, fdict = dict(), dict()

for param in names:
    pdict[param] = []
    fdict[param] = []

## Fill the prepared dictionaries with parameter values
for r in mcdata.availableruns:
    pp = mcdata.getRunParams(r)
    for name in names:
        if r in failedruns:
            # Append params from failed runs
            fdict[name].append(pp[name])
        else:
            # Append params from successful runs
            pdict[name].append(pp[name])


## Get param sampling boundaries
if opts.RANGES:
    boundaries = prof.ParameterRange.mkFromFile(opts.RANGES).asDict()
else:
    prof.log.warning("No ranges specified, be careful how to interprete the")
    prof.log.warning("output or try again using the --ranges CL option")
    boundaries = dict()
    for name in names:
        pmin = min(pdict[name] + fdict[name])
        pmax = max(pdict[name] + fdict[name])
        boundaries[name] = (pmin, pmax)


# See if we shall explore the parameter-space in 3D
if opts.VISUAL:
    if not HAVEVISUAL:
        prof.log.error("Python visual not available")
        sys.exit(1)
    if len(names) < 3:
        prof.log.error("Dim. of parameter-space (%s) to small for 3D"%len(names))
        sys.exit(1)
    visualise3D()

else:
    ## Create output directory for plots

    if not args:
        plotParamDistributions(names)
    elif len(args) == 1:
        if args[0] in names:
            for par2 in names:
                scatterParams(args[0], par2)
        else:
            from professor.tools.permut import xuniqueCombinations
            prof.log.info("Creating scatter plots for all param combinations...")
            for par1, par2 in xuniqueCombinations(params, 2):
                scatterParams(par1, par2)

    elif len(args)==2:
        prof.log.info("Creating scatter plot for %s and %s"%(args[0], args[1]))
        scatterParams(args[0], args[1])
    else:
        prof.log.error("Too many arguments")
        sys.exit(1)

sys.exit(0)
