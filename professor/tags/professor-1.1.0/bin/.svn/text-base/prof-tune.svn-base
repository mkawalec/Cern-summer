#! /usr/bin/env python

"""\
%prog --datadir DATADIR [--ipoldir IPOLDIR] --weights OBSFILE [--runsfile RUNSFILE]

%prog --refdir REFDIR --ipoldir IPOLDIR --weights OBSFILE [--runsfile RUNSFILE]

Minimise a goodness of fit (GoF) measure using pre-built MC-interpolations from
IPOLDIR against reference data in REFDIR. The MC-interpolations must be created
with prof-interpolate before running %prog.

If only the DATADIR variable is used to specify input file locations, it is
assumed that the saved interpolations are to be found in DATADIR/ipol, and that
the reference data is in DATADIR/ref. The --refdir and --ipoldir switches can be
used to specify the information explicitly or to override one of the guesses
made using the --datadir value.

The same format of observable weights file (and indeed same file!) as used for
prof-interpolate can be used to specify the observable or bin/range-wise weights
which will enter into the GoF calculation. However, it is of course necessary
that the bins for which weights are requested exist in the stored
interpolations: hence the observables specified at this stage should be a subset
of those used for prof-interpolate. To build output histograms but not include
an observable in the optimisation measure, use a weight of 0.

The RUNSFILE is used to restrict the run combinations for which optimisations
will be calculated. As for the observables specified in the weights file,
interpolations must exist for the requested run combinations. If unspecified, it
will be assumed that a file called runcombs.dat exists and is to be used.

TODO:
  * read in histogram titles
  * check result is in-/outside limits
  * use limits dynamically determined from runcomb
  * threading?? Just use prof-batchtune
"""

import sys, os
import professor.user as prof

from professor.tools import shell as shell
ipshell = shell.usePrettyTraceback()
shell.setProcessName("prof-tune")


## Set up signal handling
import signal
global RECVD_KILL_SIGNAL
RECVD_KILL_SIGNAL = None
def handleKillSignal(signum, frame):
    """
    Declare us as having been signalled, and return to default handling
    behaviour.
    """
    prof.log.critical("Signal handler called with signal " + str(signum))
    prof.log.critical("Waiting for this minimization to finish...")
    global RECVD_KILL_SIGNAL
    RECVD_KILL_SIGNAL = signum
    signal.signal(signum, signal.SIG_DFL)
## Signals to handle
signal.signal(signal.SIGTERM, handleKillSignal);
signal.signal(signal.SIGHUP,  handleKillSignal);
signal.signal(signal.SIGINT,  handleKillSignal);
signal.signal(signal.SIGUSR2, handleKillSignal);


## Build command-line options parser
import optparse
parser = optparse.OptionParser(usage=__doc__, version=prof.version)

## Add standard Prof options
prof.addDataCLOptions(parser, mc=True, ref=True, ipol=True, scan=False)
prof.addRunCombsCLOptions(parser)
prof.addIpolCLOptions(parser)
prof.addOutputCLOptions(parser)

## Tuning options
group = optparse.OptionGroup(parser, "Tuning")
group.add_option("--outfile", dest="OUTFILE", metavar="FILE.pkl", default="results.pkl",
                 help="Store results in here. [default: OUTDIR/tunes/%default]")
group.add_option("--snapshot", dest="SNAPSHOT", action="store_true", default=False,
                 help="Save snapshot result files during minimization every "
                      "10 results. [default: off]")
group.add_option("--no-ipolhistos", dest="SAVEIPOLHISTOS",
                 action="store_false", default=True,
                 help="Switch off interpolation histogram storing.")
group.add_option("--no-params", dest="SAVEPARAMS",
                 action="store_false", default=True,
                 help="Switch off creating parameter files with tune results.")
group.add_option("--runnum-offset", dest="IRUNOFFSET", metavar="N", default=0, type=int,
                 help="Offset the runcomb variation index by the given value [default: %default]")
parser.add_option_group(group)

mingroup = optparse.OptionGroup(parser, "Minimizer")
mingroup.add_option("--minimizer", choices=("pyminuit", "scipy"),
                    dest="MINIMIZER", default="pyminuit",
                    help="Select the minimizer to use (pyminuit|scipy)"
                         " [default: %default]")
# mingroup.add_option("--migrad", dest="USEMIGRAD", action="store_false",
#                     default=False, help="When using Minuit, use MIGRAD to estimate the "
#                          "parameter errors [default: on]")
mingroup.add_option("--minos", dest="USEMINOS", action="store_true",
                    default=False, help="When using Minuit, use MINOS to estimate the "
                    "parameter errors [default: off]")
mingroup.add_option("--print-minuit", dest="PRINTMINUIT", type="choice",
                    choices=("0","1","2","3"), metavar="N", default="0",
                    help="When using Minuit, set printMode to the given"
                         " value. [default: %default]")
mingroup.add_option("--limits", dest="LIMITS", default=None, metavar="FILE",
                    help="File with parameter limits for Minuit. E.g. the"
                         " file used to create the MC sample points.")
mingroup.add_option("--spmethods", "--start-points", metavar="FOO,BAR",
                    dest="STARTPOINTMETHODS", default="center",
                    help="Comma separated list with minimisation starting"
                    " point methods. [default: %default]")
mingroup.add_option("--manual-sp", "--manual-startpoint",
                    dest="MANUALSTARTPOINT", metavar="FOO=N,BAR=M",
                    help="Comma separated list of parameter name - value"
                         " pairs to be used as manual startpoints when"
                         " spmethod 'manual' is selected. Name and value are"
                         " separated by an equals sign ('='), e.g."
                         " PARJ(21)=1.2,PARJ(22)=2.4 . Unspecified parameters"
                         " are chosen randomly.")
mingroup.add_option("--fixed-parameters", dest="FIXEDPARAMETERS",
                    metavar="FOO=N,BAR=M",
                    help="Comma separated list of parameter name - value"
                         " pairs with parameter values to be fixed during"
                         " minimization. Format is the same as with"
                         " '--manual-startpoint', e.g."
                         " PARJ(21)=1.2,PARJ(22)=2.4 . NB: Only supported by"
                         " pyminuit!")
mingroup.add_option("--error-tunes", dest="ERRORTUNES",
                    default=False, action="store_true",
                    help="Make eigentunes from covariance matrix [experimental]")
parser.add_option_group(mingroup)

## Add standard logging control
prof.addLoggingCLOptions(parser, logoswitch=True)

## Parse arguments (and correct type on Minuit log level)
opts, args = parser.parse_args()
opts.PRINTMINUIT = int(opts.PRINTMINUIT)


## Set up logging level and print initial messages
prof.log.setPriority(opts)
if opts.SHOW_LOGO:
    prof.writeLogo()
prof.writeGuideLine()


## Test if we can read input ipols and ref data
dirs_ok = True
paths = prof.DataProxy.getPathsFromCLOptions(opts)
ipoldir = paths["ipol"]
if not ipoldir:
    prof.log.error("No interpolation directory given: Use the --datadir or --ipoldir option!")
    dirs_ok = False
refdir = paths["ref"]
if not refdir:
    prof.log.error("No reference data directory given: Use the --datadir or --refdir option!")
    dirs_ok = False
if not dirs_ok:
    sys.exit(1)

## Ensure that we can write to output directories
OUTDIR = paths["outdir"]
if not OUTDIR:
    prof.log.error("No output directory given: Use the --datadir or --outdir option!")
    sys.exit(1)
## Tune data dir
TUNEOUTDIR = os.path.join(OUTDIR, "tunes")
prof.log.debug("Using %s for tune param & pickle file storage" % TUNEOUTDIR)
prof.io.makeDir(TUNEOUTDIR)
TUNEOUTFILE = os.path.join(TUNEOUTDIR, opts.OUTFILE)
## Ipol histo dir
if opts.SAVEIPOLHISTOS:
    IPOLHISTOOUTDIR = os.path.join(OUTDIR, "ipolhistos")
    prof.log.debug("Using %s for interpolation histo storage" % IPOLHISTOOUTDIR)
    prof.io.makeDir(IPOLHISTOOUTDIR)
    if not prof.io.isDirW(IPOLHISTOOUTDIR):
        prof.log.error("Output directory for interpolation histograms"
                       " is not a directory or has bad permissions:"
                       " %s" % IPOLHISTOOUTDIR)
        prof.log.error("Exiting!")
        sys.exit(1)
else:
    prof.log.debug("Not storing any histogram data for later plotting.")


## Get a DataProxy object (core object for tuning data)
dataproxy = prof.DataProxy.mkFromCLOptions(opts)

## Get the specified interpolation class. We're only interested in the order
## of the polynomial to construct the file name of the ipol pickles. This is
## not necessarily the exact interpolation method used. I.e. IpolCls will
## always refer to the pure-Python implementation but the pickled files
## might contain the Weave version.
try:
    IpolCls = prof.getInterpolationClass(opts.IPOLMETHOD, False)
    prof.log.info("Using %s polynomial for interpolation." % IpolCls.method)
except Exception, e:
    prof.log.error("Problem getting interpolation method: %s" % e)
    prof.log.error("Exiting!")
    sys.exit(1)


## Get the specified minimizer class.
try:
    MinimizerCls = prof.getMinimizerClass(opts.MINIMIZER, useminos=opts.USEMINOS,
                                          printminuit=opts.PRINTMINUIT)
    prof.log.debug('Using %s as minimizer.' % MinimizerCls.__name__)
except Exception, e:
    prof.log.error("Problem getting minimizer: %s" % e)
    prof.log.error("Exiting...")
    sys.exit(1)


## Read limits file
if opts.LIMITS is not None:
    prof.io.testReadFile(opts.LIMITS)
    limits = prof.ParameterRange.mkFromFile(opts.LIMITS)
    prof.log.debug("Using minimisation limits from %s: %s" % (opts.LIMITS, limits))
else:
    limits = None
    prof.log.debug("Not using minimisation limits.")


## Parse fixed parameter option
fixedparams = None
if opts.FIXEDPARAMETERS is not None:
    fixedparams = prof.ParameterPoint.mkFromString(opts.FIXEDPARAMETERS)

## Parse start point methods
spmethods = opts.STARTPOINTMETHODS.split(',')
manualsp = None
if opts.MANUALSTARTPOINT is not None:
    manualsp = prof.ParameterPoint.mkFromString(opts.MANUALSTARTPOINT)


## Load run combinations
allruns = []
if opts.RUNSFILE:
    prof.log.debug("Using %s as runsfile" % opts.RUNSFILE)
    try:
        rcm = prof.RunCombManager.mkFromFile(opts.RUNSFILE)
        allruns = rcm.runcombs
    except Exception, e:
        prof.log.error("Error while opening run combination file %s: %s" % (opts.RUNSFILE, e))
        sys.exit(1)
else:
    prof.log.debug("No run combination file given! Using all available runs.")
    allruns.append(dataproxy.getMCData().availableruns)
prof.log.info("Loaded %i run combinations" % len(allruns))


## Select the observables we want to use for our tune
weights = None
if opts.OBSERVABLEFILE:
    try:
        prof.io.testReadFile(opts.OBSERVABLEFILE)
        weights = prof.WeightManager.mkFromFile(opts.OBSERVABLEFILE)
    except Exception, e:
        prof.log.error("Problem when reading observable file: %s" % e)
        prof.log.error("Exiting!")
        sys.exit(1)
    prof.log.debug("Loaded observable file from %s" % opts.OBSERVABLEFILE)
else:
    prof.log.debug("No observable file given! Using all available observables.")
    weights = prof.WeightManager()
    for obsname in dataproxy.getMCData().getAvailableObservables():
        weights.addBinRangeWeight(obsname)
prof.log.debug("Loaded observables: %s" % weights)


## Check that all interpolations are available in ipoldir
for runs in allruns:
    path = dataproxy.getIpolFilePath(IpolCls, runs)
    if not os.path.exists(path):
        prof.log.error("Could not find interpolation file for runs %s in"
                       " ipoldir %s: %s" % (sorted(runs), dataproxy.ipolpath, path))
        prof.log.error("Please call prof-interpolate with the correct"
                       " arguments before using this program to build"
                       " interpolation files!")
        prof.log.error("Exiting!")
        sys.exit(1)


## Build snapshot file name
if opts.SNAPSHOT:
    base, ext = os.path.splitext(TUNEOUTFILE)
    snapfilename = base + "-snap" + ext


## Define goodness of fit class to be used for tuning
# TODO: Be able to choose among different GoFs... load user-specified ones with evalfile?
gofcls = prof.SimpleIpolChi2


def tune(gofobject, spmethod="center"):
    ## TODO: Clean this up: uses lots of undeclared global variables

    ## TODO? Limiting to run-specific parameter ranges. (Not possible with
    ## the data we have?)

    ## Instantiate minimizer
    minimizer = MinimizerCls()
    msg = "Starting minimiser...\n"
    msg += "  using spmethod %s\n" % spmethod
    msg += "  using manualsp %s\n" % manualsp
    msg += "  using limits %s\n" % limits
    msg += "  using fixedpars %s" % fixedparams
    prof.log.debug(msg)

    ## Run minimizer on provided GoF
    result = minimizer.minimize(gofobject,
                                spmethod=spmethod, manualsp=manualsp,
                                limits=limits, fixedpars=fixedparams)
    print result.ipolmethod

    # This is now done by MinimizerCls.minimize
    # result.ipolmethod = IpolCls
    return result


## Do tuning for each run combination, and append to the ResultList
reslist = prof.ResultList()
nummins = len(allruns)*len(spmethods)
for irun, runs in enumerate(allruns):
    for imeth, spmethod in enumerate(spmethods):
        ## TODO: add loop over weights files?
        itune = len(spmethods) * (irun + opts.IRUNOFFSET) + imeth
        itune_name = "tune%03i" % itune
        prof.log.info("Starting %i/%i tune..." % (itune+1, nummins))
        try:
            ## Load interpolation set
            path = dataproxy.getIpolFilePath(IpolCls, runs)
            prof.log.debug("Loading ipolset from %s" % path)
            ipolset = prof.InterpolationSet.mkFromPickle(path)
            prof.log.debug("Loaded interpolation set %s" % (ipolset))
            ipolhistonames = ipolset.getHistogramNames()

            prof.log.debug("Creating TuneData")
            tundat = dataproxy.getTuneData(withref=True, useipol=IpolCls,
                                           useobs=weights.observables, useruns=runs)
            tundat.applyObservableWeightDict(weights)
            ## TODO: Add "epsilon error" to alleviate these.
            ## TODO: We need to have a way to detect empty bins explicitly rather than guessing from zero-size errors.
            tundat.vetoEmptyErrors()

            ## Make GoF object for this ipol and tunedata
            gof = gofcls(tundat)

            ## Make tune
            result = tune(gof, spmethod)
            prof.log.info("Minimizer returned:\n%s\n" % result)
            reslist.append(result)

            # TODO: This merged-dat file is not a very useful format: can we write out an AIDA file or separate dat files instead?
            def mkIpolHistos(result, tundat, outpath):
                prof.log.debug("Writing interpolation histos to %s" % outpath)
                f = open(outpath, "w")
                f.write('<?xml version="1.0" encoding="ISO-8859-1" ?>\n')
                f.write('<!DOCTYPE aida SYSTEM "http://aida.freehep.org/schemas/3.3/aida.dtd">\n')
                f.write('<aida version="3.3">\n')
                for obs in sorted(tundat.observables):
                    f.write(tundat.getInterpolationHisto(obs, result).asAIDA() + "\n\n")
                f.write("</aida>\n")
                f.close()

            ## Store interpolation histograms for central tune
            if opts.SAVEIPOLHISTOS:
                ipolhistodir = os.path.join(IPOLHISTOOUTDIR, "histos-%s" % itune_name)
                prof.io.makeDir(ipolhistodir)
                ipolhistofile = os.path.join(ipolhistodir, "%s-0.aida" % itune_name)
                mkIpolHistos(result, tundat, ipolhistofile)

            ## Write out params files
            paramsdir = os.path.join(TUNEOUTDIR, "params-%s" % itune_name)
            if opts.SAVEPARAMS:
                prof.io.makeDir(paramsdir)
                paramsfile = os.path.join(paramsdir, "%s-0.params" % itune_name)
                result.values.writeParamFile(paramsfile)


            ## Create variations on optimal result vector by going in the 2N +- principle direction vectors
            if opts.ERRORTUNES:
                prof.log.info("Eigentunes:")
                import numpy
                from professor.tools import eigen

                def mkDeltaTune(result, i, scale):
                    covmat = result.covariance
                    T_transp, S, T = eigen.eigenDecomposition(covmat)
                    delta = scale * numpy.sqrt(S[i])
                    eigenbasis_unitvec = list(numpy.zeros(len(result.values)))
                    eigenbasis_unitvec[i] = 1
                    eigenbasis_vec = delta * numpy.matrix(eigenbasis_unitvec)
                    result_params_trf = (T_transp * numpy.matrix(result.values).transpose()).transpose()
                    etune_params_trf = result_params_trf + eigenbasis_vec
                    etune_params_t = T * etune_params_trf.transpose()
                    etune_params = numpy.array(etune_params_t.transpose().tolist()[0])
                    etune_unscaled = prof.ParameterTune(result.values.keys(), etune_params, runs=runs, obs=weights.observables)
                    return S[i], etune_unscaled

                NUM_SIGMA = 1
                for i in xrange(len(result.values)):
                    splus, tune_plus = mkDeltaTune(result, i, +NUM_SIGMA)
                    tune_plus_name = "Eigentune %02d+" % (i+1)
                    gof.setParams(tune_plus)
                    prof.log.info(tune_plus_name + " (lambda = %e, GoF = %e)\n%s" % (splus, gof.calcGoF(), tune_plus))
                    prof.log.info("Delta(p) = %s\n" % (tune_plus - result.values))
                    sminus, tune_minus = mkDeltaTune(result, i, -NUM_SIGMA)
                    tune_minus_name = "Eigentune %02d-" % (i+1)
                    gof.setParams(tune_minus)
                    prof.log.info(tune_minus_name + " (lambda = %e, GoF = %e)\n%s\n" % (sminus, gof.calcGoF(), tune_minus))
                    prof.log.info("Delta(p) = %s\n" % (tune_minus - result.values))
                    # import numpy
                    # for s in numpy.linspace(-1.1, 1.1, num=23):
                    #     mys, mytune = mkDeltaTune(result, i, s)
                    #     gof.setParams(mytune)
                    #     print s, gof.calcGoF()

                    ## Store interpolation histograms for error tunes
                    if opts.SAVEIPOLHISTOS:
                        ipolhistofile_plus = os.path.join(ipolhistodir, "%s-%s.aida" % (itune_name, tune_plus_name))
                        mkIpolHistos(tune_plus, tundat, ipolhistofile_plus)
                        ipolhistofile_minus = os.path.join(ipolhistodir, "%s-%s.aida" % (itune_name, tune_minus_name))
                        mkIpolHistos(tune_minus, tundat, ipolhistofile_minus)

                    ## Store params files for error tunes
                    if opts.SAVEPARAMS:
                        paramsfile_plus = os.path.join(paramsdir, "%s-%s.params" % (itune_name, tune_plus_name))
                        result.values.writeParamFile(paramsfile_plus)
                        paramsfile_minus = os.path.join(paramsdir, "%s-%s.params" % (itune_name, tune_minus_name))
                        result.values.writeParamFile(paramsfile_minus)


        except prof.MinimizerError, err:
            prof.log.error("Minimizer error for this tuning attempt: %s" % err)
            prof.log.error("No result is saved!")
            continue
        except IOError, ioe:
            prof.log.error("Error when retrieving interpolation: %s" %ioe)
            prof.log.error("No result computed.")
            continue
        except KeyboardInterrupt:
            prof.log.critical("Keyboard interrupt detected, you'll have to "
                              "make do with only %i results." % len(reslist))
            break
        if RECVD_KILL_SIGNAL is not None:
            prof.log.critical("Leaving loop early due to signal %s: you'll "
                              "have to make do with only %i results." %
                              (RECVD_KILL_SIGNAL, len(reslist)))
            break
        if opts.SNAPSHOT and len(reslist) % 10 == 0:
            prof.log.info("Creating %i results snapshots in %s" %
                          (len(reslist), snapfilename))
            reslist.write(snapfilename)
    if RECVD_KILL_SIGNAL is not None:
        break

prof.log.debug("Writing results: %s" % TUNEOUTFILE)
# TODO: Include error tunes in some ResultCollectionList-type object for pickling
reslist.write(TUNEOUTFILE)
if opts.SNAPSHOT and len(reslist) >= 10:
    prof.log.warn("Snapshots were written to %s. " % snapfilename +
                  "You can remove this file now.")
