#! /usr/bin/env python

"""\
Usage: %prog [options] --refdir <REFDIR> --weights WEIGHTS <TUNEDIR>[:<LABEL>]  [...]

Calculate the goodness of fit for different tunes based on the weights in
WEIGHTS. Tunes must be given as directories that contain a `out.aida' file
with the MC data and a `used_params' file.

Labels for each tune can be given by appending a `:mylabel'. Note the colon!

Example:
  %prog --refdir datahistos --weights my.weights tune1/:"very good tune"
"""

import os.path
import professor.user as prof

import optparse
parser = optparse.OptionParser(usage=__doc__, version=prof.version)
# TODO: Make this the default behaviour
parser.add_option("--no-weights",
        dest="NOWEIGHTS",
        action="store_true",
        default=False,
        help="Use weight=1.0 for all non-zero weighted observables in"
             " WEIGHTS instead of the numerical value.")
parser.add_option("--per-bin",
        dest="PERBIN",
        action="store_true",
        default=False,
        help="Calculate the per-bin chi^2 for non-zero weighted observables.")
prof.addDataCLOptions(parser, mc=False, ref=True, ipol=False, scan=False)
prof.addLoggingCLOptions(parser)
opts, args = parser.parse_args()

prof.log.setPriority(opts)
prof.writeGuideLine()


## Get a DataProxy object
dataproxy = prof.DataProxy.mkFromCLOptions(opts)

## Read in MC histo files
mcdata = prof.ManualMCData()
for mcfile in args:
    tokens = mcfile.split(":")
    ## Call normpath to strip trailing slashes. This is necessary for the
    ## automatic tune-label generation.
    path = os.path.normpath(tokens[0])
    prof.io.testReadDir(path)
    if len(tokens) > 1:
        tunelabel = tokens[1]
    else:
        tunelabel = os.path.basename(path)
        tunelabel = os.path.splitext(tunelabel)[0]
    mcdata.addRunPath(tunelabel, path)
dataproxy.addMCData(mcdata, "tunes")


## Read in observable/weights file.
if opts.OBSERVABLEFILE:
    wm = prof.WeightManager.mkFromFile(opts.OBSERVABLEFILE)
    obsdict = dict([(obs, wm.getWeights(obs).values()[0])
                    for obs in wm.observables])
    prof.log.info("Reading observables from %s (%i observables)" % (opts.OBSERVABLEFILE, len(wm.observables)))
    if opts.NOWEIGHTS:
        prof.log.info("Will use simplified weights definition:"
                     " all observables that have a non-zero bin-weight get"
                     " a weight of 1.0")
        wm2 = prof.WeightManager()
        for obs in wm.observables:
            obsweight = wm[obs]
            if max(obsweight.values()) > 0.0:
                wm2.addBinRangeWeight(obs)
        wm = wm2
else:
    ## Build dummy WeightManager with 1.0 weights for the available
    ## observables in all MC tunes (i.e. the intersection). Start with a
    ## list of valid observables, i.e. no NaN histograms.
    tunes = mcdata.availableruns
    histos = set(mcdata.availablehistos)
    for tunelabel in tunes[1:]:
        histos.intersection_update(mcdata.getRunHistos(tunelabel).keys())
    wm = prof.WeightManager()
    for obs in histos:
        wm.addBinRangeWeight(obs)
    prof.log.info("Using the intersection of observables in ref. and MC data (%i observables)." % len(histos))

try:
    tunedata = dataproxy.getTuneData(withref=True, withmc="tunes", useobs=wm.observables)
    # TODO: Are we hiding a bigger problem here? I.e. should the unfilled bins be detected explicitly?
    tunedata.vetoEmptyErrors()
    tunedata.applyObservableWeightDict(wm)
except Exception, e:
    import sys
    sys.stderr.write("\nProblem when getting tuning data: %s\n" % e)
    sys.exit(1)

tunes = sorted(mcdata.availableruns)

## Calculate and print chi2/Ndf for each observable
if opts.PERBIN:
    from professor.fitfunctions import SingleSimpleMCChi2
    obs = sorted(wm.posWeightObservables)
    chi2perbingof = SingleSimpleMCChi2(tunedata, obs[0], tunes[0])
    wobs = max(map(len, obs))
    colsep = "  "
    print (r"obs \ chi2/bin".center(wobs) + colsep
            + colsep.join([t.center(10) for t in tunes]))
    print (wobs + (len(tunes))*len(colsep) + len(tunes)*10) * "-"
    for o in obs:
        line = o.ljust(wobs)
        for t in tunes:
            chi2perbingof.obs = o
            chi2perbingof.run = t
            line += colsep + "%10.5f" % (chi2perbingof.calcChi2PerBin())
        print line
    print (wobs + (len(tunes))*len(colsep) + len(tunes)*10) * "-"


## Build GoF calculator.
from professor.fitfunctions import SimpleMCChi2
chi2gof = SimpleMCChi2(tunedata, tunes[0])
print "Please note: The chi2 does NOT include the MC uncertainty as estimated"
print "    by the median MC error of all runs."

wtune = max(map(len, tunes))
for tune in tunes:
    chi2gof.run = tune
    chi2 = chi2gof.calcChi2()
    sumw = chi2gof.calcNdof()
    npar = mcdata.getRunParams(tune).dim
    print "%s  chi2/Ndf = %f = %f/(%f-%f)" % (tune.ljust(wtune),
            chi2/(sumw-npar), chi2, sumw, npar)
