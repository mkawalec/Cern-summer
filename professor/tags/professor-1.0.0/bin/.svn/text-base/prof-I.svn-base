#! /usr/bin/env python

"""
%prog [--refdir ref] --ipoldir ipol --runsfile runcombs.dat

%prog visualises histograms derived from the parameterisation of MC generators,
allowing the effects of parameter variations to be investigated interactively in
real-time using a friendly GUI. %prog could in principle also be used for a
manual generator tuning but is mostly useful for exploring the effects of
parameters and determining whether and how particular data features can be
explained within the model which has been parameterised.

TODO:
    * Errorbars for ipolhistos
    * Use mathtext/LaTeX to display the histo-titles properly
"""

import os, sys
import professor.user as prof

from professor.tools import shell
shell.usePrettyTraceback()
shell.setProcessName("prof-I")


## Call these first to prevent memory leakage
import matplotlib
matplotlib.use('WXAgg')
from matplotlib.figure import Figure
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigCanvas
from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg as NavigationToolbar

import wx, functools


# Setting matplotlib properties
params = {
    'backend': 'pdf',
    'axes.labelsize': 16,
    'text.fontsize': 16,
    'legend.fontsize': 16,
    'axes.titlesize': 16,
    'xtick.labelsize': 16,
    'ytick.labelsize': 16,
    'text.usetex': False,
    'text.latex.preamble': [r'\usepackage{amsmath}'],
    'figure.dpi': 50,
    'lines.markersize': 7.5,
    'lines.antialiased' : False,
    'patches.antialiased' : False,
    'figure.subplot.left' : 0.03,
    'figure.subplot.right' : 0.995,
    'figure.subplot.bottom' : 0.1,
    'figure.subplot.top' : 0.95,
    'figure.subplot.wspace' : 0.05
    }
matplotlib.rcParams.update(params)


## Option parsing
import optparse
parser = optparse.OptionParser(usage=__doc__, version=prof.version)
parser.add_option("-i", "--ipolset", dest="IPOLSET", default=None,
                  help="File containing a previously-calculated interpolation set")
parser.add_option("-M", "--mccomparefile", dest="MCCOMPAREFILE", default=None,
                  help="MC runfile (aida) to be plotted for comparison")
prof.addRunCombsCLOptions(parser)
parser.add_option("-t", "--translate", dest="translate", default=os.path.realpath(
                    os.path.join(prof.__file__, "../../../contrib/parametermap.txt")),
                  help="Text file that maps parameter names to descriptions.")
prof.addLoggingCLOptions(parser, logoswitch=True)
prof.addDataCLOptions(parser, mc=False, ref=True, ipol=True, scan=False)
prof.addIpolCLOptions(parser, weaveswitch=False)
opts, args = parser.parse_args()


## Set up logging level and print initial messages
prof.log.setPriority(opts)
if opts.SHOW_LOGO:
    prof.writeLogo()
prof.writeGuideLine()


## Check arguments
## TODO: Should work okay without needing to be told
if not opts.RUNSFILE:
    prof.log.error("No runcombs file given, exiting!")
    sys.exit(1)


## Get the configured interpolation class
try:
    IpolCls = prof.getInterpolationClass(opts.IPOLMETHOD, False)
    prof.log.info("Using %s for interpolation." % IpolCls.__name__)
except Exception, e:
    prof.log.error("Problem getting interpolation method: %s" % e)
    prof.log.error("Exiting!")
    sys.exit(1)


dataproxy = prof.DataProxy.mkFromCLOptions(opts)
prof.log.debug("refdir: %s" % opts.REFDIR)
prof.log.debug("ipoldir: %s" % dataproxy.ipolpath)


## Read first line of runcombs file
# TODO: There should be a helper to do this transparently
f = open(opts.RUNSFILE, "r")
runs = f.readline().strip().split()
f.close()


## Check if an observable file was specified
if opts.OBSERVABLEFILE is None:
    ## Load the list of observables from an interpolation set if not
    ## explicitely given.
    ipolset = dataproxy.getInterpolationSet(IpolCls, runs)
    observables = sorted(ipolset.getHistogramNames())
else:
    wm = prof.WeightManager()
    wm.loadWeightsFile(opts.OBSERVABLEFILE)
    observables = sorted(wm.observables)


## Load ref data and interpolation in TuneData object
tundat = dataproxy.getTuneData(withref=bool(opts.REFDIR), useipol=IpolCls,
                               useobs=observables, useruns=runs)


## TODO: move to professor.tools.utils module
def getDict(keys, values=None):
    if values is None:
        return dict.fromkeys(keys)
    else:
        # return dict([(key, values[num]) for num, key in enumerate(keys)])
        # This should to the same.
        return dict(zip(keys, values))


## TODO: move to professor.tools.utils module
def sanitizeLatexString(tex):
    for i in ["$", "\\", "{", "}", "_", "^"]:
        tex=tex.replace(i,"")
    return tex


def plotRefHisto(sub, obs):
    if opts.REFDIR:
        x,y,ye = [], [], []
        for b in dataproxy.getRefHisto(obs).getBins():
            x.append(b.getBinCenter())
            y.append(b.getYVal())
            ye.append(b.getYErr())
        sub.errorbar(x,y, yerr=ye, ls=" ", marker="o", color="k", label="Data")
    try:
        pp = prof.PlotParser()
        headers = pp.getHeaders(obs)
        title = sanitizeLatexString(headers["Title"])
        sub.set_title(title, ha="center")
    except:
        pass


def plotLabel(sub, label, x=0.5, y=-0.1, color="b", ha="left"):
    sub.text(x,y, label, ha=ha, color=color, transform=sub.transAxes,
            fontsize=20)


def getLine(hist):
    x=[]
    y=[]
    for b in hist.getBins():
        for r in b.getXRange():
            x.append(r)
            y.append(b.getYVal())
    return x, y


class ProfIFrame(wx.Frame):
    def __init__(self):
        title = 'prof-I: Professor-Interactive'
        wx.Frame.__init__(self, None, -1, title)
        self.sliders = {}
        self.showchisq = False
        self.valtexts = {}
        self.mchistos= {}
        self.fixparams = {}
        self.mccomphistos ={}
        if opts.MCCOMPAREFILE is not None:
            self.mccomphistos = prof.Histo.fromAIDA(opts.MCCOMPAREFILE)
        self.histos = {}
        self.limits = {}
        self.titles = {"left":None,  "right":None}
        self.drawobs ={"left":sorted(observables)[0], "right":sorted(observables)[0]}
        self.params = sorted(tundat.paramranges.names)
        self.npars = len(self.params)
        self.gofs = {"left":self.getGoF(self.drawobs["left"]),  "right":self.getGoF(self.drawobs["left"])}
        self.create_menu()
        self.createMainPanel()
        self.sliderUpdate(None, redraw=False)
        self.updateObs(None, "left")
        self.updateObs(None, "right")
        self.updateMCRun(None)


    def create_menu(self):
        self.menubar = wx.MenuBar()
        menu_file = wx.Menu()
        m_loadMC = menu_file.Append(-1, "&Load MC File\tCtrl-L", "Load MC File")
        m_loadPar = menu_file.Append(-1, "Load &Parameter File\tCtrl-P", "Load Parameter File")
        m_loadResult = menu_file.Append(-1, "Load Minimisation &Result\tCtrl-R", "Load  Minimisation Result")
        m_savePar = menu_file.Append(-1, "S&ave current parameters\tCtrl-a", "Save current parameters")
        m_exit = menu_file.Append(-1, "&Quit\tCtrl-Q", "Quit")
        self.Bind(wx.EVT_MENU, self.on_loadMC, m_loadMC)
        self.Bind(wx.EVT_MENU, self.on_loadPar, m_loadPar)
        self.Bind(wx.EVT_MENU, self.on_loadResult, m_loadResult)
        self.Bind(wx.EVT_MENU, self.on_savePar, m_savePar)
        self.Bind(wx.EVT_MENU, self.on_exit, m_exit)

        menu_help = wx.Menu()
        m_about = menu_help.Append(-1, "&About\tF1", "About the demo")
        self.Bind(wx.EVT_MENU, self.on_about, m_about)
        self.menubar.Append(menu_file, "&File")
        self.menubar.Append(menu_help, "&Help")
        self.SetMenuBar(self.menubar)


    def on_exit(self, event):
        self.Destroy()


    def on_about(self, event):
        msg = """ Prof-I: Professor-Interactive:
         * Use the sliders to adjust parameters
         * The resulting interpolation histogram is displayed
         * Choose a MC run from the dropdown list for comparison
           Use the button 'Set Params' to set sliders to
           parameters loaded from file or result
        """
        dlg = wx.MessageDialog(self, msg, "About", wx.OK)
        dlg.ShowModal()
        dlg.Destroy()


    def on_savePar(self, event):
        current = self.getCurrentParamValues()
        dialog = wx.FileDialog ( None, style = wx.SAVE )
        if dialog.ShowModal() == wx.ID_OK:
            outfile = dialog.GetPath()
            f=open(outfile,"w")
            for num, p in enumerate(self.params):
                f.write("%s   %f\n"%(p, current[num]))
            f.close()
        else:
            prof.log.error("No filename specified")
        dialog.Destroy()


    def on_loadMC(self, event):
        wildcard = "AIDA histogram files (*.aida)|*.aida|" \
                "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(),
                "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            self.mccomphistos = prof.Histo.fromAIDA(dialog.GetPath())
        dialog.Destroy()
        self.updateMCRun(None)


    def on_loadPar(self, event):
        wildcard = "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(),
                "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            self.fixparams = prof.ParameterPoint.mkFromFile(dialog.GetPath())
        dialog.Destroy()


    def on_loadResult(self, event):
        wildcard = "Result files (*.pkl)|*.pkl|" \
                "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(),
                "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            R = prof.ResultList.mkFromPickle(dialog.GetPath())[0]
            self.fixparams = R.values
        dialog.Destroy()


    def createMainPanel(self):
        """ Creates the main panel with all the controls on it:
             * mpl canvas
             * mpl navigation toolbar
             * Control panel for interaction
        """
        self.dpi=50
        self.panel = wx.Panel(self)
        # Panel for observable diplay
        #
        self.fig = Figure((10.0, 4.0), dpi=self.dpi)
        self.canvas = FigCanvas(self.panel, -1, self.fig)
        #
        self.axes  = self.fig.add_subplot(121)
        self.axes2 = self.fig.add_subplot(122)
        #
        self.toolbar = NavigationToolbar(self.canvas)
        #
        # Layout with box sizers
        #
        # matplotlib canvas and matplotlib toolbar
        self.vbox = wx.BoxSizer(wx.VERTICAL)
        self.vbox.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW | wx.EXPAND)
        self.vbox.Add(self.toolbar, 0, wx.EXPAND)
        #
        # Choice of observable 1
        self.hbox = wx.GridBagSizer(hgap=5, vgap=2)
        self.hbox.Add(wx.StaticText(self.panel, -1, "Obs 1:"), pos=(0,0))
        self.obschoice1 = wx.Choice(self.panel, -1, (85, 18), choices=sorted(observables))
        self.hbox.Add(self.obschoice1, pos=(0,1))
        self.logx1chkbx = wx.CheckBox(self.panel, -1, "logx")
        self.logy1chkbx = wx.CheckBox(self.panel, -1, "logy")
        self.hbox.Add(self.logx1chkbx, pos=(0,2))
        self.hbox.Add(self.logy1chkbx, pos=(0,3))
        self.Bind(wx.EVT_CHOICE, functools.partial(self.updateObs, which="left"), self.obschoice1)
        self.Bind(wx.EVT_CHECKBOX, self.setLogx, self.logx1chkbx)
        self.Bind(wx.EVT_CHECKBOX, self.setLogy, self.logy1chkbx)
        #
        # Choice of observable 2
        self.hbox.Add(wx.StaticText(self.panel, -1, "Obs 2:"), pos=(0,4))
        self.obschoice2 = wx.Choice(self.panel, -1, (85, 18), choices=sorted(observables))
        self.hbox.Add(self.obschoice2, pos=(0,5))
        self.logx2chkbx = wx.CheckBox(self.panel, -1, "logx")
        self.logy2chkbx = wx.CheckBox(self.panel, -1, "logy")
        self.hbox.Add(self.logx2chkbx, pos=(0,6))
        self.hbox.Add(self.logy2chkbx, pos=(0,7))
        self.Bind(wx.EVT_CHOICE, functools.partial(self.updateObs, which="right"), self.obschoice2)
        self.Bind(wx.EVT_CHECKBOX, self.setLogx, self.logx2chkbx)
        self.Bind(wx.EVT_CHECKBOX, self.setLogy, self.logy2chkbx)
        # Checkbox for calculation and display of chi/ndf values
        self.chisqchkbx = wx.CheckBox(self.panel, -1, "Show g.o.f.")
        self.hbox.Add(self.chisqchkbx, pos=(0,8))
        self.Bind(wx.EVT_CHECKBOX, self.setGOF, self.chisqchkbx)
        self.vbox.Add(self.hbox)

        self.vbox.AddSpacer((10,10))

        # Parameter sliders and buttons
        self.controlgrid = wx.GridBagSizer(hgap=5, vgap=2)
        self.hbox1=wx.BoxSizer(wx.HORIZONTAL)
        iniunscaled  = tundat.paramranges.center

        # Read in parameter: name  - > description text file, store as dict
        parammap = {}
        # if opts.TRANSLATE:
        #     f = open(opts.TRANSLATE)
        #     T = [line.strip().split(' ', 1) for line in f if not line.startswith('#')]
        #     f.close()
        #     for i in T:
        #         parammap[i[0]] = i[1]
        # else:


        # Build the sliders and related objects
        for i, param in enumerate(self.params):
            #
            # Parameter names
            self.controlgrid.Add(wx.StaticText(self.panel, -1, param), pos=(i,0))
            try:
                self.controlgrid.Add(wx.StaticText(self.panel, -1, parammap[param]), pos=(i,1))
            except:
                pass
            #
            # Sliders
            pmin = 0
            pmax = 1000
            slider = wx.Slider(self.panel, 100, 500, pmin, pmax,
                    pos=(10, 35*(i+1)), size=(250, -1),
                    style=wx.SL_HORIZONTAL )
            slider.SetTickFreq(10000, 1)
            self.controlgrid.Add(slider, pos=(i,2))
            self.sliders[param] = slider
            #
            # Parameter value textctrls
            textctrl = wx.TextCtrl(self.panel, -1, "%.3f" % iniunscaled[param])
            self.controlgrid.Add(textctrl, pos=(i,3))
            self.valtexts[param] = textctrl
        self.Bind(wx.EVT_SLIDER, self.sliderUpdate)
        #
        # Adding the Slider related vertical boxes to a horizontal box
        self.hbox1.Add(self.controlgrid)

        self.buttongrid=wx.GridBagSizer(hgap=5, vgap=2)
        self.buttonvbox = wx.BoxSizer(wx.VERTICAL)
        #
        ## Button for certain param settings
        self.ParamsButton = wx.Button(self.panel, label="Set params")
        self.Bind(wx.EVT_BUTTON, self.setParameters, self.ParamsButton)
        self.buttongrid.Add(self.ParamsButton, pos=(1,0))
        ##
        #
        # Buttons to reset limits
        self.resetBtn = wx.Button(self.panel, label="Reset limits 1")
        self.Bind(wx.EVT_BUTTON, functools.partial(self.resetLimits, which="left"), self.resetBtn)
        self.buttongrid.Add(self.resetBtn, pos=(3,0))
        self.resetBtn2 = wx.Button(self.panel, label="Reset limits 2")
        self.Bind(wx.EVT_BUTTON, functools.partial(self.resetLimits, which="right"), self.resetBtn2)
        self.buttongrid.Add(self.resetBtn2, pos=(4,0))
        #
        self.hbox1.Add(self.buttongrid)
        #
        # vbox for x/y limits
        self.limitgrid=wx.GridBagSizer(hgap=5, vgap=2)
        self.limitgrid.Add(wx.StaticText(self.panel, -1, "Limits 1:"), pos=(0,0))
        self.limits["left"] = {}
        for num, i in enumerate("XMin XMax YMin YMax".split()):
            self.limitgrid.Add(wx.StaticText(self.panel, -1, i), pos=(num+1, 0))
            textctrl = wx.TextCtrl(self.panel, -1, "None")
            self.limitgrid.Add(textctrl, pos=(num+1,1))
            self.limits["left"][i] = textctrl
        self.limitgrid.Add(wx.StaticText(self.panel, -1, "Limits 2:"), pos=(0,3))
        self.limits["right"] = {}
        for num, i in enumerate("XMin XMax YMin YMax".split()):
            self.limitgrid.Add(wx.StaticText(self.panel, -1, i), pos=(num+1, 3))
            textctrl = wx.TextCtrl(self.panel, -1, "None", style=wx.TE_PROCESS_ENTER)
            self.limitgrid.Add(textctrl, pos=(num+1,4))
            self.limits["right"][i] = textctrl
        self.hbox1.Add(self.limitgrid)
        for textctrl in self.limits["left"].values():
            self.Bind(wx.EVT_TEXT,
                    self.sliderUpdate, textctrl)
        for textctrl in self.limits["right"].values():
            self.Bind(wx.EVT_TEXT,
                    self.sliderUpdate, textctrl)

        # Add sliders and so on to the main vertical box
        self.vbox.Add(self.hbox1)

        self.panel.SetSizer(self.vbox)
        self.vbox.Fit(self)


    def updateHisto(self, which, obs, newpoint):
        ppoint = prof.ParameterPoint.mkFromDict(getDict(self.params, newpoint))
        ihisto = tundat.getInterpolationHisto(obs, getDict(self.params, newpoint))
        return ihisto


    def resetLimits(self, event, which):
        for i in "XMin XMax YMin YMax".split():
            self.limits[which][i].SetValue("None")
        if which == "left":
            self.axes.relim()
            self.axes.autoscale_view()
        elif which == "right":
            self.axes2.relim()
            self.axes2.autoscale_view()
        self.sliderUpdate(None)


    def getLimits(self, limdict):
        xmin = self.convertInput(limdict["XMin"].GetValue())
        xmax = self.convertInput(limdict["XMax"].GetValue())
        ymin = self.convertInput(limdict["YMin"].GetValue())
        ymax = self.convertInput(limdict["YMax"].GetValue())
        return xmin, xmax, ymin, ymax


    def setLimits(self, sub, thelimits):
        xmin, xmax, ymin, ymax = thelimits
        sub.set_xlim(xmin, xmax)
        sub.set_ylim(ymin, ymax)


    def convertInput(self, inp):
        try:
            return float(inp)
        except:
            return None


    def sliderUpdate(self, event, redraw=True):
        self.updateTextCtrls()
        unscaled  = self.getCurrentParamValues()
        self.plotHistos(unscaled, redraw=redraw)
        if self.showchisq:
            # Goodness of fit from Ipol
            self.gofs['left'].setParams(self.getCurrentParamValues())
            self.gofs['right'].setParams(self.getCurrentParamValues())

            plotLabel(self.axes,  "chi**2/Nbins= %.2f" % self.gofs['left'].calcGoF())
            plotLabel(self.axes2, "chi**2/Nbins= %.2f" % self.gofs['right'].calcGoF())
            ## Goodness of fit from MC
            try:
                gof1 = self.getGoFFromMC(self.drawobs["left"])
                gof2 = self.getGoFFromMC(self.drawobs["right"])
                plotLabel(self.axes,  "chi**2/Nbins= %.2f" % gof1, color="r", ha="right")
                plotLabel(self.axes2, "chi**2/Nbins= %.2f" % gof2, color="r", ha="right")
            except:
                pass
        # Set plot limits
        self.setLimits(self.axes, self.getLimits(self.limits["left"]))
        self.setLimits(self.axes2, self.getLimits(self.limits["right"]))
        self.canvas.draw()


    def getCurrentParamValues(self):
        temp = [self.sliders[k].GetValue()/1000. for k in self.params]
        unscaled  = tundat.paramranges.getRelativePoint(temp)
        return unscaled


    def updateTextCtrls(self):
        current = getDict(self.params, self.getCurrentParamValues())
        for k, v in self.valtexts.iteritems():
            v.SetValue("%.4f"%current[k])


    def setParameters(self, event):
        temp = [self.fixparams[k] for k in self.params]
        ppoint = prof.ParameterPoint.mkFromDict(getDict(self.params, temp))
        normed = tundat.paramranges.getNormalisedPoint(ppoint)
        for k, v in self.sliders.iteritems():
            v.SetValue(1000*normed[k])
        self.sliderUpdate(None)


    def updateObs(self, event, which):
        """ todo
        """
        self.axes.clear()
        self.axes2.clear()
        if which=="left":
            self.drawobs["left"]=observables[self.obschoice1.GetSelection()]
            self.gofs["left"]=self.getGoF(self.drawobs["left"])
        elif which=="right":
            self.drawobs["right"]=observables[self.obschoice2.GetSelection()]
            self.gofs["right"]=self.getGoF(self.drawobs["right"])

        # Ref. data is available if we can access the refpath property of
        # the global data proxy instance.
        try:
            dataproxy.refpath
            plotRefHisto(self.axes, self.drawobs["left"])

            plotRefHisto(self.axes2, self.drawobs["right"])
        except prof.DataProxyError, err:
            pass

        self.setLogy(None)
        self.updateMCRun(None)
        self.sliderUpdate(None, redraw=False)
        self.canvas.draw()


    def plotLegend(self):
        self.axes.legend(loc=0)
        self.axes2.legend(loc=0)


    def plotHistos(self, unscaled, redraw=False):
        """ This plots the observable prediction calculated from the
            parameterisation.
        """
        for i in [['left', self.axes, self.drawobs["left"]], ['right',
            self.axes2, self.drawobs["right"]]]:
            histo = self.updateHisto(i[0], i[2], unscaled)
            x, y = getLine(histo)
            if redraw is False:
                self.histos[i[0]] = i[1].plot(x,y, color="b", label="Ipol")
            else:
                self.histos[i[0]][0].set_xdata(x)
                self.histos[i[0]][0].set_ydata(y)
                self.histos[i[0]][0].set_label("Ipol")
                i[1].texts = []
                ## Workaround for changes in matplotlib 0.99
                try:
                    i[1].redraw_in_frame()
                except:
                    pass


    def getGoF(self, obs):
        from professor import fitfunctions
        return fitfunctions.SingleSimpleIpolChi2(tundat, obs)


    def updateMCRun(self, event):
        """ Update MC comparison histo."""
        try:
            self.axes.lines.remove(self.mchistos["left"][0])
            self.axes2.lines.remove(self.mchistos["right"][0])
        except:
            pass
        try:
            self.plotMCHisto(self.axes, self.drawobs["left"], plotid="left")
        except:
            prof.log.debug("Given MC comparison file does not contain obs %s or no file loaded"%self.drawobs["left"])
        try:
            self.plotMCHisto(self.axes2, self.drawobs["right"], plotid="right")
        except:
            prof.log.debug("Given MC comparison file does not contain obs %s or no file loaded"%self.drawobs["right"])
        self.canvas.draw()


    def setLogx(self, event):
        """ See if the checkboxes are checked and set logx-scales accordingly """
        for i in [(self.logx1chkbx, self.axes), (self.logx2chkbx, self.axes2)]:
            if i[0].IsChecked():
                i[1].set_xscale('log')
            else:
                i[1].set_xscale('linear')
        self.sliderUpdate(None)


    def setLogy(self, event):
        """ See if the checkboxes are checked and set logy-scales accordingly """
        for i in [(self.logy1chkbx, self.axes), (self.logy2chkbx, self.axes2)]:
            if i[0].IsChecked():
                i[1].set_yscale('log')
            else:
                i[1].set_yscale('linear')
        self.sliderUpdate(None)


    def setGOF(self, event):
        """ Toggle calculation and display of g.o.f. """
        # Ref. data is available if we can access the refpath property of
        # the global data proxy instance.
        try:
            dataproxy.refpath
            if self.chisqchkbx.IsChecked():
                self.showchisq = True
            else:
                self.showchisq = False
            self.sliderUpdate(None)
            self.updateMCRun(None)
        except prof.DataProxyError, err:
            pass


    def plotMCHisto(self, sub, obs, plotid="left"):
        """ plot a MC histo """
        histo = self.mccomphistos[obs]
        x, y = getLine(histo)
        self.mchistos[plotid] = sub.plot(x,y, color="r", label="MC")


    def getGoFFromMC(self, obs):
        """
        GoF calculation for MC histos.

        TODO: Use GoFs from professor.fitfunctions, to match prof-tune.
        TODO: Allow GoF to be specified in a user's Python file.
        """
        mchistobins = self.mccomphistos[obs].getBins()
        refhisto = dataproxy.getRefHisto(obs)
        chi2 = 0.0
        err2 = 0.0
        for num, bin in enumerate(refhisto.getBins()):
            err2 += (bin.getYErr())**2
            diff = bin.getYVal() - mchistobins[num].getYVal()
            chi2 += diff**2 / err2
        return chi2/refhisto.numBins()


## Run GUI application
app = wx.PySimpleApp()
pif=ProfIFrame()
pif.Show()
app.MainLoop()
