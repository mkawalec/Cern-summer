#! /usr/bin/env python
"""%prog --datadir DATADIR --obsfile OBSFILE [--runsfile RUNSFILE]
or
%prog --refdir REFDIR --ipoldir IPOLDIR --obsfile OBSFILE \\
    [--runsfile RUNSFILE]

Minimise heuristic GoF with pre-built MC-interpolations in IPOLDIR against
reference data in REFDIR. The MC-interpolations must be created with
prof-interpolate before running this program.

TODO:
    * read in histogram titles
    * check result is in-/outside limits
    (* threading??)
"""

import sys
import os
import logging
logging.basicConfig(level=logging.INFO, format = "%(levelname)s %(message)s")
import optparse

from professor import rivetreader as RR
from professor.tuningdata import TuningData, SingleTuneData
from professor import interpolation
from professor.minimize import getMinimizerClass, ResultList, MinimiserError
from professor.tools.config import convParamList
from professor.tools.parameter import readParameterFile
from professor.tools import messages

## Try to rename the process on Linux
try:
   import ctypes
   libc = ctypes.cdll.LoadLibrary('libc.so.6')
   libc.prctl(15, 'prof-tune', 0, 0, 0)
except Exception:
   pass

## Set up signal handling
import signal
global RECVD_KILL_SIGNAL
RECVD_KILL_SIGNAL = None
def handleKillSignal(signum, frame):
    "Declare us as having been signalled, and return to default handling behaviour"
    logging.critical("Signal handler called with signal " + str(signum))
    logging.critical("Waiting for this minimization to finish...")
    global RECVD_KILL_SIGNAL
    RECVD_KILL_SIGNAL = signum
    signal.signal(signum, signal.SIG_DFL)
## Signals to handle
signal.signal(signal.SIGTERM, handleKillSignal);
signal.signal(signal.SIGHUP,  handleKillSignal);
signal.signal(signal.SIGINT,  handleKillSignal);
signal.signal(signal.SIGUSR2, handleKillSignal);


parser = optparse.OptionParser(usage=__doc__)

parser.add_option("-d", "--debug",
        dest = "debug",
        action = "store_true",
        help = "Turn debug logging on and stop after 3*len(spmethods)"
            " minimisations.")
group = optparse.OptionGroup(parser, "Tuning")
parser.add_option("-R", "--runsfile", "--runcombs",
        dest = "runsfile",
        help = "File with run combinations to use (space separated, 1"
            " combination per line). (default: %default)")
group.add_option("--outfile",
        dest = "outfile",
        help = "Store results in here. (default: %default)")
group.add_option("--snapshot",
        dest = "snapshot",
        action = "store_true",
        help = "Save snapshot result files during minimization every 10"
            " results. (default is off)")
group.add_option("--histo-outdir",
        dest = "histooutdir",
        help = "Store *.dat files with histogram data from the"
        " interpolation at the predicted minima. (default: %default)")
group.add_option("-I", "--no-ipolhistos",
        dest = "saveipolhistos",
        action = "store_false",
        help = "Switch of interpolation histogram storing.")

parser.set_defaults(
        debug = False,
        runsfile = "runcombs.dat",
        outfile = "results.pkl",
        # to be compatible with old prof-tune
        histooutdir = "./ipolhistos",
        saveipolhistos = True,
        snapshot = False
        )
parser.add_option_group(group)

mingroup = optparse.OptionGroup(parser, "Minimiser")
mingroup.add_option("--minimizer",
        choices = ("pyminuit", "scipy"),
        help = "Select the minimizer to use (pyminuit|scipy)"
               " (default: %default)")
mingroup.add_option("--minos",
        dest = "useminos",
        action = "store_true",
        help = "When using Minuit, use MINOS instead of MIGRAD to estimate"
               " the parameter errors.")
mingroup.add_option("--migrad",
        dest = "useminos",
        action = "store_false",
        help = "When using Minuit, use MIGRAD to estimate"
               " the parameter errors (default).")
mingroup.add_option("--print-minuit",
        dest = "printminuit",
        type = "choice",
        choices = ("0","1","2","3"),
        help = "When using Minuit, set printMode to the given value."
               " (default: %default)")
mingroup.add_option("--limits",
        dest = "limits",
        help = "File with parameter limits for Minuit. E.g. the file used to"
            " create the MC sample points.")
mingroup.add_option("--spmethods", "--start-points",
        dest = "startpointmethods",
        help = "Comma separated list with minimisation starting point"
               " methods.")
mingroup.add_option("--manual-sp", "--manual-startpoint",
        dest = "manualstartpoint",
        help = "Comma separated list of parameter name - value pairs to be used"
               " as manual startpoints when spmethod 'manual' is selected."
               " Name and value are separated by a equals ('=').  E.g."
               " PARJ(21)=1.2,PARJ(22)=2.4 . Unspecified Parameters are chosen"
               " randomly.")
mingroup.add_option("--fixed-parameters",
        dest = "fixedparameters",
        help = "Comma separated list of parameter name - value pairs with"
               " parameter values to be fixed during minimization. Format is"
               " the same as with '--manual-startpoint', e.g."
               " PARJ(21)=1.2,PARJ(22)=2.4 . NB: Only supported by pyminuit!")
parser.set_defaults(
        minimizer = "pyminuit",
        useminos = False,
        printminuit = "0",
        limits = None,
        startpointmethods = "center"
        )
parser.add_option_group(mingroup)

interpolation.addCLOptions(parser)
RR.addDataCLOptions(parser)
opts, args = parser.parse_args()

if opts.debug:
    logging.getLogger().setLevel(logging.DEBUG)
    logging.debug("Options are: %s" % (str(opts)))

sys.stdout.write(messages.logo + "\n" + messages.guideline)
sys.stdout.flush()

## Check data directories.
refdir = RR.getDataDirectories(opts)["ref"]
ipoldir = RR.getDataDirectories(opts)["ipol"]
logging.debug("refdir: %s  ipoldir: %s" % (refdir, ipoldir))
if (not os.path.isdir(refdir) or
    not os.access(refdir, os.R_OK|os.X_OK)):
    logging.error("Reference data directory is not a directory or has bad"
            " permissions: %s" % (refdir))
    logging.error("Exiting!")
    sys.exit(1)
if (not os.path.isdir(ipoldir) or
    not os.access(ipoldir, os.R_OK|os.X_OK)):
    logging.error("Interpolation data directory is not a directory or has"
            " bad permissions: %s" % (ipoldir))
    logging.error("Exiting!")
    sys.exit(1)

## Check histo output directory.
if opts.saveipolhistos:
    if os.path.exists(opts.histooutdir):
        if (not os.path.isdir(opts.histooutdir)
                or not os.access(opts.histooutdir, os.W_OK|os.X_OK)):
            logging.error("Output directory for interpolation histograms is not"
                    " a directory or has bad permissions: %s" % (opts.histooutdir))
            logging.error("Exiting!")
            sys.exit(1)
    else:
        logging.info("Creating output directory for interpolation histograms:"
                " %s" % (opts.histooutdir))
        os.makedirs(opts.histooutdir)
    logging.info("Output directory for interpolation histograms: %s" % (
        opts.histooutdir))
else:
    logging.info("Not storing any histogram data for later plotting.")


## Get the configured interpolation class.
try:
    IpolCls = interpolation.getInterpolationClass(opts.ipolmethod,
            opts.useweave)
    logging.info("Using %s for interpolation." % (IpolCls.__name__))
except Exception, e:
    logging.error("Problem getting interpolation method: %s" % (e))
    logging.error("Exiting!")
    sys.exit(1)


## Get the configured minimizer class.
try:
    MinimizerCls = getMinimizerClass(opts.minimizer,
            useminos = opts.useminos, printminuit = int(opts.printminuit))
    logging.info('Using %s as minimizer.'%(MinimizerCls.__name__))
except Exception, e:
    logging.error("Problem getting minimizer: %s" % (e))
    logging.error("Exiting...")
    sys.exit(1)
## Read limits file.
if opts.limits is not None:
    if (not os.path.isfile(opts.limits) or
            not os.access(opts.limits, os.R_OK)):
        logging.error("Limits file does not exist or has bad permissions: "
                " %s" % (opts.limits))
        logging.error("Exiting...")
        sys.exit(1)
    else:
        limits = readParameterFile(opts.limits)
        logging.info("Using minimisation limits from %s." % (opts.limits))
        logging.debug("Using minimisation limits %s." % (limits))
else:
    limits = None
    logging.info("Not using minimisation limits.")
## Parse fixed parameter option.
fixedparams = convParamList(opts.fixedparameters)
## Parse start point methods.
spmethods = opts.startpointmethods.split(',')
## Parse manual start points.
manualsp = convParamList(opts.manualstartpoint)


## Select the observables we want to use for our tune.
try:
    obsdict = RR.readObservableFile(opts.observablefile)
except Exception, e:
    logging.error("Problem when reading observable file: %s" % (e))
    logging.error("Exiting!")
    sys.exit(1)
logging.debug("loaded observable file from %s: %s" % (
        opts.observablefile, obsdict))


## Load run combinations
logging.debug("Using %s as runsfile" % (opts.runsfile))
try:
    runfile = open(opts.runsfile, "r")
except Exception, e:
    logging.error("Error while opening run combination file %s: %s" %
            (opts.runsfile, e))
    sys.exit(1)
allruns = [line.split() for line in runfile.readlines()]
runfile.close()
logging.info("Loaded %i run combinations from %s" % (len(allruns),
    opts.runsfile))
if opts.debug:
    logging.info("Debugging: limiting to 3 minimisations!")
    allruns = allruns[:3]

## Check that all interpolations are available in ipoldir.
for runs in allruns:
    name = RR.getIpolFilename(IpolCls, runs)
    path = os.path.join(ipoldir, name)
    if not os.path.exists(path):
        logging.error("Could not find interpolation file for runs %s in"
                " ipoldir %s: %s" % (
                sorted(runs), ipoldir, name))
        logging.error("Please call prof-interpolate with the correct"
                " arguments before using this program to build"
                " interpolation files!")
        logging.error("Exiting!")
        sys.exit(1)


## Load ref data into TuningData object
tundat = TuningData()
# copied from getTuningData
refhistos = RR.getRefHistos(refdir)
for name, hist in refhistos.iteritems():
    tundat.setRefHisto(name, hist)

# build snapshot file name
if opts.snapshot:
    base, ext = os.path.splitext(opts.outfile)
    snapfilename = base + "-snap" + ext

def tune(runs, itune, spmethod="center"):
    # load interpolation set
    fname = RR.getIpolFilename(IpolCls, runs)
    path = os.path.join(ipoldir, fname)
    logging.debug("Loading ipolset from %s" % (path))
    ipolset = interpolation.InterpolationSet.fromPickle(path)
    ipolhistonames = ipolset.getHistogramNames()

    logging.debug("Creating SingleTuneData")
    # build SingleTuneData
    refbins = {}
    for obs in obsdict.iterkeys():
        # check that we have the interpolation
        if obs not in ipolhistonames:
            logging.error("Could not find interpolation for histogram %s"
                    " in file %s !" % (obs, fname))
            logging.error("Please call prof-interpolate with the correct"
                    " arguments first!")
            logging.error("Exiting!")
            sys.exit(1)

        refhist = tundat.getRefHisto(obs)
        for ibin in xrange(refhist.numBins()):
            binid = tundat.getBinID(refhist, ibin)
            refbins[binid] = refhist.getBin(ibin)
    # create a STD without MC data
    std = SingleTuneData(refbins, ipolset)
    # This apllies weights and vetos read from bindefinitions given in file
    std.applyObservableWeightDict(obsdict)

    # TODO? Limiting to runspecific parameter ranges is not possible with
    # the data we have.

    logging.debug("Starting minimiser...")
    logging.debug("  using spmethod %s" % (spmethod))
    logging.debug("  using manualsp %s" % (manualsp))
    logging.debug("  using limits %s" % (limits))
    logging.debug("  using fixedpars %s" % (fixedparams))
    minimizer = MinimizerCls()
    result = minimizer.guessMinimum(std,
            spmethod=spmethod, manualsp=manualsp,
            limits=limits, fixedpars=fixedparams)
    logging.info("Minimiser returned:\n%s" % (result))
    result.setIpolMethod(ipolset.ipolmethod.method)

    # dress result with some flags
    if fixedparams is not None:
        for p in fixedparams.keys():
            logging.debug("Setting fixed flag for parameter %s" % (p))
            result.setFixedFlag(p)
    if limits is not None:
        result.setLimitUsedFlag()
        # check if we hit the limit
        mdict = result.asDict(scaled=False)
        for param, l in limits.items():
            if (abs(mdict[param] - l[0]) < 1.0e-4
                    or abs(mdict[param] - l[0]) < 1.0e-4):
                logging.info("Result near parameter limits!")
                result.setHitLimitFlag()
                break

    if opts.saveipolhistos:
        # Store interpolation histograms.
        global histonametempl
        # fhistoname = os.path.join(opts.histooutdir, "histos-%i.dat" % (itune))
        fhistoname = os.path.join(opts.histooutdir, histonametempl % (itune))
        logging.info("Writing interpolation histos to %s" % (fhistoname))
        f = open(fhistoname, "w")
        for obs in sorted(std.getObservables()):
            f.write(
                std.getInterpolationHisto(obs, result, tundat.getTitle(obs)).asFlat()
                + "\n\n")
        f.close()
    return result

reslist = ResultList()
nummins = len(allruns)*len(spmethods)
# filename template for interpolated histo dat files
histonametempl = "histos-%%0%ii.dat" % (len("%i" % (nummins)))
for irun, runs in enumerate(allruns):
    for imeth, spmethod in enumerate(spmethods):
        itune = len(spmethods)*irun + imeth
        logging.info("Starting %i/%i tune..." % (itune+1, nummins))
        try:
            result = tune(runs, itune, spmethod)
            reslist.append(result)
        except MinimiserError, err:
            logging.error("Minimiser yielded an error for this tuning"
                    " attempt: %s" % (err))
            logging.error("No result is saved!")
            continue
        except KeyboardInterrupt:
            logging.critical("Keyboard interrupt detected, you'll have to go"
                    " with %i results only." % len(reslist))
            break
        if RECVD_KILL_SIGNAL is not None:
            logging.critical("Leaving loop early due to signal %s, you'll"
                    " have to go with %i results only." % (
                                RECVD_KILL_SIGNAL, len(reslist)))
            break
        if opts.snapshot and len(reslist) % 10 == 0:
            logging.info("Snapshotting %i results to %s" % (len(reslist),
                snapfilename))
            reslist.write(snapfilename)

    if RECVD_KILL_SIGNAL is not None:
        break

logging.info("Writing results: %s" % (opts.outfile))
reslist.write(opts.outfile)
if opts.snapshot and len(reslist) >= 10:
    logging.warn("Snapshots were written to %s. You can remove this file"
            " now." % (snapfilename))
