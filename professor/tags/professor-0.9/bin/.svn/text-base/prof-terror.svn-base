#!/usr/bin/env python
usage = """
%prog [options] <resultsfile>

This script is intended for the estimation of Tuning Errors.
Sample parameter points from within a k-sigma ellipsis
defined by the covariance matrix of a MinimizationResult.

TODO: Use also covariance matrix calculated from sample
of MinimizationResults to include systematics as well.
"""

import numpy, scipy, random, os, sys
import logging
logging.basicConfig(level=logging.INFO, format = "%(levelname)s %(message)s")
from optparse import OptionParser

try:
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed([])
except:
    logging.info("Ipython shell not available.")

from scipy.special import gammaincinv

from professor.tools import parameter, formulas
from professor import rivetreader, interpolation
from professor.minimize import result
from professor.tools import formulas, messages

parser = OptionParser(usage=usage)


parser.add_option("-n", "--npoints", dest="NPOINTS",
                  default=3, help="Number of points to sample")
parser.add_option("-O", "--outdir", dest="OUTDIR",
                  default="ipolhisto", help="output directory")
parser.add_option("-s", "--systematic", dest="SYSTEMATIC", action="store_true",
                  default=False, help="Store used_params files of the minima"
                  " found in a resulttlist")
(opts, args) = parser.parse_args()

sys.stdout.write(messages.guideline)
sys.stdout.flush()

def getSigmasAndRotationMatrix(res):
    """ Calculate the Eigendecomposition of a (covariance-) matrix
        M = T^{-1} S T and return the Eigenvalues S and the rotation-matrix T
    """
    if type(res) == result.ResultList:
        covmat = formulas.convertCovMatToArray(res.getSampleCovMat())[0]

    elif type(res) == result.MinimizationResult:
        covmat = res.getCovMatrix()
    else:
        print "result is neither a list nor a Result"
        sys.exit(1)
    T_inv, S, T = formulas.eigenDecomposition(covmat)
    return S, T

def stretchSphereVector(vector, S):
    """ Transform a vector to an ellisis in major axes representation. """
    onellipse = []
    for num, x in enumerate(vector):
        onellipse.append(x*numpy.sqrt(S[num]))
    return onellipse

def saveParams(fname, names, values):
    """ Write out params to a file."""
    f = open(fname, "w")
    for num, name in enumerate(names):
        f.write("%s   %f\n"%(name, values[num]))
    f.close()


### This produces opts.NPOINTS points randomly sampled from the d-dimensional
### Standard-Gaussian

rlist = result.ResultList.fromPickle(args[0])
logging.info("Read minimisation result(s) from %s."%args[0])
res = rlist[0]
p0 = res.parunscaled

if len(args) == 2:
    res = result.ResultList.fromPickle(args[1])
    if len(res) < 2:
        logging.error("Covmat. calc. from sample needs more than one "
                + "min. result.")
        sys.exit(1)

if not opts.SYSTEMATIC:
    Sigmas, T = getSigmasAndRotationMatrix(res)
    d = len(Sigmas)

    thePoints = numpy.random.randn(int(opts.NPOINTS), d)

    ellipsis = []

    for i in thePoints:
        ellipsevector = stretchSphereVector(i, Sigmas)
        rotatedellipsepoint = T*(scipy.matrix(ellipsevector).transpose())
        ellipsis.append(numpy.array(rotatedellipsepoint)[:,0] + numpy.array(p0))
else:
    ellipsis = [R.parunscaled for R in rlist]


if not os.path.exists(opts.OUTDIR):
    os.mkdir(opts.OUTDIR)
    logging.debug("Created folder %s."%opts.OUTDIR)
for i in xrange(len(ellipsis)):
    if not os.path.exists("%s/%i"%(opts.OUTDIR, i)):
        os.mkdir("%s/%i"%(opts.OUTDIR, i))
        saveParams("%s/%i/used_params"%(opts.OUTDIR, i), rlist.getParamNames(), ellipsis[i])
logging.info("Done! Written %i parameter-points to %s."%(len(ellipsis), opts.OUTDIR))
