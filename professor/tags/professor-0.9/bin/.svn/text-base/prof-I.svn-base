#!/usr/bin/env python
usage = """
%prog [options]

Minimal example: %prog -m mc -r ref -i profipol_quadratic_5b807.pkl

%prog visualises histograms derived from the parameterisation of Mc generators.
It can be used to investigate the change of the shape of observables
if parameters are altered in a user-friendly GUI.
It could in principle also be used for a manual tuning but may be
more useful for educational purposes.

TODO:
    * errorbars for ipolhistos
    * Use Latex to display the histo-titles properly

"""
import matplotlib       # These two lines must be called before import pylab
matplotlib.use('WXAgg') # to prevent memory leakage

import os, wx, sys, logging, numpy
import functools
from matplotlib import mathtext
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from matplotlib.backends.backend_wxagg import \
    FigureCanvasWxAgg as FigCanvas, \
    NavigationToolbar2WxAgg as NavigationToolbar

from professor.minimize import result
from professor import rivetreader as RR
from professor import interpolation, lighthisto
from professor.tools.elementtree import ET
from professor.tools import parameter, translate, messages
from professor.tuningdata import TuningData, SingleTuneData, GoFData

try:
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed([])
except:
    print "Ipython shell not available."
from optparse import OptionParser

# Setting matplotlib properties
params = {
        'backend':'pdf',
        'axes.labelsize': 16,
        'text.fontsize': 16,
        'legend.fontsize': 16,
        'axes.titlesize': 16,
        'xtick.labelsize': 16,
        'ytick.labelsize': 16,
        'text.usetex': False,
        'text.latex.preamble' :  ['\usepackage{amsmath}'],
        'figure.dpi': 50,
        'lines.markersize':7.5,
        'lines.antialiased' : False,
        'patches.antialiased' : False,
        'figure.subplot.left' : 0.03,
        'figure.subplot.right' : 0.995,
        'figure.subplot.bottom' : 0.1,
        'figure.subplot.top' : 0.95,
        'figure.subplot.wspace' : 0.05,
        }
matplotlib.rcParams.update(params)

parser = OptionParser(usage=usage)

parser.add_option("-d", "--debug",
        dest = "debug",
        action = "store_true",
        help = "Turn debug logging on.")
parser.add_option("-m", "--mcdir", dest="mcdir",
                  default="mc", help="directory with MC runs")
parser.add_option("-r", "--refdir", dest="refdir",
                  default=None, help="directory with reference histos")
parser.add_option("-i", "--ipolset", dest="ipolset",
                  default=None, help="file with a previously calculated"
                    " interpolation set")
parser.add_option("-O", "--observables", dest="observables",
                  default=None, help="observable-file")
parser.add_option("-M", "--mccomparefile", dest="mccomparefile",
                  default=None, help="MC runfile (aida) to be plotted for comparison")

opts, args = parser.parse_args()

(opts, args) = parser.parse_args()

if opts.debug:
    logging.getLogger().setLevel(logging.DEBUG)
    print opts

## Check ref data and mc data directories and ipolfile.
refdir = opts.refdir
mcdir = opts.mcdir
ipolset = opts.ipolset
logging.debug("refdir: %s    mcdir: %s    ipolset: %s" % (refdir, mcdir, ipolset))
if refdir:
    if (not os.path.isdir(refdir) or
        not os.access(refdir, os.R_OK|os.X_OK)):
        logging.error("Reference data directory is not a directory or has bad"
                " permissions: %s" % (refdir))
        logging.error("Exiting!")
        sys.exit(1)
else:
    logging.warning("No refrence data directory given!")

if (not os.path.isdir(mcdir) or
    not os.access(mcdir, os.R_OK|os.X_OK)):
    logging.error("MC data directory is not a directory or has bad"
            " permissions: %s" % (mcdir))
    logging.error("Exiting!")
    sys.exit(1)
if not os.path.exists(ipolset):
    logging.error("Interpolation set given does not exist" +
            ": %s" % (ipolset))
    logging.error("Exiting!")
    sys.exit(1)


# load interpolation set
logging.debug("Loading ipolset from %s" % (opts.ipolset))
ipolset = interpolation.InterpolationSet.fromPickle(opts.ipolset)
ipolhistonames = ipolset.getHistogramNames()
logging.debug("Creating SingleTuneData")

# Load ref data and parameter points into TuningData
tundat = RR.getTuningData(refdir, mcdir, getparamsonly=True)

# check if an observable file was specified
if opts.observables is None:
    observables = sorted(ipolset.getHistogramNames())
else:
    observables = sorted([obs for obs in RR.readObservableFile(
        opts.observables).keys() if obs in ipolset.getHistogramNames()])

# parameter ranges
try:
    ranges = parameter.readParameterFile(args[0])
    logging.debug("Loading parameter ranges from: %s"%args[0])
except:
    ranges = tundat.getParameterRanges(tundat.getRunNums())
    logging.debug("Loading parameter ranges from runs in: %s"%mcdir)

def getMCcompHistos(hfile):
    mccomphistos = {}
    tree = ET.parse(hfile)
    for dps in tree.findall("dataPointSet"):
        dpsname = dps.get("path") + "/" + dps.get("name")
        ## Make a histogram and add it to the return dictionary
        mccomphistos[dpsname] = lighthisto.Histo.fromDPS(dps)
    logging.debug("Successfully loaded comparison histos" +
            " from: %s"%hfile)
    return mccomphistos

def getDict(keys, values=None):
    if values is None:
        return dict.fromkeys(keys)
    else:
        return dict([(key, values[num]) for num, key in enumerate(keys)])

def sanitizeLatexString(tex):
    for i in ["$", "\\", "{", "}", "_", "^"]:
        tex=tex.replace(i,"")
    return tex

def plotRefHisto(sub, obs):
    x,y,ye = [], [], []
    for b in tundat.getRefHisto(obs).getBins():
        x.append(b.getBinCenter())
        y.append(b.getYVal())
        ye.append(b.getYErr())
    sub.errorbar(x,y, yerr=ye, ls=" ", marker="o", color="k", label="Data")
    try:
        anainfo = RR.getSingleAnalysisInfo(os.path.split(obs)[0])
        title = sanitizeLatexString(anainfo[obs]["Title"])
        sub.set_title(title, ha="center")
    except:
        pass

def plotLabel(sub, label, x=0.5, y=-0.1, color="b", ha="left"):
    sub.text(x,y, label, ha=ha, color=color, transform=sub.transAxes,
            fontsize=20)

def getLine(histo):
    x=[]
    y=[]
    for b in histo.getBins():
        for r in b.getXRange():
            x.append(r)
            y.append(b.getYVal())
    return x, y

class ProfIFrame(wx.Frame):
    def __init__(self):
        title = 'prof-I: Professor-Interactive'
        wx.Frame.__init__(self, None, -1, title)
        self.sliders = {}
        self.showchisq = False
        self.valtexts = {}
        self.mchistos={}
        self.mccomphistos ={}
        self.fixparams = {}
        if opts.mccomparefile is not None:
            self.mccomphistos=getMCcompHistos(opts.mccomparefile)
        self.histos = {}
        self.limits = {}
        self.titles = {"left":None,  "right":None}
        self.drawobs ={"left":sorted(observables)[0], "right":sorted(observables)[0]}
        # Read in interpolation
        self.stds = {"left":self.makeObsSTD(self.drawobs["left"]),
                     "right":self.makeObsSTD(self.drawobs["right"])}
        self.params = ipolset.scaler.getKeys()
        self.npars = len(self.params)
        self.inivalues = getDict(self.params, 500.*numpy.ones(self.npars))
        self.create_menu()
        self.createMainPanel()
        self.sliderUpdate(None, redraw=False)
        self.updateObs(None, "left")
        self.updateObs(None, "right")
        self.updateMCRun(None)
        #self.plotLegend()

    def create_menu(self):
        self.menubar = wx.MenuBar()
        menu_file = wx.Menu()
        m_loadMC = menu_file.Append(-1, "&Load MC File\tCtrl-L", "Load MC File")
        m_loadPar = menu_file.Append(-1, "Load &Parameter File\tCtrl-P", "Load Parameter File")
        m_loadResult = menu_file.Append(-1, "Load Minimisation &Result\tCtrl-R", "Load  Minimisation Result")
        m_savePar = menu_file.Append(-1, "S&ave current parameters\tCtrl-a", "Save current parameters")
        m_exit = menu_file.Append(-1, "E&xit\tCtrl-X", "Exit")
        self.Bind(wx.EVT_MENU, self.on_loadMC, m_loadMC)
        self.Bind(wx.EVT_MENU, self.on_loadPar, m_loadPar)
        self.Bind(wx.EVT_MENU, self.on_loadResult, m_loadResult)
        self.Bind(wx.EVT_MENU, self.on_savePar, m_savePar)
        self.Bind(wx.EVT_MENU, self.on_exit, m_exit)

        menu_help = wx.Menu()
        m_about = menu_help.Append(-1, "&About\tF1", "About the demo")
        self.Bind(wx.EVT_MENU, self.on_about, m_about)
        self.menubar.Append(menu_file, "&File")
        self.menubar.Append(menu_help, "&Help")
        self.SetMenuBar(self.menubar)

    def on_exit(self, event):
        self.Destroy()

    def on_about(self, event):
        msg = """ Prof-I: Professor-Interactive:
         * Use the sliders to adjust parameters
         * The resulting interpolation histogram is displayed
         * Choose a MC run from the dropdown list for comparison
           Use the button 'Set Params' to set sliders to
           parameters loaded from file or result
        """
        dlg = wx.MessageDialog(self, msg, "About", wx.OK)
        dlg.ShowModal()
        dlg.Destroy()

    def on_savePar(self, event):
        current = self.getCurrentParamValues()
        dialog = wx.FileDialog ( None, style = wx.SAVE )
        if dialog.ShowModal() == wx.ID_OK:
            outfile = dialog.GetPath()
            f=open(outfile,"w")
            for num, p in enumerate(self.params):
                f.write("%s   %f\n"%(p, current[num]))
            f.close()
        else:
            logging.error("No filename specified")
        dialog.Destroy()

    def on_loadMC(self, event):
        wildcard = "AIDA histogram files (*.aida)|*.aida|" \
                "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(),
                "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            self.mccomphistos=getMCcompHistos(dialog.GetPath())
        dialog.Destroy()
        self.updateMCRun(None)

    def on_loadPar(self, event):
        wildcard = "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(),
                "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            self.fixparams = parameter.readParameterFile(dialog.GetPath())
        dialog.Destroy()

    def on_loadResult(self, event):
        wildcard = "Result files (*.pkl)|*.pkl|" \
                "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(),
                "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            R = result.ResultList.fromPickle(dialog.GetPath())[0]
            self.fixparams = R.asDict(scaled=False)
        dialog.Destroy()

    def createMainPanel(self):
        """ Creates the main panel with all the controls on it:
             * mpl canvas
             * mpl navigation toolbar
             * Control panel for interaction
        """
        self.dpi=50
        self.panel = wx.Panel(self)
        # Panel for observable diplay
        #
        self.fig = Figure((10.0, 4.0), dpi=self.dpi)
        self.canvas = FigCanvas(self.panel, -1, self.fig)
        #
        self.axes  = self.fig.add_subplot(121)
        self.axes2 = self.fig.add_subplot(122)
        #
        self.toolbar = NavigationToolbar(self.canvas)
        #
        # Layout with box sizers
        #
        # matplotlib canvas and matplotlib toolbar
        self.vbox = wx.BoxSizer(wx.VERTICAL)
        self.vbox.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW | wx.EXPAND)
        self.vbox.Add(self.toolbar, 0, wx.EXPAND)
        #
        # Choice of observable 1
        self.hbox = wx.GridBagSizer(hgap=5, vgap=2)
        self.hbox.Add(wx.StaticText(self.panel, -1, "Obs 1:"), pos=(0,0))
        self.obschoice1 = wx.Choice(self.panel, -1, (85, 18), choices=sorted(observables))
        self.hbox.Add(self.obschoice1, pos=(0,1))
        self.logx1chkbx = wx.CheckBox(self.panel, -1, "logx")
        self.logy1chkbx = wx.CheckBox(self.panel, -1, "logy")
        self.hbox.Add(self.logx1chkbx, pos=(0,2))
        self.hbox.Add(self.logy1chkbx, pos=(0,3))
        self.Bind(wx.EVT_CHOICE, functools.partial(self.updateObs, which="left"), self.obschoice1)
        self.Bind(wx.EVT_CHECKBOX, self.setLogx, self.logx1chkbx)
        self.Bind(wx.EVT_CHECKBOX, self.setLogy, self.logy1chkbx)
        #
        # Choice of observable 2
        self.hbox.Add(wx.StaticText(self.panel, -1, "Obs 2:"), pos=(0,4))
        self.obschoice2 = wx.Choice(self.panel, -1, (85, 18), choices=sorted(observables))
        self.hbox.Add(self.obschoice2, pos=(0,5))
        self.logx2chkbx = wx.CheckBox(self.panel, -1, "logx")
        self.logy2chkbx = wx.CheckBox(self.panel, -1, "logy")
        self.hbox.Add(self.logx2chkbx, pos=(0,6))
        self.hbox.Add(self.logy2chkbx, pos=(0,7))
        self.Bind(wx.EVT_CHOICE, functools.partial(self.updateObs, which="right"), self.obschoice2)
        self.Bind(wx.EVT_CHECKBOX, self.setLogx, self.logx2chkbx)
        self.Bind(wx.EVT_CHECKBOX, self.setLogy, self.logy2chkbx)
        # Checkbox for calculation and display of chi/ndf values
        self.chisqchkbx = wx.CheckBox(self.panel, -1, "Show g.o.f.")
        self.hbox.Add(self.chisqchkbx, pos=(0,8))
        self.Bind(wx.EVT_CHECKBOX, self.setGOF, self.chisqchkbx)
        self.vbox.Add(self.hbox)

        self.vbox.AddSpacer((10,10))
        #
        # Parameter sliders and buttons
        self.controlgrid = wx.GridBagSizer(hgap=5, vgap=2)
        self.hbox1=wx.BoxSizer(wx.HORIZONTAL)
        iniunscaled  = getDict(self.params, ipolset.scaler.descale(.5*numpy.ones(self.npars)))
        for i, param in enumerate(self.params):
            #
            # Parameter names
            self.controlgrid.Add(wx.StaticText(self.panel, -1, r"%s"%param), pos=(i,0))
            try:
                self.controlgrid.Add(wx.StaticText(self.panel,
                -1, r"%s"%translate.translate(param)), pos=(i,1))
            except:
                pass
            #
            # Sliders
            iv = self.inivalues[param]
            pmin = 0
            pmax = 1000
            slider = wx.Slider(self.panel, 100, iv, pmin, pmax,
                    pos=(10, 35*(i+1)), size=(250, -1),
                    style=wx.SL_HORIZONTAL )
            slider.SetTickFreq(10000, 1)
            self.controlgrid.Add(slider, pos=(i,2))
            self.sliders[param] = slider
            #
            # Parameter value textctrls
            textctrl = wx.TextCtrl(self.panel, -1, "%.3f"%iniunscaled[param])
            self.controlgrid.Add(textctrl, pos=(i,3))
            self.valtexts[param] = textctrl
        self.Bind(wx.EVT_SLIDER, self.sliderUpdate)
        #
        # Adding the Slider related vertical boxes to a horizontal box
        self.hbox1.Add(self.controlgrid)

        self.buttongrid=wx.GridBagSizer(hgap=5, vgap=2)
        self.buttonvbox = wx.BoxSizer(wx.VERTICAL)
        #
        ## Button for certain param settings
        self.ParamsButton = wx.Button(self.panel, label="Set params")
        self.Bind(wx.EVT_BUTTON, self.setParameters, self.ParamsButton)
        self.buttongrid.Add(self.ParamsButton, pos=(1,0))
        ##
        #
        # Buttons to reset limits
        self.resetBtn = wx.Button(self.panel, label="Reset limits 1")
        self.Bind(wx.EVT_BUTTON, functools.partial(self.resetLimits, which="left"), self.resetBtn)
        self.buttongrid.Add(self.resetBtn, pos=(3,0))
        self.resetBtn2 = wx.Button(self.panel, label="Reset limits 2")
        self.Bind(wx.EVT_BUTTON, functools.partial(self.resetLimits, which="right"), self.resetBtn2)
        self.buttongrid.Add(self.resetBtn2, pos=(4,0))
        #
        self.hbox1.Add(self.buttongrid)
        #
        # vbox for x/y limits
        self.limitgrid=wx.GridBagSizer(hgap=5, vgap=2)
        self.limitgrid.Add(wx.StaticText(self.panel, -1, "Limits 1:"), pos=(0,0))
        self.limits["left"] = {}
        for num, i in enumerate("XMin XMax YMin YMax".split()):
            self.limitgrid.Add(wx.StaticText(self.panel, -1, i), pos=(num+1, 0))
            textctrl = wx.TextCtrl(self.panel, -1, "None")
            self.limitgrid.Add(textctrl, pos=(num+1,1))
            self.limits["left"][i] = textctrl
        self.limitgrid.Add(wx.StaticText(self.panel, -1, "Limits 2:"), pos=(0,3))
        self.limits["right"] = {}
        for num, i in enumerate("XMin XMax YMin YMax".split()):
            self.limitgrid.Add(wx.StaticText(self.panel, -1, i), pos=(num+1, 3))
            textctrl = wx.TextCtrl(self.panel, -1, "None", style=wx.TE_PROCESS_ENTER)
            self.limitgrid.Add(textctrl, pos=(num+1,4))
            self.limits["right"][i] = textctrl
        self.hbox1.Add(self.limitgrid)
        for textctrl in self.limits["left"].values():
            self.Bind(wx.EVT_TEXT,
                    self.sliderUpdate, textctrl)
        for textctrl in self.limits["right"].values():
            self.Bind(wx.EVT_TEXT,
                    self.sliderUpdate, textctrl)

        # Add sliders and so on to the main vertical box
        self.vbox.Add(self.hbox1)

        self.panel.SetSizer(self.vbox)
        self.vbox.Fit(self)

    def getTitleBMP(self, which):
        tex = self.getPlotTitle(self.drawobs[which])
        lp  = mathtext.MathTextParser('Bitmap')
        img = lp.parse(tex, 72)[0]
        IMG = wx.ImageFromData(img.get_width(), img.get_height(),
                img.as_rgb_str())
        BMP = wx.BitmapFromImage(IMG)
        return BMP

    def drawTitle(self, bmp, which):
        brush = wx.Brush("sky blue")
        self.titles[which].SetBackground(brush)
        self.titles[which].Clear()

    def getTitleIMG(self, which):
        tex = self.getPlotTitle(self.drawobs[which])
        lp  = mathtext.MathTextParser('Bitmap')
        img = lp.parse(tex, 72)[0]
        return img.as_array()

    def updateHisto(self, which, obs, newpoint):
        self.stds[which] = self.makeObsSTD(obs)
        if opts.refdir:
            ihisto =  self.stds[which].getInterpolationHisto(obs, getDict(self.params, newpoint))
        else:
            ihisto = ipolset.getInterpolationHisto(obs, getDict(self.params, newpoint))
        return ihisto

    def resetLimits(self, event, which):
        for i in "XMin XMax YMin YMax".split():
            self.limits[which][i].SetValue("None")
        if which == "left":
            self.axes.relim()
            self.axes.autoscale_view()
        elif which == "right":
            self.axes2.relim()
            self.axes2.autoscale_view()
        self.sliderUpdate(None)

    def getLimits(self, limdict):
        xmin = self.convertInput(limdict["XMin"].GetValue())
        xmax = self.convertInput(limdict["XMax"].GetValue())
        ymin = self.convertInput(limdict["YMin"].GetValue())
        ymax = self.convertInput(limdict["YMax"].GetValue())
        return xmin, xmax, ymin, ymax

    def setLimits(self, sub, thelimits):
        xmin, xmax, ymin, ymax = thelimits
        sub.set_xlim(xmin, xmax)
        sub.set_ylim(ymin, ymax)

    def convertInput(self, inp):
        try:
            return float(inp)
        except:
            return None

    def sliderUpdate(self, event, redraw=True):
        self.updateTextCtrls()
        unscaled  = self.getCurrentParamValues()
        self.plotHistos(unscaled, redraw=redraw)
        if self.showchisq:
            # Goodness of fit from Ipol
            gof1 = self.stds["left"].getGoFFromIpol(self.getCurrentParamValues())
            gof2 = self.stds["right"].getGoFFromIpol(self.getCurrentParamValues())
            chis_1 = gof1.chi2/gof1.ndof
            chis_2 = gof2.chi2/gof2.ndof
            plotLabel(self.axes,  "chi**2/Ndf= %.2f"%chis_1)
            plotLabel(self.axes2, "chi**2/Ndf= %.2f"%chis_2)
            # Goodness of fit from MC
            try:
                gof1MC = self.getGoFFromMC(self.drawobs["left"])
                gof2MC = self.getGoFFromMC(self.drawobs["right"])
                chis_1MC = gof1MC.chi2/gof1MC.ndof
                chis_2MC = gof2MC.chi2/gof2MC.ndof
                plotLabel(self.axes,  r"$\chi^2/N_{df}= %.2f$"%chis_1MC, color="r", ha="right")
                plotLabel(self.axes2, r"$\chi^2/N_{df}= %.2f$"%chis_2MC, color="r", ha="right")
            except:
                pass
        # Set plot limits
        self.setLimits(self.axes, self.getLimits(self.limits["left"]))
        self.setLimits(self.axes2, self.getLimits(self.limits["right"]))
        self.canvas.draw()

    def getCurrentParamValues(self):
        temp = [self.sliders[k].GetValue()/1000. for k in self.params]
        unscaled  = ipolset.scaler.descale(temp)
        return unscaled

    def updateTextCtrls(self):
        current = getDict(self.params, self.getCurrentParamValues())
        for k, v in self.valtexts.iteritems():
            v.SetValue("%.4f"%current[k])

    def setParameters(self, event):
        try:
            temp = [self.fixparams[k] for k in self.params]
            scaled = getDict(self.params, ipolset.scaler.scale(temp))
            for k, v in self.sliders.iteritems():
                v.SetValue(1000*scaled[k])
            self.sliderUpdate(None)
        except:
            logging.error("Parameter file loaded unsuitable or no parameter file loaded")

    def updateObs(self, event, which):
        """ todo
        """
        self.axes.clear()
        self.axes2.clear()
        if which=="left":
            self.drawobs["left"]=observables[self.obschoice1.GetSelection()]
        elif which=="right":
            self.drawobs["right"]=observables[self.obschoice2.GetSelection()]
        # Print observable titles
        #for i in ["left", "right"]:
            #try:
                #self.titles[i].remove()
            #except:
                #pass
        if opts.refdir:
            plotRefHisto(self.axes, self.drawobs["left"])
            #x0, y0 = self.fig.transFigure.transform_point((0.1, 0.0))
            #self.titles["left"] = self.fig.figimage(self.getTitleIMG("left"), x0, y0, cmap="Greys")

            plotRefHisto(self.axes2, self.drawobs["right"])
            #x0, y0 = self.fig.transFigure.transform_point((1.1, 0.0))
            #self.titles["right"] = self.fig.figimage(self.getTitleIMG("right"), x0, y0, cmap="Greys")

        self.setLogy(None)
        self.updateMCRun(None)
        self.sliderUpdate(None, redraw=False)
        self.canvas.draw()

    def plotLegend(self):
        self.axes.legend(loc=0)
        self.axes2.legend(loc=0)

    def plotHistos(self, unscaled, redraw=False):
        """ This plots the observable prediction calculated from the
            parameterisation.
        """
        for i in [['left', self.axes, self.drawobs["left"]], ['right',
            self.axes2, self.drawobs["right"]]]:
            histo = self.updateHisto(i[0], i[2], unscaled)
            x, y = getLine(histo)
            if redraw is False:
                self.histos[i[0]] = i[1].plot(x,y, color="b", label="Ipol")
            else:
                self.histos[i[0]][0].set_xdata(x)
                self.histos[i[0]][0].set_ydata(y)
                self.histos[i[0]][0].set_label("Ipol")
                i[1].texts = []
                # Work around for changes in matplotlib 0.99
                try:
                    i[1].redraw_in_frame()
                except:
                    pass
        #self.plotLegend()

    def updateMCRun(self, event):
        """ Update MC comparison histo. """
        try:
            self.axes.lines.remove(self.mchistos["left"][0])
            self.axes2.lines.remove(self.mchistos["right"][0])
        except:
            pass
        try:
            self.plotMCHisto(self.axes, self.drawobs["left"], plotid="left")
        except:
            logging.debug("Given MC comparison file does not contain obs %s or no file loaded"%self.drawobs["left"])
        try:
            self.plotMCHisto(self.axes2, self.drawobs["right"], plotid="right")
        except:
            logging.debug("Given MC comparison file does not contain obs %s or no file loaded"%self.drawobs["right"])
        #self.plotLegend()
        self.canvas.draw()

    def setLogx(self, event):
        """ See if the checkboxes are checked and set logx-scales accordingly """
        for i in [(self.logx1chkbx, self.axes), (self.logx2chkbx, self.axes2)]:
            if i[0].IsChecked():
                i[1].set_xscale('log')
            else:
                i[1].set_xscale('linear')
        self.sliderUpdate(None)

    def setLogy(self, event):
        """ See if the checkboxes are checked and set logy-scales accordingly """
        for i in [(self.logy1chkbx, self.axes), (self.logy2chkbx, self.axes2)]:
            if i[0].IsChecked():
                i[1].set_yscale('log')
            else:
                i[1].set_yscale('linear')
        self.sliderUpdate(None)

    def setGOF(self, event):
        """ Toggle calculation and display of g.o.f. """
        if opts.refdir:
            if self.chisqchkbx.IsChecked():
                self.showchisq = True
            else:
                self.showchisq = False
            self.sliderUpdate(None)

    def plotMCHisto(self, sub, obs, plotid="left"):
        """ plot a MC histo """
        histo = self.mccomphistos[obs]
        x, y = getLine(histo)
        self.mchistos[plotid] = sub.plot(x,y, color="r", label="MC")

    def makeObsSTD(self, obs):
        if opts.refdir:
            refbins = {}
            refhist = tundat.getRefHisto(obs)
            for ibin in xrange(refhist.numBins()):
                binid = tundat.getBinID(refhist, ibin)
                refbins[binid] = refhist.getBin(ibin)
            # create STD without MC data
            std = SingleTuneData(refbins, ipolset)
        else:
            std = {}
            for k, v in ipolset.iteritems():
                if obs in k:
                    std[k] = v
        return std

    def getGoFFromMC(self, obs):
        """ GoF calculaton for MC histos, taken from tuningdata.SingleTuneData """
        gofdata = GoFData(len(ipolset.getParameterNames()))
        mchist = self.mccomphistos[obs]
        for ibin, refbin in enumerate(tundat.getRefHisto(obs).getBins()):
            # only add bins, where the reference error is > 0.0
            if refbin.getYErr() > 0.0:
                gofdata.append((refbin, mchist.getBin(ibin), 1))
            else:
                logging.debug('vetoing bin: %s '%str(self.getBinID(mchist, ibin)))

        return gofdata

sys.stdout.write(messages.logo + "\n" + messages.guideline)

app = wx.PySimpleApp()
pif=ProfIFrame()
pif.Show()
app.MainLoop()
