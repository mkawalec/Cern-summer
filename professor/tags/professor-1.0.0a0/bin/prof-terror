#! /usr/bin/env python

"""
%prog [options] <resultsfile>

This script is intended for the estimation of tuning errors. It samples
parameter points from within a k-sigma ellipsis defined by the covariance matrix
of a MinimizationResult.

TODO:

 * Add error-tunes, i.e. 2N tunes at the principle 1 sigma points on the Minuit
   ellipsoid.
 * Rename "stat" and "sys" to match the paper convention... these are misleading names.
 * Add "combined error", i.e. current "stat" and "sys" errors combined.
 * Extend error tunes to combined error?
"""

import numpy, random
import os, sys

import professor.user as prof


# ## Try to enable ipython traceback printing
# from professor.tools import shell
# shell.usePrettyTraceback()


## Parse command line args
from optparse import OptionParser
parser = OptionParser(usage=__doc__)
parser.add_option("-n", "--npoints", dest="NPOINTS",
                  default=3, help="Number of points to sample")
parser.add_option("-O", "--outdir", dest="OUTDIR",
                  default="ipolhisto", help="output directory")
parser.add_option("-s", "--systematic", dest="SYSTEMATIC", action="store_true",
                  default=False, help="Store used_params files of the minima"
                  " found in a result list")
(opts, args) = parser.parse_args()


## Write usage messages
prof.writeLogo()
prof.writeGuideLine()


def getSigmasAndRotationMatrix(res):
    """ Calculate the eigen-decomposition of a (covariance) matrix
        M = T^{-1} S T and return the Eigenvalues S and the rotation-matrix T
    """
    from professor.tools import formulas
    if type(res) == prof.ResultList:
        covmat = formulas.convertCovMatToArray(res.getSampleCovMat())[0]

    elif type(res) == prof.MinimizationResult:
        covmat = res.getCovMatrix()
    else:
        print "res is neither a ResultList nor a MinimizationResult"
        sys.exit(1)
    T_inv, S, T = formulas.eigenDecomposition(covmat)
    return S, T


def stretchSphereVector(vector, S):
    """ Transform a vector to an ellipsis in major axes representation."""
    onellipse = []
    for num, x in enumerate(vector):
        onellipse.append(x*numpy.sqrt(S[num]))
    return onellipse


def saveParams(fname, names, values):
    """ Write out params to a file."""
    f = open(fname, "w")
    for num, name in enumerate(names):
        f.write("%s   %f\n"%(name, values[num]))
    f.close()


### This produces opts.NPOINTS points randomly sampled from the d-dimensional
### Standard-Gaussian

rlist = prof.ResultList.fromPickle(args[0])
prof.log.info("Read minimization result(s) from %s." % args[0])
res = rlist[0]
p0 = res.parunscaled

if len(args) == 2:
    res = prof.ResultList.fromPickle(args[1])
    if len(res) < 2:
        prof.log.error("Covmat. calc. from sample needs more than one minimization result.")
        sys.exit(1)


## TODO: Rename to match paper conventions
if not opts.SYSTEMATIC:
    Sigmas, T = getSigmasAndRotationMatrix(res)
    d = len(Sigmas)

    thePoints = numpy.random.randn(int(opts.NPOINTS), d)

    ellipsis = []

    import scipy
    for i in thePoints:
        ellipsevector = stretchSphereVector(i, Sigmas)
        rotatedellipsepoint = T*(scipy.matrix(ellipsevector).transpose())
        ellipsis.append(numpy.array(rotatedellipsepoint)[:,0] + numpy.array(p0))
else:
    ellipsis = [R.parunscaled for R in rlist]


if not os.path.exists(opts.OUTDIR):
    os.mkdir(opts.OUTDIR)
    prof.log.debug("Created folder %s."%opts.OUTDIR)
for i in xrange(len(ellipsis)):
    ioutdir = os.path.join(opts.OUTDIR, str(i))
    if not os.path.exists(ioutdir):
        os.mkdir(ioutdir)
        saveParams(os.path.join(ioutdir, "used_params"), rlist.getParamNames(), ellipsis[i])

prof.log.info("Done! Written %i parameter-points to %s." % (len(ellipsis), opts.OUTDIR))
