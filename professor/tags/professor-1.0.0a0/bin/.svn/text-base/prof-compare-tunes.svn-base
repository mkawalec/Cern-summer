#! /usr/bin/env python

usage = """Usage: %prog [options] --refdir <REFDIR> --weights WEIGHTS <TUNEDIR>[:<LABEL>]  [...]

Calculate the goodness of fit for different tunes based on the weights in
WEIGHTS. Tunes must be given as directories that contain a `out.aida' file
with the MC data and a `used_params' file.

Labels for each tune can be given by appending a `:mylabel'. Note the colon!

Example:
  %prog --refdir datahistos --weights my.weights tune1/:"very good tune"
"""

import os.path
import professor.user as prof

from optparse import OptionParser
parser = OptionParser(usage=usage)
parser.add_option("-W", "--no-weights",
        dest="noweights",
        action="store_true",
        default=False,
        help="Use weight=1.0 for all non-zero weighted observables in"
             " WEIGHTS instead of the numerical value.")
parser.add_option("--per-bin",
        dest="perbin",
        action="store_true",
        default=False,
        help="Calculate the per-bin chi^2 for non-zero weighted observables.")
parser.add_option("-v", "--verbose",
        dest="loglevel",
        default=prof.log.INFO,
        action = "store_const",
        const = prof.log.DEBUG,
        help="verbose logging")
parser.add_option("--quiet",
        dest="loglevel",
        action = "store_const",
        const = prof.log.WARN,
        help="quiet logging")

prof.DataProxy.addDataCLOptions(parser, mc=False, ref=True, ipol=False, scan=False)
opts, args = parser.parse_args()

prof.log.setPriority(opts)

prof.writeGuideLine()


## Get a DataProxy object
dataproxy = prof.DataProxy.fromCLOptions(opts)

## Read in MC histo files
mcdata = prof.ManualMCData()
for mcfile in args:
    tokens = mcfile.split(":")
    ## Call normpath to strip trailing slashes. This is necessary for the
    ## automatic tune-label generation.
    path = os.path.normpath(tokens[0])
    prof.IOTests.ReadDir(path)
    if len(tokens) > 1:
        tunelabel = tokens[1]
    else:
        tunelabel = os.path.basename(path)
        tunelabel = os.path.splitext(tunelabel)[0]
    mcdata.addRunPath(tunelabel, path)
dataproxy.addMCData(mcdata, "tunes")


## Read in observable/weights file.
if opts.observablefile:
    prof.log.info("Reading observables from %s" % (opts.observablefile))
    wman = prof.WeightManager.fromFile(opts.observablefile)
    obsdict = dict([(obs, wman.getWeights(obs).values()[0])
                    for obs in wman.observables])
    if opts.noweights:
        prof.log.info("Will use simplified weights definition:"
                     " all observables that have a non-zero bin-weight get"
                     " a weight of 1.0")
        wman2 = prof.WeightManager()
        for obs in wman.observables:
            obsweight = wman[obs]
            if max(obsweight.values()) > 0.0:
                wman2.addBinRangeWeight(obs)
        wman = wman2
else:
    ## Build dummy WeightManager with 1.0 weights for the available
    ## observables available in all MC tunes (i.e. the intersection)
    histos = set(dataproxy.listRefHistos())
    for tunelabel in mcdata.availableruns:
        histos.intersection_update(mcdata.getRunHistos(tunelabel).keys())
    wman = prof.WeightManager()
    for obs in histos:
        wman.addBinRangeWeight(obs)
    prof.log.info("Using the intersection of observables in ref. and MC data.")

tunedata = dataproxy.getTuneData(withref=True, withmc="tunes",
                                 useobs=wman.observables)
## TODO: Are we hiding a bigger problem here? I.e. should the unfilled bins be detected explicitly?
tunedata.vetoEmptyErrors()
tunedata.applyObservableWeightDict(wman)

tunes = sorted(mcdata.availableruns)

## Calculate and print chi2/Ndf for each observable
if opts.perbin:
    from professor.fitfunctions import SingleSimpleMCChi2
    obs = sorted(wman.posWeightObservables())
    chi2perbingof = SingleSimpleMCChi2(tunedata, obs[0], tunes[0])
    wobs = max(map(len, obs))
    colsep = "  "
    print (r"obs \ chi2/bin".center(wobs) + colsep
            + colsep.join([t.center(10) for t in tunes]))
    print (wobs + (len(tunes))*len(colsep) + len(tunes)*10) * "-"
    for o in obs:
        line = o.ljust(wobs)
        for t in tunes:
            chi2perbingof.obs = o
            chi2perbingof.run = t
            line += colsep + "%10.5f" % (chi2perbingof.calcChi2PerBin())
        print line
    print (wobs + (len(tunes))*len(colsep) + len(tunes)*10) * "-"


## Build GoF calculator.
from professor.fitfunctions import SimpleMCChi2
chi2gof = SimpleMCChi2(tunedata, tunes[0])
chi2gof.use_mc_error = False

wtune = max(map(len, tunes))
for tune in tunes:
    chi2gof.run = tune
    chi2 = chi2gof.calcChi2()
    sumw = chi2gof.calcNdof()
    npar = len(mcdata.getRunParams(tune))
    print "%*s  chi2/Ndf = %f = %f/(%f-%f)" % (wtune, tune,
            chi2/(sumw-npar), chi2, sumw, npar)
