Professor TODO
--------------

* Make professor.params subpackage, cf. professor.data, with __init__.py to
  import class/function defs into professor.params import scope. Move
  professor.tools.parameter to professor.params. This seems too important to be
  stored away in the "tools" cupboard.

* parameter.readParameterFile -> class method ParameterPoint

  Eike: A bit complicated: It reads the contents of a file into a
  dictionary. Perhaps we can make this a private function of the module (leading
  "_")?

  Andy: Sounds okay if it's only actually used inside the module.

* Reconsider script defaults:
  - prof-interpolate: write to "./ipol" dir rather than DATADIR/ipol?
  - prof-tune: remove default runcombs.dat assumption and make --runsfile mandatory

* Move test* scripts into test directory, outside professor tree and hence not
  installed.

  What should we do with controlplots? It seems a) out of date and probably not
  functional, and b) more like a test suite than a fundamental part of the
  library. Should it just be deleted, or should it be moved outside the
  professor package as for the tests?

* Add some unit tests to make refactoring a bit more robust. There are currently
  some tests in the professor package: move them outside into the 'unit'
  directory.

* Finish error bands study! 3-param JIMMY tune -> 100 "stat" smearings around
  each of 100 "sys" minimisation points, using many different interpolations.

* Make Andy finally sit down and write the bloody alternative Py6 tunes note!
  Argh!

* Install Professor 0.9, then 1.0 in the LCG Applications Area AFS, i.e. just
  above the Genser AFS area, with a setup script to allow AFS users to set up
  ~instantaneously. PyMinuit, Cheetah, matplotlib, Numpy and SciPy will all be
  available via the lcg/pyanalysis and lcg/pytools collections: just add them to
  PYTHONPATH in the setup script.

  While we're at it, let's also install some packages which will be useful for
  Rivet and friends, such as Eigen2 (or 3...), libyaml-cpp, TinyXML, ...

* Make Sphinx-based documentation of Prof. Emphasis on docs for the "average
  physics user" rather than for us. Should include instructions on making tunes,
  kebab/scatter plots, envelopes, sensitivity plots, correlation colour maps,
  and using prof-I. And error tunes & error bars when available.

* Add the LEP tune comparison plots to the Prof plot gallery.

* Use WeightManager for epsilon errors... multiply on MC or ref error? Needs to
  be optional, and I think should also be overrideable by a single global
  epsilon factor specified in the scripts, so that users don't have to make the
  epsilon weights file if they don't want to use it for anything non-trivial.

* WeightManager should provide a wm.getValue("/path/to/MYHIST:42")

* "Mostly" remove Scaler from public view, including as a required function
  argument. For cases like the prof-I sliders it should be visible, but is
  otherwise an implementation detail which most users would just be confused
  by. The getInterpolationHisto function is a prime example. (This method
  accepts a a dict, already. Any more example you guys stumbled upon?)

* Provide more structured histo loading from multiple formats via functions in
  a professor.histo.input module.

* Use clearer vetoing for inputs to prof-sensitivities: should we exclude bins
  with few stats or leave that up to the user via the prof-sensitivities interface?

* Bin-bin correlations: correlations between bins within an observable will
  influence the GoF, but we don't know exactly how. We suspect some effect on
  the error2 calc, i.e. bin_i.err**2 -> bin_i.err * bin_j.err or similar. But
  how does this affect the number of DoF? Presumably correlations mean that
  there are not the number of independent DoF weights that we were previously
  assuming. And how do bin weights enter if weight_i != weight_j? All stuff for
  the MSc student to think about!

  What we do NOW is to add an observable-level hook to DataProxy to provide the
  correlation matrix, i.e. dp.getCorrelationMatrix("path/to/MYOBS"), which
  should currently return an identity matrix of the correct size (i.e. #bins)
  for that observable. Maybe we could try updating the chi2 to use it. We should
  check whether this is going to slow down chi2 computation significantly: it's
  a borderline use-case, and maybe it's better to return None for the 99% of
  cases where there is no corr matrix and put a corresponding conditional in the
  chi2/DoF calcs. OR, also have a dp.hasCorrelationMatrix(obspath) function so
  that the chi2 calc can *choose* to be more efficient... I think I like that
  best.

* Try using GPU computation for parallelising the bin ipol building or
  multi-ipol minimising on a single machine. PyCUDA seems a very impressive
  package. This would be a nice MSc or summer student project.

* Factory function consistency: should ~always be class methods on the type of
  class that they will construct. Functions that *make* a new object should
  start with "mk", ones which retrieve an existing one (including singleton)
  should start with "get".
