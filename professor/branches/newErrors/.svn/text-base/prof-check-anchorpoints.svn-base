#! /usr/bin/env python

usage = """Usage: %prog [options] <plotmode> [args ...]\n
Plot occupation of parameter space.

Either in plotmode (first arg) distrib, this will create a parameter wise
overview plot of #(params) 1D subplots.

        example:    %prog -b boundaries.params distrib

Or you can prodce 2D scatter plots, which is achievable in three ways:

        1.)     %prog -b boundaries.params scatter
        this will create as many plots as there are unique combinations of
        parameters.

        2.)     %prog -b boundaries.params scatter "PARP(61)"
        this will create scatter plots of all param combinations that include
        a certain param, here it would be PARP(61)

        3.)     %prog -b boundaries.params scatter "PARP(61)" "PARP(61)"
        will create only one scatter plot, the one of the parameters given
        as second and third argument

"""

import os, sys, pylab, numpy, matplotlib, re
from professor.tools.permut import xuniqueCombinations
from optparse import OptionParser
from IPython.Shell import IPShellEmbed
ipshell = IPShellEmbed([])


params = {
        'axes.labelsize': 7,
        'text.fontsize': 8,
        'legend.fontsize': 7,
        'xtick.labelsize': 5,
        'ytick.labelsize': 8,
        'text.usetex': False,
        }
pylab.rcParams.update(params)



parser = OptionParser(usage=usage)

parser.add_option("-m", "--mcdir", dest="MC_DIR",
        type=str, default='mc', help="specify directory containing mc runs")
parser.add_option("-o", "--outdir", dest="OUTDIR",
        default=".", help="write data files into this directory")
parser.add_option("-H", "--histfilename", dest="HIST_FNAME",
        default="out.aida", help="file name, the histos are stored in")
parser.add_option("-p", "--paramsfilename", dest="PARAMS_FNAME",
        default="used_params", help="file name, the used params are stored in")
parser.add_option("-b", "--boudariesfile", dest="BOUNDARIES_FNAME", default=None,
        help="file with the sampling boundaries used for the generation" )
parser.add_option("-s", "--shell", dest="SHELL", default=False,
        help="open interactive IPython shell afterwards" )
parser.add_option("-d", "--debug", dest="DEBUG", default=False,
        help="open interactive IPython after data has been read in" )


(opts, args) = parser.parse_args()

if len(args) == 0 and opts.DEBUG is False:
    print "not plot mode provided, exiting..."
    sys.exit(2)

if opts.BOUNDARIES_FNAME is None:
    print "need to specify boundaries file"
    sys.exit(2)

def readParams(outparamsfile, dim=1):
    """ this is copied from rivetreader.py's function get MCHistosAndParams()
        the parameters in the parameter file will be read into a dictionary
    """
    pfile = open(outparamsfile, "r")
    temp = {}
    for line in pfile:
        line = re.sub(r'(^.*?)#.*', r'\1', line) # strip comments
        line = re.sub(r' +', r' ', line) # collapse spaces
        line = re.sub(r'\n', r'', line) # remove newline
        if len(line) == 0 or line == " ":
            continue
        tokens = line.split(" ")
        if len(tokens) != dim + 1:
            print "Parameter def %s is invalid for dim = %i"%(str(tokens), dim)
        else:
            if dim == 1:
                temp[tokens[0]] = float(tokens[1])
            elif dim ==2:
                temp[tokens[0]] = ( float(tokens[1]), float(tokens[2]) )
            else:
                print "dim = %i not supported, aborting..."%dim
    return temp

def plotSingleParamsDistribution(sub, param):
    """ iterate over all parameters and plot vertical lines at their value
        values from the failed runs a re plotted in black, all other in red
    """
    for run, pdict in allruns.iteritems():
        if run in failedruns:
            sub.plot([pdict[param]], [0.], color='k', marker='|', ls=' ')
        else:
            sub.plot([pdict[param]], [0.], color='r', marker='|', ls=' ')

    ## green vertical lines at the param sampling boundaries
    sub.axvline(x=boundaries[param][1], ls='-', c='g', linewidth=0.2)
    sub.axvline(x=boundaries[param][0], ls='-', c='g', linewidth=0.2)

    ## xlimits at the param sampling boundaries
    sub.set_xlim(xmax=boundaries[param][1])
    sub.set_xlim(xmin=boundaries[param][0])

    ## turn off bounding box, ticks, ticklabels
    sub.set_frame_on(False)
    xtl = sub.xaxis.get_ticklines()
    for t in xtl:
        t.set_visible(False)
    ytl = sub.yaxis.get_ticklines()
    for t in ytl:
        t.set_visible(False)
    sub.set_yticklabels(())
    sub.set_yticks(( ))

    ## set sensible xticks
    xlabels=numpy.linspace(boundaries[param][0], boundaries[param][1], 5)
    sub.set_xticks(xlabels)
    sub.set_xticklabels(map(str, xlabels))

    ## set xlabel
    sub.set_xlabel(param)

def plotParamDistributions(params):
    """ create parameter distribution plot for all parameters in list params"
    """
    print "plotting"

    ## create figure and set size depending on nr of params
    fig = pylab.figure(facecolor='w')
    fig.set_figwidth(6)
    fig.set_figheight(len(params)*.15*fig.get_figwidth())

    ## create subplot for each param and plot params distribution in it
    for num, param in enumerate(params):
        if not param == "PROF_SCAN_PARAM":
            sub=fig.add_subplot(len(params), 1, num+1)
            plotSingleParamsDistribution(sub, param)

    ## adjust subplots, create title, save figure to file
    fig.subplots_adjust(left=0.15, right=0.85, bottom=0.1, top=0.9, wspace=0.8, hspace=.9)
    pylab.figtext(.5,.95, "Distribution of the anchor points", ha="center")
    print "saving"
    pylab.savefig(opts.OUTDIR+'/anchordist.eps')
    print "done"

def scatterParams(par1, par2):
    if not par1 and par2 in params:
        print "parameter names %s and %s are not among the available ones:"
        print params
        sys.exit(2)

    print "creating scatter plot for params %s and %s"%(par1, par2)

    fig = pylab.figure(facecolor='w')
    sub = fig.add_subplot(1,1,1)
    sub.set_xlabel(par1)
    sub.set_ylabel(par2)

    for run, pdict in allruns.iteritems():
        if run in failedruns:
            sub.plot([pdict[par1]], [pdict[par2]], color='k', marker='o', ls=' ')
        else:
            sub.plot([pdict[par1]], [pdict[par2]], color='r', marker='o', ls=' ')


    sub.set_xlim(xmax=boundaries[par1][1])
    sub.set_xlim(xmin=boundaries[par1][0])

    sub.set_ylim(ymax=boundaries[par2][1])
    sub.set_ylim(ymin=boundaries[par2][0])
    pylab.figtext(.5,.95, "Scatter plot of anchor points", ha="center")
    pylab.savefig(opts.OUTDIR+'/anchor-correl-%s-%s.eps'%(par1, par2))


print "reading data"

# get all runs params as dict: {run1:{par1:value,par2:value...}, run2:{...}}
allruns = {}
for run in os.listdir(opts.MC_DIR):
    try:
        allruns[run] = readParams(opts.MC_DIR+'/'+run+'/'+opts.PARAMS_FNAME)
    except:
        print "ignoring %s"%(opts.MC_DIR+'/'+run)
        pass

# determine if a run failed by checking for the exitance of a histo file in the
# corresponding mcrun subdirectory
failedruns = [run for run in os.listdir(opts.MC_DIR)
        if not opts.HIST_FNAME in os.listdir(opts.MC_DIR+'/'+run)]

# get params using the first entry of allruns dict
params = sorted(allruns[allruns.keys()[0]].keys())

# get param sampling boundaries
boundaries = readParams(opts.BOUNDARIES_FNAME, 2)

if opts.DEBUG is False:
    if args[0] == "distrib":
        plotParamDistributions(params)
    elif args[0] == "scatter":
        if len(args)==3:
            "creating scatter plot for %s and %s"%(args[1], args[2])
            scatterParams(args[1], args[2])
        elif len(args)==2:
            for par2 in params:
                scatterParams(args[1], par2)
        elif len(args)==1:
            "print creating scatter plots for all param combinations..."
            for par1, par2 in xuniqueCombinations(params, 2):
                scatterParams(par1, par2)
        else:
            print "too many arguments"
            sys.exit(2)
    else:
        print "plot mode '%s' not supported"%args[0]
        sys.exit(2)

    if not opts.SHELL is False:
        print "opening interactive shell, press CTRL-D to exit"
        ipshell()

else:
    print "welcome do debug mode, press CDTR-D to exit"
    ipshell()
