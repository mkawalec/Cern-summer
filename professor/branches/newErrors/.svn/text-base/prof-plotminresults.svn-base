#! /usr/bin/env python

"""%prog

Create pdf plots in the given directory and the given file mode.

Usage:
    %prog [options] PLOTMODE RESULT.XML:"label1" [RESULT2.XML:"label2" ...]

    PLOTMODE sets the type of the created plots:
        - chi2: Creates chi^2 vs. parameter result plots. One plot for each
                parameter and each given results file.
        - compare: Creates paramter result vs. observable set plots. One
                   plot for each parameter.

    RESULT.XML a result file created by prof-tune. If you are plotting
    results for different sets of observables, the results for each set
    should be in separate files (RESULT2.XML ...)

Use --help to get information for all options.

TODO: file naming scheme
"""

import sys, os, itertools, numpy, matplotlib, matplotlib.pyplot, logging
import optparse
import logging
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")

from professor.tools import formulas, parameter
from professor.minimize import ResultList

try:
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed([])
except:
    logging.info("Ipython shell not available.")

params = {
        'backend':'pdf',
        'axes.labelsize': 20,
        'text.fontsize': 20,
        'legend.fontsize': 20,
        'axes.titlesize': 20,
        'xtick.labelsize': 20,
        'ytick.labelsize': 20,
        'text.usetex': True,
        'figure.dpi': 150,
        'lines.markersize':7.5,
        'figure.subplot.left' : 0.12,
        'figure.subplot.right' : 0.995,
        'figure.subplot.bottom' : 0.1,
        'figure.subplot.top' : 0.979,
        'lines.markersize':5
        }

matplotlib.pyplot.rcParams.update(params)

parser = optparse.OptionParser(usage = __doc__)
parser.add_option("--logy",
        dest = "logy",
        action = "store_true",
        help = "Log scaled chi^2 axis when PLOTMODE is chi2.")
parser.add_option("--liny",
        dest = "logy",
        action = "store_false",
        help = "Linear scaled chi^2 axis when PLOTMODE is chi2. (default)")
parser.add_option("--ndof",
        dest = "ndof",
        action = "store_true",
        help = "Plot chi^2/ndof instead of chi^2 when PLOTMODE is chi2."
               " (default)")
parser.add_option("--no-ndof",
        dest = "ndof",
        action = "store_false",
        help = "Plot chi^2 instead of chi^2/ndof when PLOTMODE is chi2.")
parser.add_option("--outdir",
        help = "The directory were the plots are saved. (default: %default)")
parser.add_option("--paramsfile",
        help = "The file that contains the parameters for prof-runrivet")
parser.add_option("--bw",
        dest = "bw",
        action = "store_true",
        help = "produce b/w safe plots, e.g. suitable for publications")
parser.add_option("--color",
        dest = "bw",
        action = "store_false",
        help = "produce color plots (default)")

parser.set_defaults(
        logy = False,
        ndof = True,
        outdir = "./",
        bw = False)

opts, args = parser.parse_args()

## Load/check data and commandline.
try:
    plotmode = args[0]
    resultpaths = args[1:]
except IndexError:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Bad number of arguments!\n")
    sys.exit(1)

if plotmode not in ("chi2", "compare"):
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Given plotmode is not supported. Use chi2"
                     "or compare!\n")
    sys.exit(1)

# Check existence of outdir
outdir = opts.outdir
if not os.path.isdir(outdir):
    logging.info("created directory %s"%outdir)
    os.mkdir(outdir)

# Load parameter-file
try:
    par_boundaries = parameter.readParameterFile(opts.paramsfile)
except:
    par_boundaries = None

# Load results to a [observable set name]->[result list] dict.
resdict = {}
if len(resultpaths) == 0:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: No result files given!\n")
    sys.exit(1)
for p in resultpaths:
    try:
        rfile, name = p.split(":")
    except ValueError:
        logging.info("no plot label specified for %s, using filename instead"%p)
        name = os.path.splitext(os.path.basename(p))[0]
        rfile = p
    reslist = ResultList.fromPickle(rfile)
    reslist.isValid()
    resdict[name] = reslist

logy = opts.logy
ndof = opts.ndof


## Define some plotting routines.
def getColors(keys):
    colorcycle = itertools.cycle(['r', 'k', 'b', 'g'])
    if opts.bw:
        colorcycle = itertools.cycle(['k', '.7'])
    d = {}
    for k in sorted(keys, reverse=True):
        d[k] = colorcycle.next()
    return d


def getMRData(reslist, paramname):
    ## Group MinRun objects together by num_runs
    data, catalogue = {}, {}
    for mr in reslist:
        num_runs = len(mr.runs)
        if not data.has_key(num_runs):
            data[num_runs] = []
        data[num_runs].append(mr)

    ## Group results further depending on flags set
    pindex = reslist[0].getIndex(paramname)
    for num_runs, mrs in sorted(data.iteritems()):

        ## Split points by whether they are inside all param ranges
        params = { "IN":[], "OUT":[], "ON_LIMIT":[] }
        perrs =  { "IN":[], "OUT":[], "ON_LIMIT":[] }
        chi2s =  { "IN":[], "OUT":[], "ON_LIMIT":[] }
        for mr in mrs:
            if mr.HITLIMIT_FLAG:
                if len(mr.parunscaled) > pindex:
                    params["ON_LIMIT"].append( mr.parunscaled[pindex] )
                if len(mr.errunscaled) > pindex:
                    perrs["ON_LIMIT"].append( mr.errunscaled[pindex] )
                chi2s["ON_LIMIT"].append( mr.chi2 / mr.ndof )
            else:
                if not mr.OUTSIDE_FLAG:
                    if len(mr.parunscaled) > pindex:
                            params["IN"].append( mr.parunscaled[pindex] )
                    if len(mr.errunscaled) > pindex:
                            perrs["IN"].append( mr.errunscaled[pindex] )
                    chi2s["IN"].append( mr.chi2 / mr.ndof )
                else:
                    if len(mr.parunscaled) > pindex:
                        params["OUT"].append( mr.parunscaled[pindex] )
                    if len(mr.errunscaled) > pindex:
                        perrs["OUT"].append( mr.errunscaled[pindex] )
                    chi2s["OUT"].append( mr.chi2 / mr.ndof )
            catalogue[num_runs] = {"params" : params, "perrs" : perrs,
                    "chi2s" : chi2s}
    return catalogue


def plotChi2ForListAndParam(fig, reslist, paramname):
    """Plot chi^2 vs. parameter result for one result list and observable
    set.

    This creates one plot.
    """
    data = getMRData(reslist, paramname)

    colordict = getColors(data.keys())
    pmin = pmax = None

    ## Plot chi2 vs. param value
    fig.clear()
    sub = fig.add_subplot(1,1,1)
    if logy:
        sub.set_yscale("log")

    for num_runs, cat in sorted(data.iteritems()):

        ## Get drawing colours, and alphaize the out-of-range version
        colorcode = colordict[num_runs]
        inrange_color = matplotlib.colors.ColorConverter().to_rgb(colorcode)
        outrange_color = [c + 0.5*(1-c) for c in inrange_color]
        colors = { "IN" : inrange_color, "OUT" : outrange_color,
                "ON_LIMIT" : inrange_color}

        ## Set markers to distinguish results that hit parameter limits
        markers = { "IN" : "o", "OUT" : "o",
                "ON_LIMIT" : "x"}

        for n, i in enumerate(["OUT", "IN", "ON_LIMIT"]):
            if not cat["params"][i]:
                continue

            ## For the xlims
            if pmin is None or min(cat["params"][i]) < pmin:
                pmin = min(cat["params"][i])
            if pmax is None or max(cat["params"][i]) > pmax:
                pmax = max(cat["params"][i])

            kwargs = {"marker" : markers[i], "linestyle":"",
                      "color" : colors[i],
                      "label" : "$N_\\mathrm{runs} = %i\\:\\mathrm{(%s)}$" % (
                          num_runs, (i.lower()).replace("_","\\,")) }

            ## Draw more-runs results on top of fewer-runs ones
            zorder = num_runs + n
            try:
                j, k, l = sub.errorbar(cat["params"][i], cat["chi2s"][i],
                        xerr=cat["perrs"][i], zorder=zorder, **kwargs)
            except:
                sub.plot(cat["params"][i], cat["chi2s"][i], zorder=zorder,
                        **kwargs)

    ## Plot vertical lines at the parameter-sampling-boundaries
    if par_boundaries is not None:
        sub.axvline(x=par_boundaries[paramname][0], ls=':', c='g')
        sub.axvline(x=par_boundaries[paramname][1], ls=':', c='g',
                    label="$\\mathrm{Sampling\\:boundaries}$", zorder=0)
    else:
        logging.warning("%s: no parameter boundaries are being "%paramname
                + "plotted; be careful how you interpret the plots!")

    ## Set sensible xlims
    if par_boundaries is not None:
        lows = [par_boundaries[paramname][0], pmin]
        highs = [par_boundaries[paramname][1], pmax]
    else:
        lows = [pmin]
        highs =[pmax]

    nicenPlotLimits(sub, lows, highs, 'x')
    sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()

    sub.set_xlabel("$\\mathrm{%s}$" % paramname)
    if ndof:
        sub.set_ylabel("$\\chi^2/N_{\\mathrm{df}}$")
    else:
        sub.set_ylabel("$\\chi^2$", rotation=0)

    try:
        l = sub.legend(loc="best", labelspacing=0.02, handletextpad=0.04)
    except:
        l = sub.legend(loc="best")
    if l is not None:
        l.get_frame().set_edgecolor('w')
        l.set_alpha(0.1)
        l.set_zorder(20)
    return sub


def stringsStartwith(alist, token):
    """ returns True if all the string in alist start with the same token """
    for item in alist:
        if not len(item.split(token)) == 2:
            return False
        else:
            continue
    return True

def plotCompareForParam(fig, paramname, identifier='results'):
    setnames = sorted(resdict.keys())

    fig.clear()
    # these are for the y-limits of the subplot
    mins = []
    maxs = []
    all = []
    sub = fig.add_subplot(111)
    pmin = pmax = None

    # workaround to remove legend duplicates
    legendtags = {}
    for rset in resdict.keys():
        for run_num in resdict[rset].getRunCounts():
            legendtags[run_num] = {"IN":0, "OUT":0, "ON_LIMIT":0}

    for j, setname in enumerate(setnames):
        allofset = []
        reslist = resdict[setname]
        pindex = reslist[0].getIndex(paramname)

        x = j + 1

        data = getMRData(reslist, paramname)

        colordict = getColors(data.keys())

        for num_runs, cat in sorted(data.iteritems()):

            ## Get drawing colours, and alphaize the out-of-range version
            colorcode = colordict[num_runs]
            inrange_color = matplotlib.colors.ColorConverter().to_rgb(colorcode)
            outrange_color = [c + 0.5*(1-c) for c in inrange_color]
            colors = { "IN" : inrange_color, "OUT" : outrange_color,
                    "ON_LIMIT" : inrange_color}

            ## Set markers and offsets to distinguish results that hit parameter limits
            markers = { "IN" : "o", "OUT" : "o", "ON_LIMIT" : "x"}
            offsets = { "IN" : 0, "OUT" : 0.2, "ON_LIMIT" : 0.1}

            for n, i in enumerate(["OUT", "IN", "ON_LIMIT"]):
                if not cat["params"][i]:
                    continue

                ## For the xlims
                if pmin is None or min(cat["params"][i]) < pmin:
                    pmin = min(cat["params"][i])
                if pmax is None or max(cat["params"][i]) > pmax:
                    pmax = max(cat["params"][i])

                if len(cat["params"][i]) >= 1 and legendtags[num_runs][i] == 0:
                    kwargs = {"marker" : markers[i], "linestyle":"",
                              "color" : colors[i],
                              "label" : "$N_\\mathrm{runs} = %i\\:\\mathrm{(%s)}$" % (
                                  num_runs, (i.lower()).replace("_","\\,")) }
                    legendtags[num_runs][i] += 1
                else:
                    kwargs = {"marker" : markers[i], "linestyle":"",
                              "color" : colors[i],
                              "label" : False }


                ## Draw more-runs results on top of fewer-runs ones
                zorder = num_runs + n
                sub.plot((x+offsets[i])*numpy.ones(len(cat["params"][i])), cat["params"][i],
                        zorder=zorder, **kwargs)

    # plot horizontal lines at the param-sampling-boundaries
    if par_boundaries is not None:
        sub.axhline(y=par_boundaries[paramname][0], ls=':', c='g')
        sub.axhline(y=par_boundaries[paramname][1], ls=':', c='g',
                label="$\\mathrm{Sampling\\:boundaries}$")

    sub.set_ylabel("$\\mathrm{%s}$"%(paramname))
    sub.set_xticks(range(1, len(setnames) + 1))
    def wrap(string):
        return "$\\mathrm{"+string+"}$"
    clean_setnames = [k.replace("_","\\:") for k in setnames]
    sub.set_xticklabels(map(wrap,clean_setnames), rotation=0, y=-0.02)
    sub.set_xlim(0, len(setnames) + 1)

    ## Set sensible xlims
    if par_boundaries is not None:
        lows = [par_boundaries[paramname][0], pmin]
        highs = [par_boundaries[paramname][1], pmax]
    else:
        lows = [pmin]
        highs =[pmax]

    nicenPlotLimits(sub, lows, highs, 'y')
    # set useful y-limits, so that the horizontal lines are displayed nicely
    #if not par_boundaries is None:
        #lows = [par_boundaries[paramname][0], min(mins)]
        #highs = [par_boundaries[paramname][1], max(maxs)]
    #else:
        #lows = [min(mins)]
        #highs =[max(maxs)]

        #nicenPlotLimits(sub, lows, highs, 'y')

    sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()
    try:
        l = sub.legend(loc=0, labelspacing=0.02, handletextpad=0.04)
        l.get_frame().set_edgecolor('w')
        l.set_alpha(.1)
        l.set_zorder(20)
    except AttributeError:
        pass
    return sub


def nicenPlotLimits(sub, lows, highs, axis):
    try:
        dist = abs(lows[0] - highs[1])
        newmin = min(lows)  - .1*dist
        newmax = max(highs) + .1*dist
    except (IndexError, TypeError):
        newmin = min(lows)
        newmax = max(highs)
    if axis == "x":
        sub.set_xlim(xmax=newmax)
        sub.set_xlim(xmin=newmin)
    elif axis == "y":
        sub.set_ylim(ymax=newmax)
        sub.set_ylim(ymin=newmin)
    else:
        raise StandardError("axis has to be either 'x' or 'y'")



if __name__ == "__main__":

    if plotmode == "chi2":
        # Plot and save chi^2 vs. parameter for all observable sets and
        # parameters.
        for setname, reslist in resdict.iteritems():
            for paramname in reslist.getParamNames():
                fig = matplotlib.pyplot.figure(facecolor='w')
                sub = plotChi2ForListAndParam(fig, reslist, paramname)
                safename = setname.replace(" ","").replace(",","")
                fig.savefig("%s/chi2_%s_%s.pdf" % (outdir, paramname, safename))

    elif plotmode == "compare":
        pnames = resdict.values()[0].getParamNames()
        fig = matplotlib.pyplot.figure()
        for pname in pnames:
            plotCompareForParam(fig, pname)
            fig.savefig("%s/compare_%s.pdf" % (outdir, pname))
    else:
        sys.stderr.write(conf.getHelp())
        sys.stderr.write("Error: Given plot mode '%s' is not supported. Use chi2 or compare!\n" % plotmode)
        sys.exit(1)
