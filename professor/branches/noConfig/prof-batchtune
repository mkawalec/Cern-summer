#! /usr/bin/env python

modes = ["RUNCOMBS", "OBS"]

usage = """
%%prog [options] <cmd> <templatefile> [<templatefile> ...]

Create batch scripts for prof-tune. 

cmd is the batching mode: %s""" % str(modes)

import os, sys, re
import logging, cmd

#import glob, shutil, time
#import threading, Queue, subprocess, signal
#import traceback, unittest


## Try importing Cheetah templating
try:
    from Cheetah.Template import Template
except:
    progname = os.path.basename(sys.argv[0])
    sys.stderr.write("%s requires Cheetah (www.cheetahtemplate.org)\n" % progname)
    exit(1)



def get_templates(tfiles):
    """Get template strings from template files."""
    TEMPLATES = {}
    for tfile in tfiles:
        if not os.access(tfile, os.R_OK):
            logging.warning("Can't read batch script template " + tfile)
            exit(1)
        #TEMPLATEDIR = os.path.dirname(tfile)
        #if len(TEMPLATEDIR) == 0:
        #    TEMPLATEDIR = os.getcwd()
        #if not os.access(TEMPLATEDIR, os.W_OK):
        #    logging.warning("Can't write to batch script dir " + os.path.abspath(TEMPLATEDIR))
        #    exit(1)
        scriptbasename = os.path.basename(tfile)
        scriptbasename = re.sub(r'\.template$', '', scriptbasename)
        scriptbasename = re.sub(r'\.tmpl$', '', scriptbasename)
        f = open(tfile, "r")
        scripttemplate = f.read()
        f.close()
        TEMPLATES[scriptbasename] = scripttemplate
    return TEMPLATES


def write_templates(templates, tokens, instance_number):
    ## Loop over templates ("parts") for this run
    for tpath, ttext in templates.iteritems():
        extn = "%03d" % instance_number
        if opts.SET_ID:
            extn = opts.SET_ID + extn
        scriptpath = tpath + "." + extn
        ## Extra tokens for expansion
        tokens['PROF_SETID'] = opts.SET_ID
        tokens['PROF_THIS'] = scriptpath
        tokens['PROF_RUNDIR'] = os.path.abspath(opts.RUN_DIR)
        tokens['PROF_OUTDIR'] = os.path.abspath(opts.OUT_DIR)
        scripttmpl = Template(ttext, tokens)
        scriptstr = str(scripttmpl)
        ## Write to file
        logging.info("Writing script to %s" % scriptpath)
        f = open(scriptpath, "w")
        f.write(scriptstr)
        f.close()




## Internal command parser
class BatchCmd(cmd.Cmd):
    """Process commands that query the LHAPDF library."""
    intro = "Generate different sorts of Professor tuning batch scripts"
    prompt = "prof> "

    def emptyline(self):
        return False
    def do_EOF(self, line):
        return True
    def do_exit(self, argstr):
        return self.do_EOF(argstr)
    def do_quit(self, argstr):
        return self.do_EOF(argstr)


    def do_runcombs(self, argstr):
        "Make a set of batch scripts, one for each combination of runs to tune"
        try:
            args = argstr.split()
            DATADIR = args[0]
            OBSFILE = args[1]
            SKIP_RUNS = int(args[2])
            TEMPLATES = get_templates(args[3:])
        except:
            print "Usage: runcombs DATADIR OBSFILE SKIP TEMPLATE [TEMPLATE ...]"
            return

        ## Find run names in the data directory tree
        MCDIRPATH = os.path.join(DATADIR, "mc")
        RUNS = os.listdir(MCDIRPATH)
        nchoose = len(RUNS) - SKIP_RUNS
        from professor.tools.permut import randomUniqueCombinations
        if opts.MAX_NUM_INSTANCES < 1:
            opts.MAX_NUM_INSTANCES = None
        for n, combn in enumerate(randomUniqueCombinations(RUNS, nchoose, opts.MAX_NUM_INSTANCES)):
            logging.debug("Combination #%d (%d of %d) = %s" % (n, nchoose, len(RUNS), str(combn)))
            OUTFILE = "results-%d-comb-%d.xml" % (SKIP_RUNS, n)
            if opts.SET_ID:
                OUTFILE = opts.SET_ID + "-" + OUTFILE
            tokens = {
                'PROF_RUNCOMB'   : combn,
                'PROF_DATADIR'   : os.path.abspath(DATADIR),
                'PROF_JOB'       : n,
                'PROF_NUMSKIP'   : SKIP_RUNS,
                'PROF_NUMCHOOSE' : nchoose,
                'PROF_OUTFILE'   : OUTFILE,
                'PROF_OBSFILE'   : os.path.abspath(OBSFILE)
                }
            write_templates(TEMPLATES, tokens, n)

    #def help_runcombs(self, argstr):
    #    print ""


    def do_obs(self, argstr):
        "Make a set of batch scripts, one for each observable/weight file in OBSDIR"

        ## Get available obsset files and check them for accessibility
        OBSFILES = [f for f in os.listdir(opts.OBS_DIR) if not f.endswith('~')]
        for n, obsfile in enumerate(OBSFILES):
            if opts.MAX_NUM_INSTANCES is not None and n >= opts.MAX_NUM_INSTANCES:
                logging.info("Max number of instances is less than the number of obs/weight files")
                logging.info("Remaining obs/weight files: %s" % str(OBSFILES[n:]))
                break
            outfile = os.path.abspath(os.path.join(opts.OUT_DIR, "results_%s.xml" % obsfile))
            obspath = os.path.join(OBSDIRPATH, obsfile)
            if not os.access(obspath, os.R_OK):
                logging.error("Observable file %s not readable: skipping" % obsfile)
                continue
            tokens = {
                'PROF_RUNCOMB'  : [],
                'PROF_DATADIR'  : os.environ["PWD"],
                'PROF_JOB'      : obsfile,
                'PROF_OUTFILE'  : os.path.abspath(outfile),
                'PROF_OBSFILE'  : os.path.join(OBSPATH, obsfile)
                }
            write_templates(TEMPLATES, tokens, n)

    #def help_obs(self, argstr):
    #    print ""



if __name__ == '__main__':

    ## Parse command line options
    from optparse import OptionParser, OptionGroup
    parser = OptionParser(usage=usage)
    parser.add_option("--outdir", dest="OUT_DIR",
                      default=".", help="directory where results are to be stored")
    parser.add_option("--rundir", dest="RUN_DIR",
                      default=".", help="directory where run should take place")
    parser.add_option("--setid", dest="SET_ID",
                      default=None, help="identifier for this set of instantiations")
    parser.add_option("--max", dest="MAX_NUM_INSTANCES", type=int,
                      default=100, help="maximum number of template instances to create")
    parser.add_option("-V", "--verbose", action="store_const", const=logging.DEBUG, dest="LOGLEVEL", 
                      default=logging.INFO, help="print extra status messages")
    parser.add_option("-Q", "--quiet", action="store_const", const=logging.WARNING, dest="LOGLEVEL", 
                      default=logging.INFO, help="be very quiet")
    (opts, args) = parser.parse_args()

    ## Set up logging
    logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")

    ## Run command parser
    if not len(args):
        BatchCmd().cmdloop()
    else:
        wholecmd = " ".join(args)
        BatchCmd().onecmd(wholecmd)
