#! /usr/bin/env python
"""
%prog --datadir DATADIR --obsfile OBSFILE
%prog --refdir REFDIR --mcdir MCDIR --obsfile OBSFILE

Start chi^2 minimizations for all one-run-left-out choices and all runs.
The minimization results are stored in a given file (--outfile option) and
can be read by other programs (e.g. prof-plotminresults to plot the results
in a chi^2 parameter plane).

TODO
  * Change runs-to-leave-out arg name to --skip-nruns
"""

import sys, os, logging
import logging
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")
import optparse
from professor.tools.config import convParamList
from professor.rivetreader import (getConfiguredData, readObservableFile,
        addDataCLOptions)
from professor.minimize import getMinimizerClass, ResultList, ValidationFailed
from professor.tools import permut
from professor.histo import Histo
from professor.tools.parameter import readParameterFile

from professor import interpolation


## Import minimiser error
try:
    from minuit import MinuitError
except ImportError:
    try:
        from minuit2 import MinuitError
    except:
        logging.error("Can't import Minuit: exiting")
        exit(1)


## Set up signal handling
import signal
global RECVD_KILL_SIGNAL
RECVD_KILL_SIGNAL = None
def handleKillSignal(signum, frame):
    "Declare us as having been signalled, and return to default handling behaviour"
    logging.critical("Signal handler called with signal " + str(signum))
    logging.critical("Waiting for this minimization to finish...")
    global RECVD_KILL_SIGNAL
    RECVD_KILL_SIGNAL = signum
    signal.signal(signum, signal.SIG_DFL)
## Signals to handle
signal.signal(signal.SIGTERM, handleKillSignal);
signal.signal(signal.SIGHUP,  handleKillSignal);
signal.signal(signal.SIGINT,  handleKillSignal);
signal.signal(signal.SIGUSR2, handleKillSignal);

parser = optparse.OptionParser(usage=__doc__)

group = optparse.OptionGroup(parser, "Tuning")
# group = parser
group.add_option("--outfile",
        dest = "outfile",
        help = "file where the results are stored")
group.add_option("--spmethods", "--start-points",
        dest = "startpointmethods",
        help = "Comma separated list with the minimization"
               " starting point methods")
group.add_option("--check",
        dest = "check",
        action = "store_true",
        help = "call TuningData.isValid() after object has been built")
group.add_option("--no-check",
        dest = "check",
        action = "store_false",
        help = "don't call TuningData.isValid() after object has been built")
group.add_option("--debug",
        dest = "debug",
        action = "store_true",
        help = "Turn debugging on. This will result in doing only a 3"
               " minimizations.")
group.add_option("--shell",
        dest = "shell",
        action = "store_true",
        help = "Start an IPython shell after running the script.")
group.add_option("--ipolhistos",
        dest = "ipolhistos",
        help = "Specify path where interpolation (at predicted minima)"
               " histos are to be stored.")
group.add_option("--runs",
        dest = "runs",
        type = "int",
        help = "The number of runs that should be left out, e.g. for 30"
               " available MC runs, '1' gives the 30 interpolations with 1"
               " run left out. You can restrict the combinatorics using --max")
group.add_option("--runsfile",
        dest = "runsfile",
        help = "Specify a file of run combinations to use (space separated, 1"
               " combination per line)")
group.add_option("--max",
        dest = "maxminimizations",
        type = "int",
        help = "maximum number of minimizations")
group.add_option("--manual-sp", "--manual-startpoint",
        dest = "manualstartpoint",
        help = "Comma separated list of parameter name - value pairs to be used"
               " as manual startpoints when spmethod 'manual' is selected."
               " Name and value are separated by a equals ('=').  e.g."
               " PARJ(21)=1.2,PARJ(22)=2.4 .")
parser.set_defaults(
        outfile = "./results.xml",
        startpointmethods = "random",
        check = True,
        debug = False,
        shell = False,
        runs = 0,
        maxminimizations = 1000
        )
parser.add_option_group(group)


mingroup = optparse.OptionGroup(parser, "Minimization")
mingroup.add_option("--minimizer",
        choices = ("pyminuit", "scipy"),
        help = "Select the minimizer to use (pyminuit|scipy)"
               " (default: %default)")
mingroup.add_option("--minos",
        dest = "useminos",
        action = "store_true",
        help = "When using Minuit, use MINOS instead of MIGRAD to estimate"
               " the parameter errors.")
mingroup.add_option("--migrad",
        dest = "useminos",
        action = "store_false",
        help = "When using Minuit, use MIGRAD to estimate"
               " the parameter errors (default).")
mingroup.add_option("--print-minuit",
        dest = "printminuit",
        type = "choice",
        choices = (0,1,2,3),
        help = "When using Minuit, set printMode to the given value."
               " (default: %default)")
group.add_option("--validate",
        dest = "validate",
        action = "store_true",
        help = "Validate the result. NB: Only supported by pyminuit.")
group.add_option("--no-validate",
        dest = "validate",
        action = "store_false",
        help = "Don't validate the result.")
mingroup.add_option("--fixed-parameters",
        dest = "fixedparameters",
        help = "Comma separated list of parameter name - value pairs with"
               " parameter values to be fixed during minimization. Format is"
               " the same as with '--manual-startpoint', e.g."
               " PARJ(21)=1.2,PARJ(22)=2.4 . NB: Only supported by pyminuit!")
group.add_option("--limits",
        dest = "limits",
        help = "file with parameter limits to be used with minuit")
parser.set_defaults(
        minimizer = "pyminuit",
        useminos = False,
        printminuit = 0,
        validate = False)
parser.add_option_group(mingroup)

interpolation.addCLOptions(parser)
addDataCLOptions(parser)
opts, args = parser.parse_args()

#print opts
#print args


## Turn debug logging on off
if opts.debug is True:
    logging.getLogger().setLevel(logging.DEBUG)
    # logging.basicConfig(level=logging.DEBUG,
            # format="%(asctime)s %(levelname)s %(message)s")
    DEBUG = True
    logging.info("running in debug mode")
else:
    # logging.basicConfig(level=logging.INFO,
            # format="%(asctime)s %(levelname)s %(message)s")
    DEBUG = False


## 1. Check option values and load data
##    Ordered by time consumption.


## Read start point config
spmethods = opts.startpointmethods.split(',')
logging.info("using start point methods: %s"%(', '.join(spmethods)))


## Convert manual startpoint option
manualsp = convParamList(opts.manualstartpoint)
logging.info("Using manual startpoint %s"%(manualsp))
if manualsp is not None and "manual" not in spmethods:
    if len(spmethods)== 1:
        logging.info("Changing start point method from %s to %s"
                % (spmethods, ["manual"]))
        spmethods = ["manual"]
    else:
        logging.info("Adding 'manual' to start point methods.")
        spmethods.append("manual")

## Get the configured interpolation class
try:
    IpolCls = interpolation.getInterpolationClass(opts.ipolmethod,
            opts.useweave)
    logging.info("using %s for interpolation." % (IpolCls.__name__))
except Exception, e:
    logging.error("Problem getting interpolation method: %s" % (e))
    logging.error("Exiting...")
    sys.exit(1)


## Get the configured minimizer class.
try:
    MinimizerCls = getMinimizerClass(opts.minimizer,
            useminos = opts.useminos, printminuit = int(opts.printminuit))
    logging.info('Using %s as minimizer.'%(MinimizerCls.__name__))
except Exception, e:
    logging.error("Problem getting minimizer: %s" % (e))
    logging.error("Exiting...")
    sys.exit(1)


## Test if we can write to outfile.
outfile = opts.outfile
outfile = os.path.abspath(os.path.expanduser(outfile))
if os.path.exists(outfile):
    if not os.path.isfile(outfile):
        raise IOError("Given output file '%s' exists and is not a"
                      " file!"%(outfile))
    if not os.access(outfile, os.W_OK):
        raise IOError("Given output file '%s' exists and I don't have"
                      " write permissions!"%(outfile))
else:
    base = os.path.dirname(outfile)
    print base
    if not os.access(base, os.W_OK|os.X_OK):
        raise IOError("Given output file '%s' can not be created!"%(outfile))


## Convert the runs option
num_runs_to_skip = opts.runs

## Convert fixed parameters
fixedpars = convParamList(opts.fixedparameters)
logging.info("Using fixed parameter %s"%(fixedpars))

## Convert parameter limits
try:
    limits = readParameterFile(opts.limits)
    logging.info("Using parameter limits %s"%(limits))
except:
    limits = {}
    logging.info("Not using any parameter limits")


## Select the observables we want to use for our tune.
try:
    obsdict = readObservableFile(opts.observablefile)
except Exception, e:
    logging.error("Problem when reading observable file: %s" % (e))
    logging.error("Exiting!")
    sys.exit(1)
else:
    logging.debug("loaded observable file from %s: %s" % (
        opts.observablefile, obsdict))


## Load and check tuning data.
tundat = getConfiguredData(opts.datadir, opts.mcdir, opts.refdir, opts.ipoldir)
if opts.check:
    tundat.isValid()
else:
    logging.warning("no validation of TuningData object performed")


## Check if ipolhisto outdir exists:
if opts.ipolhistos is not None:
    if not os.path.exists(opts.ipolhistos):
        os.mkdir(opts.ipolhistos)
    elif (not os.path.isdir(opts.ipolhistos)
            or os.access(opts.ipolhistos, os.W_OK|os.X_OK)):
        sys.stderr.write(parser.format_help())
        sys.stderr.write("Error: Given output directory for histogram files"
                " exists and is not a directory or has wrong access rights:"
                " %s" % (opts.ipolhistos))
        sys.exit(1)

## 2. Build minimizer and result container
minimizer = MinimizerCls()
## Create a result list which will be written to an outfile at the end.
reslist = ResultList()


## 3. Set up observables and available MC run numbers.
observables = obsdict.keys()
allruns = tundat.getRunNums()
if opts.maxminimizations is None:
    allruns.sort()
else:
    logging.info("Max. number of tunings: %d" % opts.maxminimizations)


def tune(runs):
    """Perform a full tune for the given choice of runs."""
    # build SingleTuneData instance
    std = tundat.getTuneData(IpolCls, use_runnums=runs, use_obs=observables)
    # and apply weights
    std.applyObservableWeightDict(obsdict)
    for meth in spmethods:
        logging.info("Starting minimization for runs %s and spmethod %s"%(
                                sorted(runs), meth))
        mr = minimizer.guessMinimum(std, spmethod=meth, manualsp=manualsp, fixedpars=fixedpars, limits=limits)
        # Replace the line above by an appropiately changing the following
        # line. (For the parameter index remember that parameters are sorted
        # alphabetically)
        # mr = minimizer.guessMinimumFixed(std, meth, {0: 1.45})
        logging.info("Result: %s"%(mr))

        if opts.validate:
            try:
                minimizer.validateResult(mr)
            except ValidationFailed, e:
                logging.error("Validation failed for runs %s:\n    %s"%(runs, e))
                logging.error("Result not appended!")
                continue

        if opts.limits is not None:
            # do not append minimization result if any of the results 
            # components is equal to a param limit specified via --limits
            mdict = mr.asDict(scaled=False)
            def equal(a, b):
                """ compare floats """
                return abs(a - b) < 1e-4

            def resultIsLimit():
                """ check if minresult is a param limit """
                for k,v in limits.iteritems():
                    if equal(mdict[k],v[0]) or equal(mdict[k],v[1]):
                        return True
                return False

            if resultIsLimit():
                logging.error("Result component identical to a param limit!")
                if meth == "random":
                    logging.error("Result not appended, will try again.")
                    ## Make sure that one gets as many results as specified via --max
                    global notunes
                    notunes -= 1
                else:
                    logging.error("Result not appended!")
                continue
        reslist.append(mr)

        ## Save interpolation histograms to file at the predicted minimum
        if opts.ipolhistos is not None:
            outname = os.path.join(opts.ipolhistos,
                    "%s_index_%i.dat" % (
                        opts.outfile.split("/")[-1].replace(".", "_"),
                        len(reslist) - 1))
            # outname = opts.ipolhistos+'/%s_index_%i.dat'%(
                    # opts.outfile.split('/')[-1].replace('.','_'), len(reslist) - 1)
            f = open(outname,'w')

            for i in sorted(std.getObservables()):
                f.write(std.getInterpolationHisto(i, mr, tundat.getTitle(i)).asFlat() + '\n\n')
            f.close()
            logging.info("Written corresponding interpolation histos to %s"%outname)



##  Function to iterate over run combinations from a file
def iter_runcombs_file(maxnum=None):
    global RUNCOMBFILE
    f = open(RUNCOMBFILE, "r")
    for n, l in enumerate(f.readlines()):
        #print "***", n, maxnum
        if maxnum is not None and n >= maxnum:
            break
        runcomb = l.split()
        yield runcomb
    f.close()


##  Function to iterate over run combinations generated on the fly
def iter_runcombs(maxnum):
    global allruns
    global num_runs_to_skip
    for combn in permut.xrandomUniqueCombinations(allruns, (len(allruns) - num_runs_to_skip), maxnum):
        yield combn


## Chose sampling from file or on the fly based on --runsfile arg
RUNCOMBFILE = opts.runsfile
if RUNCOMBFILE:
    iter_runcombs = iter_runcombs_file
    #for i in iter_runcombs(1000):
    #    print len(i), i



## 4. Start tuning for the run combinations
num_tunes_done = 0
MAXNUM = opts.maxminimizations
for runs in iter_runcombs(MAXNUM+1):
    ## Break out now if we should
    if DEBUG and num_tunes_done >= 3:
        logging.info("Only 3 tunings will be done in debug mode; stopping here...")
        break
    if num_tunes_done >= MAXNUM:
        logging.info("Max number of tunings reached, stopping here...")
        break
    if RECVD_KILL_SIGNAL is not None:
        logger.critical("Leaving event loop early due to signal " + str(RECVD_KILL_SIGNAL))
        break

    ## Do this tune!
    try:
        tune(runs)
        num_tunes_done += 1
    ## TODO: Hide this as a generic prof.MinimiserError
    except MinuitError:
        logging.warning("Minimiser yielded an error for this tuning attempt")
        continue
    except KeyboardInterrupt:
        logging.critical("Keyboard interrupt detected, you'll have to go with %i results only." % len(reslist))
        break
    if RECVD_KILL_SIGNAL is not None:
        logging.critical("Leaving event loop early due to signal " + str(RECVD_KILL_SIGNAL))
        break


## 5. Store results in outfile
## TODO: It would be nice if we could periodically dump this file during 
##   the tuning process, rather than having to wait all the way to the end
logging.info("Writing results to '%s'" % outfile)
reslist.write(outfile)


## 6. Optionally start an IPython shell to inspect the results
if opts.shell:
    logging.info("Opening IPython shell...")
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed([])
    ipshell()
