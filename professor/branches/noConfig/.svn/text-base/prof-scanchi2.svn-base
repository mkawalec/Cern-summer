#!/usr/bin/env python

USAGE = \
"""Usage: %prog [options] --datadir=<datadir> --results=<results.xml>

Calculate goodness of fit for a run (or set of runs).
Intended to be used with rivetrunner in "scan mode".

Information about run combinations to be used for the interpolation are
taken from a result.xml file. It is thus mandatory to specify it via the
--results switch. If not, only MC scan data is plotted, no interpolations
whatsoever.

Also an obervable(weights) file has to be specified via --obsfile. Only
observables in it will be used during any chi2 calculation.

Optionally the minimization results themselves can be drawn (at least in
LINESCAN mode) as vertical which indicate the position of a minimization
results parameter point if projected onto a parameter axis. In this case it
is recommended ot also specify the file of parameter boundaries the scan was
done with via --scanrange. Otherwise the first and the last run's parameters
will be used to calculate the projection, which only works properly if these
two runs really contain the edges of the LINESCAN.
"""

import sys
import os, re
import logging
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")
import optparse
import numpy
import pylab

# Professor imports and config
from professor.tools import parameter
from professor import rivetreader
from professor import minimize
from professor.tools import planelineprojection as plp
from professor.tools.progressbar import ForLoopProgressBar as flpb
from matplotlib.font_manager import fontManager, FontProperties
from matplotlib.patches import FancyArrow

try:
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed([])
except:
    print "Ipython shell not available."

parser = optparse.OptionParser(usage = USAGE)
rivetreader.addDataCLOptions(parser)
parser.add_option("--debug",
        action = "store_true",
        help = "print debugging messages")
parser.add_option("--outdir",
        help = "specify directory in which to write out chi2 data files")
parser.add_option("--outfile",
        help = "specify file name  for output, by default file name is"
               " generated automatically")
parser.add_option("--results",
        help = "The results file to use, to reload the used run names"
               " and observables for the interpolation. The observables"
               " must match those in the observable/weight file (option"
               " obsfile)!")
parser.add_option("--params",
        help = "Specifiy the parameters for the x-axis in a comma"
               " separated list. For each parameter a new plot is"
               " created. Use 'LINESCAN' to use the line scan"
               " parameter.")
parser.add_option("--scanparams",
        help = "in case of LINESCAN, specifiy the parameter file(s), the"
               " scan was done with. Use ',' as separator between two"
               " filenames.")
parser.add_option("--vlines",
        help = "draw vertical line at the projection of these points on"
               " the scan line as such: --vlines file.params:'tune A'")
parser.add_option("--vbands",
        help = "draw vertical error bands at the projection of a point"
               " as such: --vbands file.params:'tune A'   file.params"
               " would need to have a structure as 'param value errlow errhigh'")
parser.add_option("--logy",
        dest = "logy",
        action = "store_true",
        help = "Log scaled chi^2 axis when PLOTMODE is chi2. (default)")
parser.add_option("--liny",
        dest = "logy",
        action = "store_false",
        help = "Linear scaled chi^2 axis when PLOTMODE is chi2.")
parser.add_option("--ndof",
        dest = "ndof",
        action = "store_true",
        help = "Plot chi^2/ndof instead of chi^2 when PLOTMODE is chi2. (default)")
parser.add_option("--no-ndof",
        dest = "ndof",
        action = "store_false",
        help = "Plot chi^2 instead of chi^2/ndof when PLOTMODE is chi2. (default)")
parser.add_option("--plotminimia",
        dest = "plotminima",
        action = "store_true",
        help = "Draw vertical lines to indicate predicted minima.")
parser.add_option("--no-plotminimia",
        dest = "plotminima",
        action = "store_false",
        help = "Don't draw vertical lines to indicate predicted minima. (default)")
parser.add_option("--clean",
        dest = "clean",
        action = "store_true",
        help = "if set, only those minimization results will be considered"
               " that really fall into the hypercube")
parser.add_option("--shell",
        dest = "shell",
        action = "store_true",
        help = "Open IPython Shell (if available) before plotting.")
parser.add_option("--pazo",
        dest = "pazo",
        action = "store_true",
        help = "include \usepackage[mathpazo] in preamble")
parser.add_option("--direction",
        help = "additional information for the plot title")
parser.add_option("--bw",
        dest = "bw",
        action = "store_true",
        help = "produce b/w safe plots, e.g. suitable for publications")
parser.add_option("--color",
        dest = "bw",
        action = "store_false",
        help = "produce color plots (default)")
parser.add_option("--no-scandata",
        dest = "noscandata",
        action = "store_true",
        help = "do not plot/require MC scan histos, use used_params files only")

parser.set_defaults(
        debug = False,
        outdir = "./",
        logy = True,
        ndof = True,
        plotminima = False,
        clean = False,
        shell = False,
        pazo = False,
        bw = False,
        noscandata = False)

(opts, args) = parser.parse_args()

if opts.scanparams is None:
    scanparams = []
else:
    scanparams = opts.scanparams.split(",")

## matplotlib setup
params = {
        'backend':'pdf',
        'axes.labelsize': 20,
        'text.fontsize': 20,
        'legend.fontsize': 20,
        'axes.titlesize': 20,
        'xtick.labelsize': 20,
        'ytick.labelsize': 20,
        'text.usetex': True,
        'text.latex.preamble' :  ['\usepackage{amsmath}'],
        'figure.dpi': 150,
        'lines.markersize':7.5,
        'figure.subplot.left' : 0.1,
        'figure.subplot.right' : 0.995,
        'figure.subplot.bottom' : 0.1,
        'figure.subplot.top' : 0.979
        }
if opts.pazo:
    params['text.latex.preamble'] = ['\usepackage{amsmath}', '\usepackage{mathpazo}']
pylab.rcParams.update(params)

# set font type for legend
legendfont = FontProperties(family='serif', style='normal')

## Define data generation functions
def getScanData(pname, zerocoeffbinids):
    """Get two lists with parameter values and GoF values of ref vs. scan mc
    data for plotting.
    """
    pars = []
    chi2s = []
    NDOF = 0
    for scanrun in sorted(scandat.getRunNums()):
        if pname == "LINESCAN":
            try:
                pval = scandat.getScanParam(scanrun)
            except:
                print "Not using scan run #%s"%scanrun
                continue
        else:
            pval = scandat.getParam(scanrun, pname)
        gofdata = scandat.getGoFFromMC(scanrun, obsdict, zerocoeffbinids)
        gofdata.referror = True
        gofdata.simerror = False

        pars.append(pval)
        if ndof:
            chi2val = gofdata.chi2/gofdata.ndof
        else:
            chi2val = gofdata.chi2
        chi2s.append(chi2val)
        logging.debug("Scanrun %s : len = %i  chi2_scan = %s  ndof = %s"%(
            scanrun, len(gofdata), chi2val, gofdata.ndof))
        NDOF += gofdata.ndof
    return pars, chi2s, NDOF

def getIpolData(mcrandomruns, pname):
    """Return two lists: interpolation parameters, interpolation chi^2s.

    The chi^2s are calculated using the interpolation for the given random
    MC runs.
    """
    pars = []
    chi2s = []

    std = tundat.getTuneData(mcrandomruns, obsdict.keys())
    std.applyObservableWeightDict(obsdict)
    def keyfunc(runnum):
        if pname == "LINESCAN":
            pval = scandat.getScanParam(runnum)
        else:
            pval = scandat.getParam(runnum, pname)
        return pval
    for scanrun in sorted(scandat.getRunNums(), key=keyfunc):
        pdict = scandat.getParams(scanrun)
        if pname == "LINESCAN":
            pval = scandat.getScanParam(scanrun)
        else:
            pval = scandat.getParam(scanrun, pname)

        gofdata = std.getGoFFromIpol(pdict, scaled=False)
        gofdata.referror = True
        gofdata.simerror = False

        allchi2ndof.append(gofdata.chi2/gofdata.ndof)

        pars.append(pval)
        if ndof:
            chi2val = gofdata.chi2/gofdata.ndof
        else:
            chi2val = gofdata.chi2
        chi2s.append(chi2val)
        logging.debug("Scanrun %s : len = %i  chi2_ipol = %s  ndof = %s"%(
            scanrun, len(gofdata), chi2val, gofdata.ndof))

    return pars, chi2s, std._zerocoeffbinids

def getScanRange():
    """ return the parameter ranges used for the scanruns """
    def compCube(c1, c2):
        if getCubeSize(c1) > getCubeSize(c2):
            return 1
        else:
            return -1

    temp = []
    for rangefile in scanparams:
        params = parameter.readParameterFile(rangefile)
        temp.append(params)
    if len(temp) == 1:
        return temp
    elif len(temp) == 2:
        ### check if keys are equal first
        if sorted(temp[0].keys()) == sorted(temp[1].keys()):
            ### return param ranges sorted from smalles to largest 
            temp.sort(cmp=compCube)
            return temp
    else:
        print "Not more than two filenames supported."
        sys.exit(1)

def getLength(ranges):
    return numpy.sqrt(sum([(v[1] - v[0])**2 for v in ranges.values()]))

def getCubeSize(rangedict):
    """Return the volume of an n-dim. cube in parameter space.
    @param rangedict: a dict that holds parameter ranges
    """
    volume = 1.
    for v in rangedict.values():
        volume *= abs(v[1] - v[0])
    return volume

def getProjectedPredictions(pars, predict, scanrange):
    """ projects minimization results onto the scanline in the param-hypercube
    """
    p0 = numpy.array([scanrange[par][0] for par in pars])
    p1 = numpy.array([scanrange[par][1] for par in pars])
    projpred = dict.fromkeys(predict)
    for k, v in predict.iteritems():
        projpred[k] = plp.getLambda(v, p0, p1)
    return projpred

def getIpolMethod():
    """ return either 'cubic' or 'quadratic', based on the first ipol in tundat
        and therein the first binprob's method
    """
    firstipol = tundat._ipols[tundat._ipols.keys()[0]]
    firstipolsfirstbinprob = firstipol[firstipol.keys()[0]]
    ipolmethod = firstipolsfirstbinprob.method
    return ipolmethod

def projectPointsOnLineScan(P):
    n_columns = 2 + len(P)
    scrange = getScanRange()[0]
    n_rows = len(scrange.keys())
    ## prepare numpy array. columns 0 and 1 will hold the scan ranges
    ## while all other columns correspond to the parampoints one wishes
    ## to project
    T = numpy.zeros((n_rows, n_columns))
    for numi, par in enumerate(sorted(scrange.keys())):
        T[numi, 0] = scrange[par][0]
        T[numi, 1] = scrange[par][1]
        for numj, keyj in enumerate(sorted(P.keys())):
            T[numi, 2 + numj] = P[keyj][par]
    projections = {}
    for num, name in enumerate(sorted(P.keys())):
        projections[name] = plp.getLambda(T[:,2 + num], T[:,0], T[:,1])
    return projections

# turn debug logging on off
if opts.debug:
    logging.getLogger().setLevel(logging.DEBUG)
    DEBUG = True
    logging.info("running in debug mode")
else:
    DEBUG = False

## 1. Check option values and load data
##    Ordered by time consumption.

## Select the observables and weights we want to use for our tune.
obsfile = opts.observablefile
if not obsfile is None:
    obsdict = rivetreader.readObservableFile(obsfile)
    logging.debug("loaded observable file from %s: %s"%(obsfile, obsdict))
else:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("No obsfile specified, thus exiting (use --obsfile) ...\n")
    sys.exit(1)

## Load minimization results.
if not opts.results is None:
    reslist = minimize.ResultList.fromXML(opts.results)
    if opts.clean:
        try:
            reslist=reslist.getResultsInsideRange(getScanRange()[-1])
        except IndexError:
            reslist=reslist.getResultsInsideRange(getScanRange())

    ## Check if observables match obsdict.
    if reslist.getObservables() != sorted(obsdict.keys()):
        sys.stderr.write(parser.format_help())
        sys.stderr.write("\nObservables in obsfile %s and result file %s do not"
                         " match!\n"%(obsfile,
                             opts.results))
        sys.exit(1)

## Check/make output directory
outdir = opts.outdir
outdir = os.path.abspath(outdir)

if not os.path.exists(outdir):
    os.makedirs(outdir)
    logging.info("Making output directory: %s"%(outdir))
elif not os.path.isdir(outdir):
    sys.stderr.write("Output directory '%s' exists but is not a directory!"%(
                     output))
    sys.stderr.write("Exiting...\n")
    sys.exit(1)
if not os.access(outdir, os.W_OK| os.X_OK):
    sys.stderr.write("Output directory '%s' has not the proper access mode!"%(
                     output))
    sys.stderr.write("Exiting...\n")
    sys.exit(1)

## Load parameter names.
plotparams = opts.params.split(",")
for param in plotparams:
    if param != "LINESCAN" and param not in scandat.paramNames():
        sys.stderr.write(parser.format_help())
        sys.stderr.write("\nParameter '%s' not in available paramter"
                         " names (LINESCAN, %s).\n\n"%(param,
                             ', '.join(scandat.paramNames())))
        sys.exit(1)

## check if parameter files supplied via vbands and vlines 
def checkVbandsLines(comseplist, name):
    for i in comseplist:
        if not os.path.exists(i.split(":")[0]):
            logging.error("file given by %s does not exist"%name)
            sys.exit(1)

vl = opts.vlines
vb = opts.vbands
if vl is not None:
    checkVbandsLines(vl, "--vlines")
if vb is not None:
    checkVbandsLines(vb, "--vbands")

## Load and check scan and random tuning data.
if not opts.results is None:
    tundat = rivetreader.getConfiguredData(opts.datadir, opts.mcdir, opts.refdir,
            opts.ipoldir)
    #tundat.isValid()
else:
    logging.info("No results file spcified, thus only plotting MC scan.")
if not opts.noscandata:
    scandat = rivetreader.getConfiguredScanData(opts.datadir, opts.scandir,
            opts.mcdir, opts.refdir, opts.ipoldir, getparamsonly=False)
else:
    scandat = rivetreader.getConfiguredScanData(opts.datadir, opts.scandir,
            opts.mcdir, opts.refdir, opts.ipoldir, getparamsonly=True)

#scandat.isValid()



logy = opts.logy
ndof = opts.ndof

allchi2ndof = []
if opts.shell:
    ipshell()

## define figure and axis
figheigth = 6
fig = pylab.figure(facecolor='w')#, figsize=(0.5*(numpy.sqrt(5.)-1)*figheigth,figheigth))

### desired heigth of plotwindow with interpolations and scan data
plotheigth = 0.65

### remaining heigth for histogram plotwindow
histheigth = pylab.rcParams.get('figure.subplot.top') - pylab.rcParams.get('figure.subplot.bottom') - plotheigth

### the lower axes
ax_plot = pylab.axes([
        pylab.rcParams.get('figure.subplot.left'),
        pylab.rcParams.get('figure.subplot.bottom'),
        pylab.rcParams.get('figure.subplot.right') -pylab.rcParams.get('figure.subplot.left') ,
        plotheigth]
        )

### the upper axes used for the histogram of minimization results
ax_hist = pylab.axes([
        pylab.rcParams.get('figure.subplot.left'),
        pylab.rcParams.get('figure.subplot.bottom') + plotheigth,
        pylab.rcParams.get('figure.subplot.right') -pylab.rcParams.get('figure.subplot.left') ,
        histheigth]
        )

# create a plot for each parameter
for param in plotparams:

    # plot the chi^2s for each selection of runs in the given result list.
    ipolkwargs = {"linestyle" : "-",
                  #"linewidth" : .2,
                  }

    scankwargs = {"color" : "r",
                  "marker" : "o",
                  "linestyle" : "",
                  "zorder"    : 12
                  }
    if opts.bw:
        scankwargs["color"] = "w"

    if not opts.results is None:
        ## drawing the interpoaltion and collection minimization results
        predictions = {} # this is for collecting the minimization results
        ## sort reslist by number of runs used for interpolation first
        resdict = {}
        for numruns in reslist.getRunCounts():
            temp = [i for i in reslist if len(i.runs) == numruns]
            resdict[str(numruns)] = temp
        ## and plot, iterating over number of runs used for interpolation first
        for numruns, sublist in resdict.iteritems():
            # iterate over the minimization results in the according list
            bar = flpb(0, len(sublist), 30, '%i ipols with %s runs: '%(len(sublist) ,numruns))
            for i, mr in enumerate(sublist):
                bar.update(i)
                if DEBUG and i >= 3:
                    break
                predictions[str(i)] = mr.parunscaled
                pars = mr.getKeys()
                pipol, mcipol, zerocoeffbinids = getIpolData(mr.runs, param)
                if int(numruns) == len(tundat.getRunNums()):
                    if opts.bw:
                        color="k"
                    else:
                        color="r"
                    linewidth = 2
                    zorder = 11
                    label="$\\mathrm{%s\\: interpolation(s)}$"%getIpolMethod()
                else:
                    if opts.bw:
                        color="0.7"
                    else:
                        color="b"
                    zorder = 10
                    linewidth = .03
                    label = None
                if i == len(sublist) -1:
                    ax_plot.semilogy(pipol, mcipol, label=label, color=color,
                        zorder=zorder, linewidth=linewidth, **ipolkwargs)
                else:
                    ax_plot.semilogy(pipol, mcipol, color=color, zorder=zorder, **ipolkwargs)

    ## getting and drawing scan MC data
    pscan, cscan, NDOF = getScanData(param, None)
    ax_plot.semilogy(pscan, cscan, label="$\\mathrm{scan\\: MC\\: data}$", **scankwargs)

    ## in case parameter point files were supplied via --vlines, read params, calculate
    ## their projection on the scan line and plot a vertical line there


    # reduce xlim, ylim
    if param == "LINESCAN":
        ax_plot.set_xlim(0.,1.)
        ax_plot.set_ylim(1.,70.)

    # prepare minimization results for plotting
    if not opts.results is None:
        sMR = reslist.getMinimum()
        sMR_chi2ndof = sMR.chi2/sMR.ndof
        if opts.plotminima is not False:
            overflow, underflow = 0, 0
            allmins = []
            if param == "LINESCAN":
                scanrange = getScanRange()
                for i, t in enumerate(getProjectedPredictions(pars,
                    predictions, scanrange[0]).values()):
                    # append only those min results that are on LINESCAN
                    if t < 0.:
                        underflow += 1
                    elif t > 1:
                        overflow += 1
                    elif t >= 0. and t <= 1:
                        allmins.append(t)
            ## plot a horizontal line smallest chi2/ndof in results
            m_line=ax_plot.axhline(
                    y=sMR_chi2ndof, xmin=.2, xmax=.8, linewidth=1.5, ls='--', c='k',
                    label='$\\mathrm{min}(\\chi^2/N_{\\mathrm{df}})=%.1f$'%sMR_chi2ndof, linewidth=2)
            ## plot histo of min results on top subplot
            if not len(allmins) == 0:
                ax_hist.hist(allmins, bins=4*numpy.floor(numpy.sqrt(len(reslist))),
                        range=(0, 1), histtype='step', zorder=1,
                        facecolor=None, edgecolor=None)
            else:
                logging.warning("results empty???")
            # remove ticks from top subplot
            pylab.setp(ax_hist, xticks=[], yticks=[])

    ## creating plot title
    title = "$\\chi^2\\mathrm{-scan}"
    if param == "LINESCAN":
        if len(scanparams) == 2 and opts.direction is None:
            volumes = map(getCubeSize,getScanRange())
            edgelength = (volumes[0]/volumes[1])**(1./scandat.numberOfParams())
            title += "\\mathrm{\\: through\\: minimum\\: along\\: body\\: diagonal\\: of\\: largest\\: symmetric\\: hypercube}"

        elif len(scanparams) == 1:
            title += "\\mathrm{\\:along\\: body\\: diagonal\\: of\\: sampling\\: hypercube}"
        elif len(scanparams) == 2 and opts.direction is not None:
            title += "\\mathrm{\\:through\\: minimum\\: along\\: direction\\: of\\: %s\\: uncertainty}"%opts.direction

        title += "$\\newline"
        title += "$\\quad N_{\\mathrm{df}}\\: =\\:%i"%NDOF
        try:
            title += "\\quad\\mathrm{min}(\\chi^2/\\mathrm{ndof})\\: =\\:%.4f"%min(allchi2ndof)
        except:
            pass

        if len(scanparams) == 2 and opts.direction is None:
            title += "\\quad\\mathrm{rel.\\: edgelength\\:=\\: %.2e}"%edgelength
        title += " \\quad\\mathrm{length\\: of\\: scan\\: line}\\:=\\:%.2e$"%getLength(getScanRange()[0])
    else:
        title+="$"

    # this is the y-label
    if ndof:
        ax_plot.text(-.1,60,"$\\chi^2/N_{\\mathrm{df}}$", fontsize=20,
                va='top', rotation=90)
    else:
        ax_plot.set_ylabel("\\LARGE{$\\chi^2$}", rotation=0)

    ## this is the x-label
    if param == "LINESCAN":
        ax_plot.text(0.5,.5, "$\\tilde{p}$", fontsize=20, ha="center")
    else:
        ax_plot.set_xlabel("$\\mathrm{Parameter}\\quad \\mathrm{%s}$"%(param))

    # create legend and remove its frame
    legend = ax_plot.legend(loc='best', labelspacing=0.02, handletextpad=0.04)
    legend.get_frame().set_edgecolor('w')
    legend.set_alpha(.1)
    legend.set_zorder(20)

    # nicer xticks
    ax_plot.set_xticks(numpy.linspace(.1,.9,3))
    ax_plot.get_xaxis().tick_bottom()
    # replicate xticks in upper subplot
    ax_hist.set_xticks(numpy.linspace(.1,.9,3))
    ax_hist.set_xticklabels(["","",""])
 
    ax_hist.set_yticks([10, 40])
    ax_hist.text(-.1, 20, "$\\frac{\\Delta N}{\\Delta\\tilde{p}}$", fontsize=20, rotation=90)
    ax_hist.get_xaxis().tick_bottom()
    ax_hist.get_yaxis().tick_left()

    # nicer yticks
    tix = [i for i in numpy.linspace(1,9,9)]
    for i in numpy.linspace(10,90,9):
        tix.append(i)
    labels=[]
    for i in tix:
        if i==1:
            l="$10^{\\:0}$"
        elif i==10:
            l="$10^{\\:1}$"
        else:
            l=""
        labels.append(l)
    ax_plot.set_yticks(tix)
    ax_plot.set_yticklabels(labels)
    ax_plot.get_yaxis().tick_left()

if "LINESCAN" in plotparams:
    param = "LINESCAN"
    vl = opts.vlines
    if vl is not None and param == "LINESCAN":
        P = {}
        for i in vl:
            pfile, label = i.split(":")
            P[label] = parameter.readParameterFile(pfile)
        # project points on line scan axes
        projections = projectPointsOnLineScan(P)
        for k, v in projections.iteritems():
            vl = ax_plot.axvline(v, zorder=0, color='k')
            ax_vl = vl.axes
            ax_vl.annotate("$\\LARGE\\mathrm{%s}$"%k, xy=(v,1.1), xycoords='data', rotation=90,
                    xytext=(-20, 0), textcoords='offset points', size=pylab.rcParams.get('text.fontsize') -2
                    )

    vb = opts.vbands
    if vb is not None and param == "LINESCAN":
        P = {}
        labels = []
        for i in vb:
            pfile, label = i.split(":")
            temp = parameter.readParameterFile(pfile)
            V, m, M = {}, {}, {}
            for k, v in temp.iteritems():
                V[k] = v[0]
                m[k] = v[0] - v[2]
                M[k] = v[0] + v[1]
            P[label] = V
            P[label+"errlow"]=m
            P[label+"errhigh"]=M
            labels.append(label)
        projbands = projectPointsOnLineScan(P)

        # unfortunately we have to define a new axes for the errorband
        ax_plot2 = pylab.axes([
                pylab.rcParams.get('figure.subplot.left'),
                pylab.rcParams.get('figure.subplot.bottom')+.01,
                pylab.rcParams.get('figure.subplot.right') -pylab.rcParams.get('figure.subplot.left') ,
                plotheigth-.02]
                )

        for i in labels:
            temp = []
            for k, v in projbands.iteritems():
                if k.split(i)[-1] == "errlow":
                    temp.append(v)
                if k.split(i)[-1] == "errhigh":
                    temp.append(v)
            low = min(temp)
            high= max(temp)
            ax_plot2.axvspan(low, high, alpha=.1, zorder=0)
            ax_plot2.set_xticks([])
            ax_plot2.set_yticks([])
            ax_plot2.set_axis_bgcolor('none')
            ax_plot2.set_frame_on(False)

    # filename generation
    fname = "scan_chi2_%s"%param
    if not opts.results is None:
        fname+="_%s"%opts.results.replace('.',"_")
    if len(scanparams) == 2 and opts.direction is None:
        fname += "_symmetric"
    elif len(scanparams) == 2 and opts.direction is not None:
        fname += "_%s"%opts.direction

    if opts.bw:
        fname +="_bw"
    if opts.clean:
        fname +="_clean"
    if logy:
        fname += "_log"
    else:
        fname += "_lin"
    if opts.outfile is not None:
        fname = opts.outfile
    savename = os.path.join(opts.outdir,
            fname + "." + pylab.rcParamas.get("backend"))
    fig.savefig(savename)
    logging.info("saving image as %s"%savename)
    f=open('title_'+fname+'.tex','w')
    f.write(title)
    f.close()
    logging.info("written title information to %s"%('title_'+fname+'.tex'))
