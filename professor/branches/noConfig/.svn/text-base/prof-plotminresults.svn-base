#! /usr/bin/env python

"""%prog

Create pdf plots in the given directory and the given file mode.

Usage:
    %prog [options] PLOTMODE RESULT.XML:"label1" [RESULT2.XML:"label2" ...]

    PLOTMODE sets the type of the created plots:
        - chi2: Creates chi^2 vs. parameter result plots. One plot for each
                parameter and each given results file.
        - compare: Creates paramter result vs. observable set plots. One
                   plot for each parameter.

    RESULT.XML a result file created by prof-tune. If you are plotting
    results for different sets of observables, the results for each set
    should be in separate files (RESULT2.XML ...)

Use --help to get information for all options.

TODO: file naming scheme
"""

import sys
import os
import itertools
import optparse
import logging
logging.basicConfig(level=logging.INFO,
        format = "%(levelname)s %(message)s")

import numpy
import matplotlib, matplotlib.pyplot

from professor.tools import formulas, parameter
from professor.minimize import ResultList

params = {
        'backend':'pdf',
        'axes.labelsize': 20,
        'text.fontsize': 20,
        'legend.fontsize': 20,
        'axes.titlesize': 20,
        'xtick.labelsize': 20,
        'ytick.labelsize': 20,
        'text.usetex': True,
        'figure.dpi': 150,
        'lines.markersize':7.5,
        'figure.subplot.left' : 0.12,
        'figure.subplot.right' : 0.995,
        'figure.subplot.bottom' : 0.1,
        'figure.subplot.top' : 0.979,
        'lines.markersize':5
        }

matplotlib.pyplot.rcParams.update(params)

parser = optparse.OptionParser(usage = __doc__)
parser.add_option("--logy",
        dest = "logy",
        action = "store_true",
        help = "Log scaled chi^2 axis when PLOTMODE is chi2.")
parser.add_option("--liny",
        dest = "logy",
        action = "store_false",
        help = "Linear scaled chi^2 axis when PLOTMODE is chi2. (default)")
parser.add_option("--ndof",
        dest = "ndof",
        action = "store_true",
        help = "Plot chi^2/ndof instead of chi^2 when PLOTMODE is chi2."
               " (default)")
parser.add_option("--no-ndof",
        dest = "ndof",
        action = "store_false",
        help = "Plot chi^2 instead of chi^2/ndof when PLOTMODE is chi2.")
parser.add_option("--outdir",
        help = "The directory were the plots are saved. (default: %default)")
parser.add_option("--paramsfile",
        help = "The file that contains the parameters for prof-runrivet")
parser.add_option("--bw",
        dest = "bw",
        action = "store_true",
        help = "produce b/w safe plots, e.g. suitable for publications")
parser.add_option("--color",
        dest = "bw",
        action = "store_false",
        help = "produce color plots (default)")

parser.set_defaults(
        logy = False,
        ndof = True,
        outdir = "./",
        bw = False)

opts, args = parser.parse_args()

## Load/check data and commandline.
try:
    plotmode = args[0]
    resultpaths = args[1:]
except IndexError:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Bad number of arguments!\n")
    sys.exit(1)

if plotmode not in ("chi2", "compare"):
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Given plotmode is not supported. Use chi2"
                     "or compare!\n")
    sys.exit(1)

# Load parameter-file
try:
    par_boundaries = parameter.readParameterFile(opts.paramsfile)
except:
    par_boundaries = None

# Load results to a [observable set name]->[result list] dict.
resdict = {}
if len(resultpaths) == 0:
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: No result files given!\n")
    sys.exit(1)
for p in resultpaths:
    try:
        rfile, name = p.split(":")
    except ValueError:
        logging.info("no plot label specified for %s, using filename instead"%p)
        name = os.path.splitext(os.path.basename(p))[0]
        rfile = p
    reslist = ResultList.fromXML(rfile)
    reslist.isValid()
    resdict[name] = reslist

# Check existence and mode of outdir
outdir = opts.outdir
if not os.path.isdir(outdir):
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Given output path does not exist or is no"
                     " directory!\n")
    sys.exit(1)
if not os.access(outdir, os.W_OK | os.X_OK):
    sys.stderr.write(parser.format_help())
    sys.stderr.write("\n\nError: Given output path has not the proper"
                     " access mode!")
    sys.exit(1)

logy = opts.logy
ndof = opts.ndof


## Define some plotting routines.
def getColors(keys):
    colorcycle = itertools.cycle(['r', 'k', 'b', 'g'])
    if opts.bw:
        colorcycle = itertools.cycle(['k', '.8'])
    d = {}
    for k in sorted(keys, reverse=True):
        d[k] = colorcycle.next()
    return d


def inRanges(mr):
    """Add a flag "inlimits" to min result objects to indicate whether they lie 
       outside *any* of the the given parameter sampling ranges."""
    if par_boundaries is not None:
        for p in mr.getKeys():
            ip = mr.getIndex(p)
            boundary = par_boundaries[p]
            if mr.parunscaled[ip] < boundary[0] or mr.parunscaled[ip] > boundary[1]:
                print "Outside range for %s: %f not in [%f,%f]" % (p, mr.parunscaled[ip], boundary[0], boundary[1])
                return False
    return True


def plotChi2ForListAndParam(fig, reslist, paramname):
    """Plot chi^2 vs. parameter result for one result list and observable
    set.

    This creates one plot.
    """

    ## Group MinRun objects together by num_runs
    data = {}
    for mr in reslist:
        num_runs = len(mr.runs)
        if not data.has_key(num_runs):
            data[num_runs] = []
        data[num_runs].append(mr)

    colordict = getColors(data.keys())
    pmin = pmax = None

    ## Plot chi2 vs. param value
    fig.clear()
    sub = fig.add_subplot(1,1,1)
    if logy:
        #sub.semilogy(params, chi2s, **kwargs)
        sub.set_yscale("log")

    pindex = reslist[0].getIndex(paramname)
    for num_runs, mrs in sorted(data.iteritems()):

        ## Split points by whether they are inside all param ranges
        params = { "IN":[], "OUT":[] }
        perrs = { "IN":[], "OUT":[] }
        chi2s = { "IN":[], "OUT":[] }
        for mr in mrs:
            if inRanges(mr):
                if len(mr.parunscaled) > pindex:
                    params["IN"].append( mr.parunscaled[pindex] )
                if len(mr.errunscaled) > pindex:
                    perrs["IN"].append( mr.errunscaled[pindex] )
                chi2s["IN"].append( mr.chi2 / mr.ndof )
            else:
                if len(mr.parunscaled) > pindex:
                    params["OUT"].append( mr.parunscaled[pindex] )
                if len(mr.errunscaled) > pindex:
                    perrs["OUT"].append( mr.errunscaled[pindex] )
                chi2s["OUT"].append( mr.chi2 / mr.ndof )

        ## Get drawing colours, and alphaize the out-of-range version
        colorcode = colordict[num_runs]
        inrange_color = matplotlib.colors.ColorConverter().to_rgb(colorcode)
        outrange_color = [c + 0.5*(1-c) for c in inrange_color]
        colors = { "IN" : inrange_color, "OUT" : outrange_color }

        for n, i in enumerate(["OUT", "IN"]):
            if not params[i]:
                continue

            ## For the xlims
            if pmin is None or min(params[i]) < pmin:
                pmin = min(params[i])
            if pmax is None or max(params[i]) > pmax:
                pmax = max(params[i])

            kwargs = {"marker" : "o", "linestyle":"",
                      "color" : colors[i],
                      "label" : "$N_\\mathrm{runs} = %i\\:\\mathrm{(%s)}$" % (num_runs, i.lower()) }

            ## Draw more-runs results on top of fewer-runs ones
            zorder = num_runs + n
            try:
                j, k, l = sub.errorbar(params[i], chi2s[i], 
                                       xerr=perrs[i], zorder=zorder, **kwargs)
            except:
                sub.plot(params[i], chi2s[i], zorder=zorder, **kwargs)

    ## Plot vertical lines at the parameter-sampling-boundaries
    if par_boundaries is not None:
        sub.axvline(x=par_boundaries[paramname][0], ls=':', c='g')
        sub.axvline(x=par_boundaries[paramname][1], ls=':', c='g',
                    label="$\\mathrm{Sampling\\:boundaries}$", zorder=0)
    else:
        print "%s: no parameter boundaries are being plotted; be careful how you interpret the plots!" % paramname
        

    ## Draw a vertical line at the weighted mean of all results
    #w_mean, w_err = reslist.mean(paramname)
    #sub.axvline(x=w_mean, ls='-', c='k', zorder=1,
    #            label="$\\overline{\\mathrm{%s}}=(%.2f\\pm%.2f)$" % (paramname, w_mean, w_err))

    ## Set sensible xlims
    if par_boundaries is not None:
        lows = [par_boundaries[paramname][0], pmin]
        highs = [par_boundaries[paramname][1], pmax]
    else:
        lows = [pmin]
        highs =[pmax]

    nicenPlotLimits(sub, lows, highs, 'x')
    sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()
    #sub.set_ylim(0,10)

    sub.set_xlabel("$\\mathrm{%s}$" % paramname)
    if ndof:
        sub.set_ylabel("$\\chi^2/N_{\\mathrm{df}}$")
    else:
        sub.set_ylabel("$\\chi^2$", rotation=0)

    try:
        l = sub.legend(loc="best", labelspacing=0.02, handletextpad=0.04)
    except:
        l = sub.legend(loc="best")
    if l is not None:
        l.get_frame().set_edgecolor('w')
        l.set_alpha(0.1)
        l.set_zorder(20)
    return sub


def stringsStartwith(alist, token):
    """ returns True if all the string in alist start with the same token """
    for item in alist:
        if not len(item.split(token)) == 2:
            return False
        else:
            continue
    return True


def plotCompareForParam(fig, paramname, identifier='results'):
    setnames = sorted(resdict.keys())

    fig.clear()
    # these are for the y-limits of the subplot
    mins = []
    maxs = []
    all = []
    sub = fig.add_subplot(111)
    for i, setname in enumerate(setnames):
        allofset = []
        reslist = resdict[setname]
        pindex = reslist[0].getIndex(paramname)
        # x = i + 1
        x = i + 1
        ydata = {}
        for mr in reslist:
            nor = len(mr.runs)
            if not ydata.has_key(nor):
                ydata[nor] = ([], [], [])
            ydata[nor][0].append(mr.parunscaled[pindex])
            try:
                ydata[nor][1].append(mr.errunscaled[pindex][0])
                ydata[nor][2].append(mr.errunscaled[pindex][1])
            except:
                pass

        # build color dict
        coldict = getColors(ydata.iterkeys())

        for nor in sorted(ydata.iterkeys()):
            ys, yErHigh, yErLow = ydata[nor]
            ## find index of largest and lowest errors
            temp = list(yErHigh)
            temp.extend(list(yErLow))
            try:
                i_max = list(yErHigh).index(max(temp))
            except ValueError:
                if not len(temp) == 0:
                    i_max = list(yErLow).index(max(temp))
            try:
                i_min = list(yErHigh).index(min(temp))
            except ValueError:
                if not len(temp) == 0:
                    i_min = list(yErLow).index(min(temp))

            for j in ys:
                allofset.append(j)
            # for the ylims...
            mins.append(min(ys))
            maxs.append(max(ys))

            sub.plot(x*numpy.ones(len(ys)), ys, marker="o",
                     linestyle="", color=coldict[nor], zorder=10)
            try:
                if i ==1 :
                    sub.errorbar([x], [ys[i_max]],
                            yerr=[[yErHigh[i_max]],[yErLow[i_max]]],
                            color=coldict[nor],
                            label="$N_\\mathrm{runs}=%i$"%nor, zorder =12)
                else:
                    sub.errorbar([x], [ys[i_max]], yerr=[[yErHigh[i_max]],
                        [yErLow[i_max]]], color=coldict[nor], zorder =12)
            except:
                pass
        # small hline at the mean of current set
        mean = numpy.mean(allofset)
        d = 1./(len(setnames) +1)
        f=.2
        if i == 1:
            sub.axhline(y=mean, xmin=d*(x-f), xmax=d*(x+f), ls='-', c='k',
                    lw=.1, label="$\\mathrm{Weighted\\: mean}$", zorder=9)
        else:
            sub.axhline(y=mean, xmin=d*(x-f), xmax=d*(x+f), ls='-', c='k',
                    lw=.6, zorder=9)

        all.append(numpy.mean(allofset))
    # plot horizontal lines at the param-sampling-boundaries
    if not par_boundaries is None:
        sub.axhline(y=par_boundaries[paramname][0], ls=':', c='g')
        sub.axhline(y=par_boundaries[paramname][1], ls=':', c='g',
                label="$\\mathrm{Sampling\\:boundaries}$")


    sub.set_ylabel("$\\mathrm{%s}$"%(paramname))
    #sub.set_xlabel("$\\mathrm{Observable\\: set}$")
    sub.set_xticks(range(1, len(setnames) + 1))
    def wrap(string):
        return "$\\mathrm{"+string+"}$"
    clean_setnames = [i.replace("_","\\:") for i in setnames]
    sub.set_xticklabels(map(wrap,clean_setnames), rotation=0, y=-0.02)
    sub.set_xlim(0, len(setnames) + 1)

    # set useful y-limits, so that the horizontal lines are displayed nicely
    if not par_boundaries is None:
        lows = [par_boundaries[paramname][0], min(mins)]
        highs = [par_boundaries[paramname][1], max(maxs)]
    else:
        lows = [min(mins)]
        highs =[max(maxs)]

        nicenPlotLimits(sub, lows, highs, 'y')

    sub.get_xaxis().tick_bottom()
    sub.get_yaxis().tick_left()

    try:
        l = sub.legend(loc=0, labelspacing=0.02, handletextpad=0.04)
        l.get_frame().set_edgecolor('w')
        l.set_alpha(.1)
        l.set_zorder(20)
    except AttributeError:
        pass
    return sub


def nicenPlotLimits(sub, lows, highs, axis):
    try:
        dist = abs(lows[0] - highs[1])
        newmin = min(lows)  - .1*dist
        newmax = max(highs) + .1*dist
    except IndexError:
        newmin = min(lows)
        newmax = max(highs)
    if axis == "x":
        sub.set_xlim(xmax=newmax)
        sub.set_xlim(xmin=newmin)
    elif axis == "y":
        sub.set_ylim(ymax=newmax)
        sub.set_ylim(ymin=newmin)
    else:
        raise StandardError("axis has to be either 'x' or 'y'")



if __name__ == "__main__":

    if plotmode == "chi2":
        # Plot and save chi^2 vs. parameter for all observable sets and
        # parameters.
        for setname, reslist in resdict.iteritems():
            #print reslist
            #for i in reslist:
            #    print i
            for paramname in reslist.getParamNames():
                fig = matplotlib.pyplot.figure(facecolor='w')
                sub = plotChi2ForListAndParam(fig, reslist, paramname)
                safename = setname.replace(" ","").replace(",","")
                fig.savefig("%s/chi2_%s_%s.pdf" % (outdir, paramname, safename))

    elif plotmode == "compare":
        pnames = resdict.values()[0].getParamNames()
        fig = matplotlib.pyplot.figure()
        for pname in pnames:
            plotCompareForParam(fig, pname)
            fig.savefig("%s/compare_%s.pdf" % (outdir, pname))
    else:
        sys.stderr.write(conf.getHelp())
        sys.stderr.write("Error: Given plot mode '%s' is not supported. Use chi2 or compare!\n" % plotmode)
        sys.exit(1)
