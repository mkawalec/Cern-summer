#! /usr/bin/env python

"""\
%prog [options] results.pkl [...]

Plot parameter-parameter correlations.

Two covariance estimates are available:
  1. covariance matrix as estimated by the minimiser (MINUIT) for the
    minimisation that is based on the maximal number of runs.
  2. a sample covariance estimator that represents the parameter-parameter
    correlation between different choices of runs.

The plots file names follow this naming scheme:
    OUTDIR/correlation/NAME-ESTIMATE.pdf
where OUTDIR is the given output dir, NAME is the basename of the result
file's path without the extension and ESTIMATE is either 'sample' or
'minimiser', i.e. the origin of the estimation.
"""

import sys, os
import numpy
from matplotlib import pyplot, cm

from professor import user as prof
from professor.controlplots import makeplotshelper as mph
from professor.tools.stringtools import latexEscape


params = {
        'backend':'pdf',
        'figure.dpi': 200,
        'text.fontsize': 16,
        'legend.fontsize': 8,
        'axes.titlesize': 16,
        'axes.labelsize': 16,
        'xtick.labelsize': 16,
        'ytick.labelsize': 16,
        'lines.markersize':7,
        'figure.subplot.left' : 0.16,
        'figure.subplot.right' : 0.98,
        'figure.subplot.top' : 0.98,
        'figure.subplot.bottom' : 0.36,
        'text.usetex': False
        }
pyplot.rcParams.update(params)


import optparse
parser = optparse.OptionParser(usage = __doc__, version=prof.version)
#parser.add_option("-o", "--outdir",
                  #dest = "OUTDIR",
                  #default = "correlations",
                  #help = "Output directory for correlation plots. [default: %default]")
parser.add_option("--tex",
                  dest = "TEX",
                  action = "store_true",
                  default = False,
                  help = "Print out LaTeX table code to stdout for each correlation plot.")
parser.add_option("--no-sample-correlation",
                  dest = "USESAMPLE",
                  action = "store_false",
                  default = True,
                  help = "Do not plot the sample correlation estimates")
parser.add_option("--minimiser-correlation",
                  dest = "USEMINIMISER",
                  action = "store_true",
                  default = False,
                  help = "Plot the minimiser correlation estimates for the run"
                  " combination with maximal number of runs.")
parser.add_option("--format",
                  dest = "FORMAT",
                  type = "choice",
                  choices = ["makeplots", "matplotlib"],
                  default = "matplotlib",
                  help = "Choose format of output files [default: %default]")
#parser.add_option("--make-plots",
                  #dest = "MAKEPLOTS",
                  #action = "store_true",
                  #default = False,
                  #help = "Produce output file for make-plots rather than matplotlib.")
prof.addDataCLOptions(parser, mc=False, ref=True, ipol=True, scan=False)
prof.addLoggingCLOptions(parser)
prof.addOutputCLOptions(parser)
opts, args = parser.parse_args()
if not args:
    sys.stderr.write(parser.format_help() + "\n")
    sys.stderr.write("Error: No result files given!")
    sys.exit(1)

prof.log.setPriority(opts)
prof.writeGuideLine()


## Check if specified outdir exists and create it otherwise.
outdir = prof.getOutputDirectory(opts, "correlations")
prof.log.debug("Using %s for sampling output." % outdir)
prof.io.makeDir(outdir)


# TODO: move this to professor/controlplots
def plotCorrelations(fig, paramnames, corr):
    """
    Parameters
    ----------
    fig : matplotlib.Figure
    paramnames : list of str
        The sorted parameter names.
    corr : array_like
        The parameter-parameter correlation matrix.
    """
    assert corr.shape == (len(paramnames), len(paramnames))
    # grid for pseudo color plots
    X, Y = numpy.meshgrid(numpy.arange(len(paramnames) + 1),
                          numpy.arange(len(paramnames) + 1))
    sub = fig.add_subplot(1,1,1)
    # Reverse the y direction (i.e. axis 0 for the pcolor call) to get
    # variances on the 1st diagonal. A 'transpose()' is not necessary here.
    #
    # Convert correlation matrix to plain ndarray, because ParameterMatrix
    # does not allow reversing the order of rows/columns
    corr = numpy.asarray(corr)
    col = sub.pcolor(X, Y, corr[::-1], vmin=-1.0, vmax=1.0, cmap=cm.RdBu_r)
    colbar = fig.colorbar(col)
    colbar.set_label('$C_{ij}$', rotation=0)
    sub.set_xticks(numpy.arange(len(paramnames)) + 0.5)
    sub.set_xticklabels(paramnames, rotation=305,
            horizontalalignment="left")
    sub.set_yticks(numpy.arange(len(paramnames)) + 0.5)
    # sub.set_yticklabels(paramnames)
    # y tick labels are reversed.
    sub.set_yticklabels(paramnames[::-1])

def writeLatexTable(stream, params, corr):
    # fix some tex issues with SHERPA parameter names
    params = map(latexEscape, params)
    # head of table
    stream.write(r"\begin{tabular}{l|*{%i}{c}}" % (len(params))
            + "\n")
    stream.write(" & " + " & ".join(params) + r" \\\hline" "\n")
    for i, p1 in enumerate(params):
        stream.write(p1)
        for j, p2 in enumerate(params):
            if j < i:
                stream.write(" & -- ")
            else:
                stream.write(" & %.2f" % (corr[i,j]))
        stream.write(r"\\" + "\n")
    stream.write(r"\end{tabular}" + "\n")

def getMakePlotsHeader(resultsname, paramnames):
    header = "# BEGIN PLOT\n"
    header +="DrawOnly=%s\n"%resultsname
    header += "RatioPlot=0\n"
    header += "LogY=0\n"
    header += "Title=Parameter correlations for %s\n"%resultsname.split("-")[0]
    header += "ZMin=-1.0\n"
    header += "ZMax=1.0\n"
    header += "LeftMargin=1.7\n"
    header += "BottomMargin=1.5\n"
    header += getTicks(paramnames)
    header += "# END PLOT\n\n"
    return header

def getTicks(paramnames):
    xticks="XCustomTicks="
    yticks="YCustomTicks="
    for num, param in enumerate(paramnames):
        if not num == len(paramnames)-1:
            xticks+="%.1f\t\\rput[r]{45}(0,0){\\strut %s}\t"%(num+.5, param)
            yticks+="%.1f\t\\strut %s\t"%(len(paramnames) -1 - num+.5, param)
        else:
            xticks+="%.1f\t\\rput[r]{45}(0,0){\\strut %s}"%(num+.5, param)
            yticks+="%.1f\t\\strut %s"%(len(paramnames) -1 - num+.5, param)

    return xticks + "\n" + yticks + "\n"

def getMakePlotsHisto(correlations, paramnames, resultsname):
    # Some data preparation first
    data = []
    X, Y = numpy.meshgrid(numpy.arange(len(paramnames) + 1),
                          numpy.arange(len(paramnames) + 1))
    X=X[0]
    Y=Y[:,0][::-1]
    for i in xrange(len(X)-1):
        for j in xrange(len(Y)-1):
            z=correlations[i][j]
            if not numpy.isnan(z):
                data.append((X[i], X[i+1], Y[j+1], Y[j], z))
            else:
                data.append((X[i], X[i+1], Y[j+1], Y[j], 0))

    # Get the histo
    histo  = "# BEGIN HISTOGRAM %s\n"%resultsname
    histo += mph.get2DHisto(data)
    histo += "# END HISTOGRAM\n"
    return histo

def writeMakePlots(fname, correlations, paramnames, resultsname):
    f = open(fname, "w")
    f.write(getMakePlotsHeader(resultsname, paramnames))
    f.write(getMakePlotsHisto(correlations, paramnames, resultsname))
    f.close()

def cov2corr(covmat):
    """Calculate correlation coefficients from a covariance matrix."""
    # code copied from numpy.corrcoeff() source code
    try:
        d = numpy.diag(covmat)
    except ValueError: # scalar covariance
        return 1
    return covmat/numpy.sqrt(numpy.multiply.outer(d,d))


for path in args:
    prof.log.info("Working on file %s..." % (path))
    fbase = os.path.splitext(os.path.basename(path))[0]
    reslist = prof.ResultList.mkFromPickle(path)
    if opts.USESAMPLE:
        paramnames = reslist.getParamNames()
        fpath = os.path.join(outdir, fbase + "-sample.")
        corr = reslist.getSampleCorrelations()

        if opts.FORMAT == "matplotlib":
            fpath += "pdf"
            fig = pyplot.figure(1, facecolor="w", figsize=(10, 10))
            plotCorrelations(fig, paramnames, corr)
            pyplot.savefig(fpath)
            fig.clf()
        else:
            fpath += "dat"
            writeMakePlots(fpath, corr, paramnames, fbase+"-sample")

        prof.log.info("  saved sample correlations to %s" % (fpath))
        if opts.TEX:
            sys.stdout.write("%% Table for sample correlations of results in"
                    " %s\n" % (path))
            writeLatexTable(sys.stdout, paramnames, corr)

    if opts.USEMINIMISER:
        fpath = os.path.join(outdir, fbase + "-minimiser.")
        t = reslist.getMaxRunsResults()
        if len(t) > 1:
            prof.log.warn("%i results with maximal number of runs in file"
                         " %s!" % (len(t), path))
            prof.log.warn("Using the first result only!")
        correl = cov2corr(t[0].covariance)
        print correl

        if opts.FORMAT == "matplotlib":
            fpath += "pdf"
            fig = pyplot.figure(1, facecolor="w")
            plotCorrelations(fig, correl.names, correl)
            pyplot.savefig(fpath)
            fig.clf()

        elif opts.FORMAT == "makeplots":
            fpath += "dat"
            writeMakePlots(fpath, correl, correl.names, fbase+"-minimiser")

        prof.log.info("  saved minimiser correlations to %s" % fpath)

        if opts.TEX:
            # TODO: Really want raw use of stdout?
            sys.stdout.write("%% Table for minimiser correlations of results in %s\n" % path)
            writeLatexTable(sys.stdout, correl.names, correl)
