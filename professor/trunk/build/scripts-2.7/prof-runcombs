#!/usr/bin/python2

"""\
%prog [<command> [<args>]] [options]

Create/extract run combinations.

Supported commands are:

create (default)
    Construct run combinations from a MC run data directory.
    Example:

    %prog create --mcdir mc/ -c 0:1 -c 15:50

extract
    Extract run combinations from results file or another run combinations
    file. The second is only useful combined with the --range RANGEFILE
    option. The result/run-combinations file must be given as second
    argument to %prog.
    Examples:

    %prog extract results.pkl

    %prog extract runcombs1.dat --range central.range --outfile runcombs1-central.dat

Runs/run-combinations can be excluded by explicitely specifying the run
numbers with the --exclude option or --range can be used to include only
runs/run-combinations that are inside the given parameter range.
"""

import sys, os
import professor.user as prof

from professor.tools import permut

import optparse
parser = optparse.OptionParser(usage=__doc__, version=prof.version)
prof.addDataCLOptions(parser, mc=True)

## Define some more global options
parser.add_option("-o", "--outfile",
                  dest="OUTFILE", metavar="FILE", default="runcombs.dat",
                  help="Output file-name [default: %default]")
parser.add_option("-r", "--range",
                  dest="RANGEFILE", metavar="RANGEFILE", default=None,
                  help="Accept only runs in the ranges of RANGEFILE"
                  " [default is to accept all runs]")
parser.add_option("-x", "--exclude", "-X",
                  default=None, dest="EXCLUDE",
                  help="Comma-separated list of MC runs that will not be included"
                  " in the run combinations.")

## Define command functions and add command-specific command line options.
## Define both at the same place of the script to make maintainance easier.

g = optparse.OptionGroup(parser, "Create-mode specific")
# TODO: Let's get rid of these switch synonyms: which do we like most?
g.add_option("-c", "--comb", "-C", "--ncombs",
             metavar = "COMBINATION",
             dest="COMBINATIONS",
             action="append",
             help="Run combination definition of the form"
                  " '#(left out):#(combinations)'. Multiple definitions can"
                  " be given. [default: create one rc with all runs]")
parser.add_option_group(g)

prof.addLoggingCLOptions(parser)
opts, args = parser.parse_args()
prof.log.setPriority(opts)
prof.writeGuideLine()
if not args:
    args.append("create")
    prof.log.debug("setting default command")
command = args[0]
args = args[1:]


## Load MC data
try:
    dataproxy = prof.DataProxy.mkFromCLOptions(opts)
    MCDATA = dataproxy.getMCData()
except Exception, err:
    msg = "Failed to load MC data:\n"
    msg += err.message + "\n"
    sys.stderr.write(msg)
    sys.exit(1)


def create():
    """Create run combinations from a MC data directory."""
    runs = set(MCDATA.availableruns)
    prof.log.debug("Found valid runs %s" % runs)

    excl = getExcluded()
    runs.difference_update(excl)

    # parse combination definitions
    runcombs = []
    for comb in opts.COMBINATIONS:
        try:
            leaveout, numcombs = map(int, comb.split(":"))
        except Exception, err:
            msg = "Failed to parse combination definition '%s'!" % comb
            sys.stderr.write(msg)
            sys.exit(1)
        thisrc = permut.xrandomUniqueCombinations(runs, len(runs) -
                                                    leaveout, numcombs)
        runcombs.extend(thisrc)

    # print run combinations to global OUTSTREAM object
    outputRunCombs(runcombs)



def extract(fname):
    """Extract run combinations from results/runcombinations file."""
    # load run combinations from file
    if fname.endswith(".pkl"):
        prof.log.debug("Opening result list %s" % fname)
        rl = prof.ResultList.mkFromPickle(fname)
        inputrcs = [res.runs for res in rl]
    else:
        prof.log.debug("Opening run combination file %s" % fname)
        inputrcs = [line.split() for line in open(fname)]

    excl = list(getExcluded())

    outputrcs = []
    for rc in inputrcs:
        rcokay = True
        # Loop over excluded run IDs instead of the present run IDs because
        # the number of excluded run IDs is probably less than the number of
        # runs in the run combinations.
        for runid in excl:
            if runid in rc:
                rcokay = False
                break
        if rcokay and rc not in outputrcs:
            outputrcs.append(rc)
    outputRunCombs(outputrcs)


## Little helpers.

def outputRunCombs(runcombs):
    """Write out run combination."""
    if len(runcombs) == 0:
        sys.stderr.write("No run combinations created/extracted!\n")
        sys.exit(1)

    outdir = os.path.dirname(opts.OUTFILE)
    prof.io.makeDir(outdir)
    try:
        out = open(opts.OUTFILE, "w")
    except Exception, err:
        sys.stderr.write("Failed to open %s: %s\n" % (opts.OUTFILE, err.message))
        sys.exit(1)
    for rc in runcombs:
        out.write(" ".join(rc) + "\n")
    out.close()
    prof.log.info("Written %i run combinations to %s" % (len(runcombs), out.name))


def getExcluded():
    """Return set with all run IDs that are excluded.

    Runs are excluded either explicitely by --exclude or because they are
    outside of --range.
    """
    excl = set()
    # exclude runs from --exclude
    if opts.EXCLUDE is not None:
        excl.update(opts.EXCLUDE.split(","))

    # exclude runs outside --range
    if opts.RANGEFILE is not None:
        global MCDATA
        ranges = prof.ParameterRange.mkFromFile(opts.RANGEFILE)

        # test that ranges are smaller than mcranges
        mcranges = MCDATA.getParameterBounds()
        if ranges.isInside(mcranges.low) and ranges.isInside(mcranges.high):
            prof.log.warn("The ranges in %s are larger than the MC data"
                          " ranges!" % opts.RANGEFILE)
            prof.log.warn("Continuing anyway...")

        for runid in MCDATA.availableruns:
            params = MCDATA.getRunParams(runid)
            if not ranges.isInside(params):
                excl.add(runid)
    prof.log.debug("Excluding runs %s" % sorted(excl))
    return excl



if command == "create":
    if len(args):
        msg = "In create mode no additional arguments are accepted!\n"
        msg += "Additional arguments were: %s\n" % args
        sys.stderr.write(msg)
        sys.exit(1)

    # set the default combination definition, if necessary
    if opts.COMBINATIONS is None:
        opts.COMBINATIONS = ["0:1"]
    create()

elif command == "extract":
    if len(args) != 1:
        msg = ("Exctract mode expects exactly one run-combination or results"
               " file as argument!\n")
        sys.stderr.write(msg)
        sys.exit(1)

    if opts.COMBINATIONS is not None:
        msg = "Option --comb only accepted in create mode!"
        sys.stderr.write(msg)
        sys.exit(1)

    extract(args[0])

else:
    msg = ("Unknown operation mode '%s'.\n"
           "Try %s --help for more information.\n" % (command, sys.argv[0]))
    sys.stderr.write(msg)
    sys.exit(1)
