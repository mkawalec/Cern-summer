#!/usr/bin/python2

"""
%prog --datadir DATADIR [--obsfile OBSFILE] [--runsfile RUNSFILE]

%prog --ipoldir IPOLDIR [--refdir REFDIR] \\
      [--obsfile OBSFILE] [--runsfile RUNSFILE]

%prog visualises histograms derived from the parameterisation of MC generators,
allowing the effects of parameter variations to be investigated interactively in
real-time using a friendly GUI. %prog could in principle also be used for a
manual generator tuning but is mostly useful for exploring the effects of
parameters and determining whether and how particular data features can be
explained within the model which has been parameterised.

TODO:
  * Errorbars for ipolhistos
  * Use mathtext/LaTeX to display the histo-titles properly
"""

import os, sys, numpy
import professor.user as prof

from professor.tools import shell
ipshell = shell.usePrettyTraceback()
shell.setProcessName("prof-I")


## Option parsing
import optparse
parser = optparse.OptionParser(usage=__doc__, version=prof.version)
parser.add_option("--ipolset", dest="IPOLSET", default=None,
                  help="File containing a previously calculated interpolation set")
parser.add_option("--params", "--paramsfile", dest="PARAMS_FILE", default=None,
                  help="File containing a parameters list from a tune, to use as the starting values")
parser.add_option("--paramdescrs", dest="PARAMS_DESCRS", default=None,
                  help="Supply a 'name value'-format text file that maps parameter "
                  "names to human-readable descriptions for the GUI.")
parser.add_option("--mccomparefile", dest="MCCOMPAREFILE", default=None,
                  help="MC runfile (AIDA) to be plotted for comparison")
parser.add_option("--no-ref", dest="SHOW_REF", action="store_false", default=True,
                  help="Don't show reference data")
prof.addRunCombsCLOptions(parser)
prof.addLoggingCLOptions(parser, logoswitch=True)
prof.addDataCLOptions(parser, mc=True, ref=True, ipol=True, scan=False)
prof.addIpolCLOptions(parser, weaveswitch=False)
opts, args = parser.parse_args()


## Set up logging level and print initial messages
prof.log.setPriority(opts)
if opts.SHOW_LOGO:
    prof.writeLogo()
prof.writeGuideLine()


## Import and set up matplotlib (AFTER parsing arguments)
try:
    import matplotlib
    matplotlib.use('WXAgg')
    from matplotlib.figure import Figure
    from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigCanvas
    from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg as NavigationToolbar
    import wx, functools
    params = {
        'backend': 'pdf',
        'axes.labelsize': 16,
        'text.fontsize': 16,
        'legend.fontsize': 16,
        'axes.titlesize': 16,
        'xtick.labelsize': 16,
        'ytick.labelsize': 16,
        'text.usetex': False,
        'text.latex.preamble': [r'\usepackage{amsmath}'],
        'figure.dpi': 50,
        'lines.markersize': 7.5,
        'lines.antialiased' : False,
        'patches.antialiased' : False,
        'figure.subplot.left' : 0.05,
        'figure.subplot.right' : 0.995,
        'figure.subplot.bottom' : 0.1,
        'figure.subplot.top' : 0.95,
        'figure.subplot.wspace' : 0.15
        }
    matplotlib.rcParams.update(params)
except Exception, e:
    prof.log.error("Problem with getting & configuring matplotlib/WX interface method: %s" % e)
    prof.log.error("Exiting!")
    sys.exit(1)


## Get the configured interpolation class
try:
    IpolCls = prof.InterpolationClass
    IpolCls.method = opts.IPOLMETHOD
    prof.log.info("Using %s for parameterisation." % IpolCls.__name__)
except Exception, e:
    prof.log.error("Problem getting parameterisation method: %s" % e)
    prof.log.error("Exiting!")
    sys.exit(1)


dataproxy = prof.DataProxy.mkFromCLOptions(opts)
prof.log.debug("Ref dir: %s" % dataproxy.refpath)
prof.log.debug("Ipol dir: %s" % dataproxy.ipolpath)


## Get the list of runs (first runcomb)
runs = None
if opts.RUNSFILE:
    prof.log.debug("Reading runs from %s" % opts.RUNSFILE)
    try:
        rcm = prof.RunCombManager.mkFromFile(opts.RUNSFILE)
        runs = rcm.firstruncomb
    except Exception, e:
        prof.log.error("Error while opening run combination file %s: %s" % (opts.RUNSFILE, e))
        sys.exit(1)
else:
    prof.log.debug("No run combination file given! Using all available runs.")
    runs = dataproxy.getMCData().availableruns


## Check if an observable file was specified
if opts.OBSERVABLEFILE is None:
    ## Load the list of observables from an interpolation set if not
    ## explicitly given.
    ipolset = dataproxy.getInterpolationSet(IpolCls, runs)
    observables = sorted(ipolset.getHistogramNames())
else:
    wm = prof.WeightManager()
    wm.loadWeightsFile(opts.OBSERVABLEFILE)
    observables = sorted(wm.observables)


## Load ref data and interpolation in TuneData object
try:
    tundat = dataproxy.getTuneData(withref=bool(dataproxy.refpath), useipol=IpolCls,
                                   useobs=observables, useruns=runs)
except prof.DataProxyError, e:
    prof.log.error("Error when loading tune data: %s" % e)
    sys.exit(1)


# TODO: move to professor.tools.utils module
def mkDict(keys, values=None):
    if values is None:
        return dict.fromkeys(keys)
    else:
        # return dict([(key, values[num]) for num, key in enumerate(keys)])
        # This should to the same.
        return dict(zip(keys, values))


# TODO: move to professor.tools.utils module
def sanitizeLatexString(tex):
    for i in ["$", "\\", "{", "}", "_", "^"]:
        tex = tex.replace(i, "")
    return tex



def plotLabel(sub, label, x=0.5, y=-0.1, color="b", ha="left"):
    sub.text(x,y, label, ha=ha, color=color, transform=sub.transAxes,
            fontsize=20)


def getLine(hist, ratio=False):
    x=[]
    y=[]
    refy=[]
    if ratio:
        for b in dataproxy.getRefHisto(ratio).getBins():
            refy.append(b.getVal())
    for num, b in enumerate(hist.getBins()):
        for r in b.getXRange():
            x.append(r)
            if ratio:
                y.append(b.getVal()/refy[num])
            else:
                y.append(b.getVal())
    return x, y


class ProfIFrame(wx.Frame):

    def __init__(self):
        title = 'prof-I: Professor Interactive'
        wx.Frame.__init__(self, None, -1, title)
        self.sliders = {}
        self.showchisq = False
        self.showref = opts.SHOW_REF
        self.valtexts = {}
        self.mchistos= {}
        self.fixparams = prof.ParameterPoint.mkFromFile(opts.PARAMS_FILE) if opts.PARAMS_FILE else {}
        self.mccomphistos = {}
        if opts.MCCOMPAREFILE is not None:
            self.mccomphistos = prof.Histo.fromAIDA(opts.MCCOMPAREFILE)
        self.histos = {}
        self.refhistos = { "left" : None, "right" : None}
        self.limits = {}
        self.titles = { "left" : None, "right" : None}
        self.drawobs = { "left" : sorted(observables)[0],
                         "right" : sorted(observables)[1 if len(observables) > 1 else 0] }
        self.ratio   = { "left" : False,
                         "right" : False }
        self.params = sorted(tundat.paramranges.names)
        self.npars = len(self.params)
        self.gofs = { "left" : self.getGoF(self.drawobs["left"]),
                      "right" : self.getGoF(self.drawobs["right"]) }
        self.create_menu()
        self.createMainPanel()
        self.sliderUpdate(None, redraw=False)
        self.updateObs(None, "left")
        self.updateObs(None, "right")
        self.updateMCRun(None)
        self.zoomOut()
        self.currentdir = os.getcwd()


    def create_menu(self):
        self.menubar = wx.MenuBar()
        menu_file = wx.Menu()
        m_loadPar = menu_file.Append(-1, "Load &parameter file\tCtrl-P", "Load parameter file")
        self.Bind(wx.EVT_MENU, self.on_loadPar, m_loadPar)
        m_loadMC = menu_file.Append(-1, "&Load AIDA data file\tCtrl-L", "Load AIDA data file")
        self.Bind(wx.EVT_MENU, self.on_loadMC, m_loadMC)
        m_loadResult = menu_file.Append(-1, "Load &tune result file\tCtrl-T", "Load tune result file")
        self.Bind(wx.EVT_MENU, self.on_loadResult, m_loadResult)
        m_savePar = menu_file.Append(-1, "&Save current parameters\tCtrl-S", "Save current parameters")
        self.Bind(wx.EVT_MENU, self.on_savePar, m_savePar)
        m_exit = menu_file.Append(-1, "&Quit\tCtrl-Q", "Quit")
        self.Bind(wx.EVT_MENU, self.on_exit, m_exit)

        menu_help = wx.Menu()
        m_about = menu_help.Append(-1, "&About\tF1", "About the demo")
        self.Bind(wx.EVT_MENU, self.on_about, m_about)
        self.menubar.Append(menu_file, "&File")
        self.menubar.Append(menu_help, "&Help")
        self.SetMenuBar(self.menubar)


    def on_exit(self, event):
        self.Destroy()


    def on_about(self, event):
        msg = """prof-I: Professor-Interactive

 * Use the sliders to adjust parameters
 * The resulting interpolation histogram is displayed
 * Choose a MC run from the dropdown list for comparison

Use the button 'Set Params' to set sliders to
parameters loaded from file or result
        """
        dlg = wx.MessageDialog(self, msg, "About", wx.OK)
        dlg.ShowModal()
        dlg.Destroy()


    def on_savePar(self, event):
        current = self.getCurrentParamValues()
        dialog = wx.FileDialog (None, style=wx.SAVE)
        if dialog.ShowModal() == wx.ID_OK:
            outfile = dialog.GetPath()
            f = open(outfile,"w")
            for num, p in enumerate(self.params):
                f.write("%s   %f\n"%(p, current[num]))
            f.close()
        else:
            prof.log.error("No filename specified")
        ## Open the dialog in the last-opened location
        self.currentdir = os.path.dirname(dialog.GetPath())
        dialog.Destroy()


    def on_loadMC(self, event):
        wildcard = "AIDA histogram files (*.aida)|*.aida|All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", self.currentdir, "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            self.mccomphistos = prof.Histo.fromAIDA(dialog.GetPath())
        ## Open the dialog in the last-opened location
        self.currentdir = os.path.dirname(dialog.GetPath())
        dialog.Destroy()
        self.updateMCRun(None)


    def on_loadPar(self, event):
        wildcard = "All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", self.currentdir, "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            self.fixparams = prof.ParameterPoint.mkFromFile(dialog.GetPath())
            self.setParameters(None)
        ## Open the dialog in the last-opened location
        self.currentdir = os.path.dirname(dialog.GetPath())
        dialog.Destroy()


    def on_loadResult(self, event):
        wildcard = "Result files (*.pkl)|*.pkl|All files (*)|*"
        dialog = wx.FileDialog(None, "Choose a file", self.currentdir, "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
            R = prof.ResultList.mkFromPickle(dialog.GetPath())[0]
            self.fixparams = R.values
        ## Open the dialog in the last-opened location
        self.currentdir = os.path.dirname(dialog.GetPath())
        dialog.Destroy()


    def createMainPanel(self):
        """ Creates the main panel with all the controls on it:
             * mpl canvas
             * mpl navigation toolbar
             * Control panel for interaction
        """
        self.dpi=50
        self.panel = wx.Panel(self)

        ## Panel for observable diplay
        self.fig = Figure((10.0, 4.0), dpi=self.dpi)
        self.canvas = FigCanvas(self.panel, -1, self.fig)
        self.axes  = self.fig.add_subplot(121)
        self.axes2 = self.fig.add_subplot(122)
        self.toolbar = NavigationToolbar(self.canvas)

        ## Layout with box sizers
        ## matplotlib canvas and matplotlib toolbar
        self.vbox = wx.BoxSizer(wx.VERTICAL)
        self.vbox.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW | wx.EXPAND)
        self.vbox.Add(self.toolbar, 0, wx.EXPAND)

        ## Choice of observable 1
        self.hbox = wx.GridBagSizer(hgap=5, vgap=2)
        self.hbox.Add(wx.StaticText(self.panel, -1, "Obs 1:"), pos=(0,0))
        self.obschoice1 = wx.Choice(self.panel, -1, (85, 18), choices=sorted(observables))
        self.obschoice1.SetSelection(sorted(observables).index(self.drawobs["left"]))
        self.hbox.Add(self.obschoice1, pos=(0,1))
        self.logx1chkbx = wx.CheckBox(self.panel, -1, "logx")
        self.logy1chkbx = wx.CheckBox(self.panel, -1, "logy")
        self.hbox.Add(self.logx1chkbx, pos=(0,2))
        self.hbox.Add(self.logy1chkbx, pos=(0,3))
        self.Bind(wx.EVT_CHOICE, functools.partial(self.updateObs, which="left"), self.obschoice1)
        self.Bind(wx.EVT_CHECKBOX, self.setLogx, self.logx1chkbx)
        self.Bind(wx.EVT_CHECKBOX, self.setLogy, self.logy1chkbx)
        self.RatioButton1 = wx.ToggleButton(self.panel, label="Ratio")
        self.hbox.Add(self.RatioButton1, pos=(0,4))
        self.Bind(wx.EVT_TOGGLEBUTTON, functools.partial(self.toggleRatio, which="left"), self.RatioButton1)

        ## Choice of observable 2
        self.hbox.Add(wx.StaticText(self.panel, -1, "Obs 2:"), pos=(0,4))
        self.obschoice2 = wx.Choice(self.panel, -1, (85, 18), choices=sorted(observables))
        self.obschoice2.SetSelection(sorted(observables).index(self.drawobs["right"]))
        self.hbox.Add(self.obschoice2, pos=(0,5))
        self.logx2chkbx = wx.CheckBox(self.panel, -1, "logx")
        self.logy2chkbx = wx.CheckBox(self.panel, -1, "logy")
        self.hbox.Add(self.logx2chkbx, pos=(0,6))
        self.hbox.Add(self.logy2chkbx, pos=(0,7))
        self.Bind(wx.EVT_CHOICE, functools.partial(self.updateObs, which="right"), self.obschoice2)
        self.Bind(wx.EVT_CHECKBOX, self.setLogx, self.logx2chkbx)
        self.Bind(wx.EVT_CHECKBOX, self.setLogy, self.logy2chkbx)
        self.RatioButton2 = wx.ToggleButton(self.panel, label="Ratio")
        self.hbox.Add(self.RatioButton2, pos=(0,8))
        self.Bind(wx.EVT_TOGGLEBUTTON, functools.partial(self.toggleRatio, which="right"), self.RatioButton2)

        self.vbox.Add(self.hbox)
        self.vbox.AddSpacer((10,10))

        ## Parameter sliders and buttons
        self.controlgrid = wx.GridBagSizer(hgap=5, vgap=2)
        self.hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        iniunscaled = tundat.paramranges.center

        ## Read in parameter: name  - > description text file, store as dict
        parammap = {}
        if opts.PARAMS_DESCRS:
            if prof.io.isFileR(opts.PARAMS_DESCRS):
                f = open(opts.PARAMS_DESCRS)
                names_descrs = [line.strip().split(None, 1) for line in f if (line.strip() and not line.startswith('#'))]
                f.close()
                for name, descr in names_descrs:
                    parammap[name] = descr
            else:
                prof.log.warning("Parameter description file %s could not be read" % opts.PARAMS_DESCRS)

        ## Build the sliders and related objects
        for i, param in enumerate(self.params):
            ## Add param name
            self.controlgrid.Add(wx.StaticText(self.panel, -1, param), pos=(i,0))
            ## Map parameter names to descriptions if available
            if parammap.has_key(param):
                self.controlgrid.Add(wx.StaticText(self.panel, -1, parammap[param]), pos=(i,1))

            ## Sliders
            pmin = 0
            pmax = 1000
            slider = wx.Slider(self.panel, 100, 500, pmin, pmax,
                               pos=(10, 35*(i+1)), size=(250, -1),
                               style=wx.SL_HORIZONTAL )
            slider.SetTickFreq(10000, 1)
            self.controlgrid.Add(slider, pos=(i,2))
            self.sliders[param] = slider

            ## Parameter value textctrls
            textctrl = wx.TextCtrl(self.panel, -1, "%.3f" % iniunscaled[param])
            self.controlgrid.Add(textctrl, pos=(i,3))
            self.valtexts[param] = textctrl
        self.Bind(wx.EVT_SLIDER, self.sliderUpdate)

        ## Adding the Slider-related vertical boxes to a horizontal box
        self.hbox1.Add(self.controlgrid)

        self.buttongrid = wx.GridBagSizer(hgap=5, vgap=2)
        self.buttonvbox = wx.BoxSizer(wx.VERTICAL)

        ## Button for certain param settings
        self.ParamsButton = wx.Button(self.panel, label="Set params")
        self.Bind(wx.EVT_BUTTON, self.setParameters, self.ParamsButton)
        self.buttongrid.Add(self.ParamsButton, pos=(1,0))

        ## Buttons to reset limits
        self.resetBtn = wx.Button(self.panel, label="Reset limits 1")
        self.Bind(wx.EVT_BUTTON, functools.partial(self.resetLimits, which="left"), self.resetBtn)
        self.buttongrid.Add(self.resetBtn, pos=(3,0))
        self.resetBtn2 = wx.Button(self.panel, label="Reset limits 2")
        self.Bind(wx.EVT_BUTTON, functools.partial(self.resetLimits, which="right"), self.resetBtn2)
        self.buttongrid.Add(self.resetBtn2, pos=(4,0))

        self.hbox1.Add(self.buttongrid)

        ## vbox for x/y limits
        self.limitgrid = wx.GridBagSizer(hgap=5, vgap=2)
        self.limitgrid.Add(wx.StaticText(self.panel, -1, "Limits 1:"), pos=(0,0))
        limittypes = ("XMin", "XMax", "YMin", "YMax")
        self.limits["left"] = {}
        for num, i in enumerate(limittypes):
            self.limitgrid.Add(wx.StaticText(self.panel, -1, i), pos=(num+1, 0))
            textctrl = wx.TextCtrl(self.panel, -1, "None")
            self.limitgrid.Add(textctrl, pos=(num+1,1))
            self.limits["left"][i] = textctrl
        self.limitgrid.Add(wx.StaticText(self.panel, -1, "Limits 2:"), pos=(0,3))
        self.limits["right"] = {}
        for num, i in enumerate(limittypes):
            self.limitgrid.Add(wx.StaticText(self.panel, -1, i), pos=(num+1, 3))
            textctrl = wx.TextCtrl(self.panel, -1, "None", style=wx.TE_PROCESS_ENTER)
            self.limitgrid.Add(textctrl, pos=(num+1,4))
            self.limits["right"][i] = textctrl
        self.hbox1.Add(self.limitgrid)
        for textctrl in self.limits["left"].values():
            self.Bind(wx.EVT_TEXT,
                    self.sliderUpdate, textctrl)
        for textctrl in self.limits["right"].values():
            self.Bind(wx.EVT_TEXT,
                    self.sliderUpdate, textctrl)

        ## Checkboxes for calculation/display of chi2/Ndf values and ref data
        self.checkboxgrid = wx.GridBagSizer(hgap=5, vgap=2)
        self.chisqchkbx = wx.CheckBox(self.panel, -1, "Show GoF")
        self.checkboxgrid.Add(self.chisqchkbx, pos=(0,1))
        self.Bind(wx.EVT_CHECKBOX, self.setGOF, self.chisqchkbx)
        if dataproxy.refpath:
            self.refchkbx = wx.CheckBox(self.panel, -1, "Show ref data")
            self.refchkbx.SetValue(opts.SHOW_REF)
            self.checkboxgrid.Add(self.refchkbx, pos=(1,1))
            self.Bind(wx.EVT_CHECKBOX, self.setRef, self.refchkbx)

        self.zoombttn = wx.Button(self.panel, label="Ni!")
        self.checkboxgrid.Add(self.zoombttn, pos=(2,1))
        self.Bind(wx.EVT_BUTTON, self.zoomOut, self.zoombttn)
        self.hbox1.Add(self.checkboxgrid)

        ## Add sliders and so on to the main vertical box
        self.vbox.Add(self.hbox1)

        self.panel.SetSizer(self.vbox)
        self.vbox.Fit(self)

        ## Set the initial slider values
        self.setParameters(None)

        ## Maximize the window
        self.Maximize()


    def updateHisto(self, which, obs, newpoint):
        ppoint = prof.ParameterPoint.mkFromDict(mkDict(self.params, newpoint))
        ihisto = tundat.getInterpolationHisto(obs, mkDict(self.params, newpoint))
        return ihisto


    def resetLimits(self, event, which):
        for i in "XMin XMax YMin YMax".split():
            self.limits[which][i].SetValue("None")
        if which == "left":
            self.axes.relim()
            self.axes.autoscale_view()
        elif which == "right":
            self.axes2.relim()
            self.axes2.autoscale_view()
        self.sliderUpdate(None)


    def getLimits(self, limdict):
        xmin = self.convertInput(limdict["XMin"].GetValue())
        xmax = self.convertInput(limdict["XMax"].GetValue())
        ymin = self.convertInput(limdict["YMin"].GetValue())
        ymax = self.convertInput(limdict["YMax"].GetValue())
        return xmin, xmax, ymin, ymax


    def setLimits(self, sub, thelimits):
        xmin, xmax, ymin, ymax = thelimits
        sub.set_xlim(xmin, xmax)
        sub.set_ylim(ymin, ymax)


    def convertInput(self, inp):
        try:
            return float(inp)
        except:
            return None


    def sliderUpdate(self, event, redraw=True):
        self.updateTextCtrls()
        unscaled = self.getCurrentParamValues()
        self.plotHistos(unscaled, redraw=redraw)
        if self.showchisq:
            ## Goodness of fit from ipol
            self.gofs['left'].setParams(self.getCurrentParamValues())
            self.gofs['right'].setParams(self.getCurrentParamValues())

            plotLabel(self.axes,  "chi2/Nbins = %.2f" % self.gofs['left'].calcGoF())
            plotLabel(self.axes2, "chi2/Nbins = %.2f" % self.gofs['right'].calcGoF())
            ## Goodness of fit from MC
            try:
                gof1 = self.getGoFFromMC(self.drawobs["left"])
                gof2 = self.getGoFFromMC(self.drawobs["right"])
                plotLabel(self.axes,  "chi2/Nbins = %.2f" % gof1, color="r", ha="right")
                plotLabel(self.axes2, "chi2/Nbins = %.2f" % gof2, color="r", ha="right")
            except:
                pass
        ## Set plot limits
        self.setLimits(self.axes, self.getLimits(self.limits["left"]))
        self.setLimits(self.axes2, self.getLimits(self.limits["right"]))
        self.canvas.draw()


    def getCurrentParamValues(self):
        temp = [self.sliders[k].GetValue()/1000. for k in self.params]
        unscaled  = tundat.paramranges.getRelativePoint(temp)
        return unscaled


    def updateTextCtrls(self):
        current = mkDict(self.params, self.getCurrentParamValues())
        for k, v in self.valtexts.iteritems():
            v.SetValue("%.4f" % current[k])


    def setParameters(self, event):
        try:
            temp = [self.fixparams[k] for k in self.params]
            ppoint = prof.ParameterPoint.mkFromDict(mkDict(self.params, temp))
            normed = tundat.paramranges.getNormalisedPoint(ppoint)
            for k, v in self.sliders.iteritems():
                v.SetValue(1000*normed[k])
            self.sliderUpdate(None)
        except:
            pass

    def toggleRatio(self, event, which=None):
        if self.ratio[which] == True:
            self.ratio[which] = False
        else:
            self.ratio[which] = True
        self.updateObs(None, which)
        self.zoomOut()


    def updateObs(self, event=None, which=None):
        """Update the observable assigned the L or R window.
        """
        self.axes.clear()
        self.axes2.clear()
        if which in ("left", None):
            self.drawobs["left"] = observables[self.obschoice1.GetSelection()]
            self.gofs["left"] = self.getGoF(self.drawobs["left"])
        if which in ("right", None):
            self.drawobs["right"] = observables[self.obschoice2.GetSelection()]
            self.gofs["right"] = self.getGoF(self.drawobs["right"])

        ## Set titles and axis labels, using the rivet plot file parser if possible
        obs1 = self.drawobs["left"]
        obs2 = self.drawobs["right"]
        self.axes.set_title(obs1)
        self.axes2.set_title(obs2)
        try:
            pp = prof.PlotParser()
            def boolstr(x):
                return False if x is None else bool(int(x))
            def numstr(x):
                return x if x is None else float(x)
            try:
                headers1 = pp.getHeaders(obs1)
                for k, v in headers1.iteritems():
                    headers1[k] = sanitizeLatexString(v)
                #print headers1
                self.axes.set_title(headers1.get("Title", obs1))
                self.axes.set_xlabel(headers1.get("XLabel", ""))
                self.axes.set_ylabel(headers1.get("YLabel", ""))
                self.axes.set_xbound(lower=numstr(headers1.get("XMin")))
                self.axes.set_xbound(upper=numstr(headers1.get("XMax")))
                self.axes.set_ybound(lower=numstr(headers1.get("YMin")))
                self.axes.set_ybound(upper=numstr(headers1.get("YMax")))
                self.logx1chkbx.SetValue(boolstr(headers1.get("LogX", 0)))
                self.logy1chkbx.SetValue(boolstr(headers1.get("LogY", 0)))
            except:
                pass
            try:
                headers2 = pp.getHeaders(obs2)
                for k, v in headers2.iteritems():
                    headers2[k] = sanitizeLatexString(v)
                #print headers2
                self.axes2.set_title(headers2.get("Title", obs2))
                self.axes2.set_xlabel(headers2.get("XLabel", ""))
                self.axes2.set_ylabel(headers2.get("YLabel", ""))
                self.axes2.set_xbound(lower=numstr(headers2.get("XMin")))
                self.axes2.set_xbound(upper=numstr(headers2.get("XMax")))
                self.axes2.set_ybound(lower=numstr(headers2.get("YMin")))
                self.axes2.set_ybound(upper=numstr(headers2.get("YMax")))
                self.logx2chkbx.SetValue(boolstr(headers2.get("LogX", 0)))
                self.logy2chkbx.SetValue(boolstr(headers2.get("LogY", 0)))
            except:
                pass
        except:
            pass

        ## Ref. data is available if we can access the refpath property of
        ## the global data proxy instance.
        try:
            if dataproxy.refpath and self.showref:
                self.plotRefHisto(self.axes, 'left')
                self.plotRefHisto(self.axes2, 'right')
        except prof.DataProxyError, err:
            pass

        self.setLogx(None)
        self.setLogy(None)
        self.updateMCRun(None)
        self.zoomOut()
        self.sliderUpdate(None, redraw=False)
        #self.canvas.draw()


    def plotLegend(self):
        self.axes.legend(loc=0)
        self.axes2.legend(loc=0)


    def plotHistos(self, unscaled, redraw=False):
        """ This plots the observable prediction calculated from the
            parameterisation.
        """
        for i in (['left', self.axes, self.drawobs["left"]],
                  ['right',self.axes2, self.drawobs["right"]]):
            histo = self.updateHisto(i[0], i[2], unscaled)
            if self.ratio[i[0]]:
                x, y = getLine(histo, i[2])
            else:
                x, y = getLine(histo)
            if redraw is False:
                self.histos[i[0]] = i[1].plot(x,y, color="b", label="Ipol")
            else:
                self.histos[i[0]][0].set_xdata(x)
                self.histos[i[0]][0].set_ydata(y)
                self.histos[i[0]][0].set_label("Ipol")
                i[1].texts = []
                ## Workaround for changes in matplotlib 0.99
                try:
                    i[1].redraw_in_frame()
                except:
                    pass

    def plotRefHisto(self, sub, which):
        if dataproxy.refpath:
            x,y,ye = [], [], []
            for b in dataproxy.getRefHisto(self.drawobs[which]).getBins():
                x.append(b.getBinCenter())
                y.append(b.getVal())
                ye.append(b.getErr())
            if self.ratio[which]:
                yer = numpy.array(ye)/numpy.array(y)
                self.refhistos[which] = sub.errorbar(x,numpy.ones(len(x)), yerr=yer, ls=" ", marker="o", color="k", label="Data")
            else:
                self.refhistos[which] = sub.errorbar(x,y, yerr=ye, ls=" ", marker="o", color="k", label="Data")
        try:
            pp = prof.PlotParser()
            headers = pp.getHeaders(obs)
            title = sanitizeLatexString(headers["Title"])
            sub.set_title(title, ha="center")
        except:
            pass


    def getGoF(self, obs):
        from professor import fitfunctions
        return fitfunctions.SingleSimpleIpolChi2(tundat, obs)


    def updateMCRun(self, event):
        """ Update MC comparison histo."""
        try:
            self.axes.lines.remove(self.mchistos["left"][0])
            self.axes2.lines.remove(self.mchistos["right"][0])
        except:
            pass
        try:
            self.plotMCHisto(self.axes, self.drawobs["left"], plotid="left")
        except:
            prof.log.debug("Given MC comparison file does not contain obs %s or no file loaded" % self.drawobs["left"])
        try:
            self.plotMCHisto(self.axes2, self.drawobs["right"], plotid="right")
        except:
            prof.log.debug("Given MC comparison file does not contain obs %s or no file loaded" % self.drawobs["right"])
        self.canvas.draw()


    def setLogx(self, event):
        """ See if the checkboxes are checked and set logx-scales accordingly """
        for i in [(self.logx1chkbx, self.axes), (self.logx2chkbx, self.axes2)]:
            if i[0].IsChecked():
                i[1].set_xscale('log')
            else:
                i[1].set_xscale('linear')
        self.sliderUpdate(None)


    def setLogy(self, event):
        """ See if the checkboxes are checked and set logy-scales accordingly """
        for i in [(self.logy1chkbx, self.axes), (self.logy2chkbx, self.axes2)]:
            if i[0].IsChecked():
                i[1].set_yscale('log')
            else:
                i[1].set_yscale('linear')
        self.sliderUpdate(None)


    def setGOF(self, event):
        """ Toggle calculation and display of g.o.f. """
        if dataproxy.refpath:
            self.showchisq = self.chisqchkbx.IsChecked()
            self.sliderUpdate(None)
            self.updateMCRun(None)


    def setRef(self, event):
        """ Toggle display of ref data"""
        if dataproxy.refpath:
            self.showref = self.refchkbx.IsChecked()
            self.sliderUpdate(None)
            self.updateMCRun(None)
            self.updateObs(None)


    def plotMCHisto(self, sub, obs, plotid="left"):
        """ plot a MC histo """
        histo = self.mccomphistos[obs]
        if self.ratio(plotid):
            x, y = getLine(histo, obs)
        else:
            x, y = getLine(histo)
        self.mchistos[plotid] = sub.plot(x,y, color="r", label="MC")


    def getGoFFromMC(self, obs):
        """
        GoF calculation for MC histos.

        TODO: Use GoFs from professor.fitfunctions, to match prof-tune.
        TODO: Allow GoF to be specified in a user's Python file.
        """
        mchistobins = self.mccomphistos[obs].getBins()
        refhisto = dataproxy.getRefHisto(obs)
        chi2 = 0.0
        err2 = 0.0
        for num, bin in enumerate(refhisto.getBins()):
            err2 += (bin.getErr())**2
            diff = bin.getVal() - mchistobins[num].getVal()
            chi2 += diff**2 / err2
        return chi2/refhisto.numBins()

    def zoomOut(self, event=None):
        """ For each plotwindow find the min and max y values of current param point
            and set plotlimits accordingly.
        """
        # Find extremal ipolplot y values

        for i in (['left', self.axes, self.drawobs["left"]],
                  ['right',self.axes2, self.drawobs["right"]]):
            y=self.histos[i[0]][0]._y
            ymaxs = []
            ymins = []
            ymaxs.append(max(y))
            ymins.append(min(y))

            if self.refhistos[i[0]] is not None:
                rhc = self.refhistos[i[0]]
                ymaxs.append(max(rhc[0]._y))
                ymaxs.append(max(rhc[1][0]._y))
                ymaxs.append(max(rhc[1][1]._y))
                ymins.append(min(rhc[0]._y))
                ymins.append(min(rhc[1][0]._y))
                ymins.append(min(rhc[1][1]._y))

            ymax = max(ymaxs)
            ymin = min(ymins)
            d = ymax - ymin

            i[1].set_ylim(ymin-.3*d, ymax+.3*d)

        self.sliderUpdate(None)



## Run GUI application
app = wx.PySimpleApp()
pif=ProfIFrame()
pif.Show()
app.MainLoop()
