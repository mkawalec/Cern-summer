#!/usr/bin/python2

"""%prog [options] (<paramrangefile> | <parameterfile1> <parameterfile2>)

Sample from a parameter space defined by a set of ranges and
write the results to used_params files in a sub-directory tree.

By default, %prog generates points by random sampling from
the parameter hypercube defined in <paramrangefile>.

With the --scan option equally distant points are sampled along a straight
line. If no other options are given, this line is defined by the two points
in <paramrangefile>. To make the line go through a point of tuned parameter
values use the --scancenter option. The orientation of the line can be set
with the --direction option. See the table below.

direction      scan center          sampled line
=============  ===================  =======================================
diagonal       minimization result  sampling along body diagonal of the
               parameter file       largest hyper cube that is centered
                                    around `scan center' and fits into the
                                    parameter ranges of <paramrangefile>.

steep/shallow  minimization result  sampling along longest line that fits
                                    into parameter ranges of
                                    <paramrangefile> in steep/shallow
                                    direction of the result's covariance
                                    matrix, i.e. not necessarily symmetric.
                                    If the `:sym' flag is given the line
                                    will be symmetric around the result.

A "fake reference" point within a central region of
the param hypercube for bootstrap testing of Professor when
no real reference data is available.
"""

import os, sys, time

from professor import user as prof
from professor.tools.sorting import ParameterCmp

## Parse command line options
from optparse import OptionParser, OptionGroup
parser = OptionParser(usage=__doc__, version=prof.version)

parser.add_option("-N", "--num-runs",
                  dest="NUM_RUNS", type=int,
                  default=1,
                  help = "Number of generated points.")
parser.add_option("--first-run",
                  dest="NUM_FIRST_RUN", type=int,
                  default=0, help="number given to the first run")
parser.add_option("-t", "--timestamp",
                  dest="TIMESTAMP", action="store_true",
                  default=False,
                  help = "Add a timestamp prefix to the output directory name")
parser.add_option("-T", "--template",
                  dest="TEMPLATES", action="append",
                  default = [],
                  help = "Replace variables in template files instead of"
                         " writing used_params files")
parser.add_option("-S", "--seed",
                  dest="SEED", action="store",
                  default = -1,
                  help = "Provide a random seed for reproducible sampling.")

scangroup = OptionGroup(parser, "Param line scanning")
scangroup.add_option("-s", "--scan", action="store_true", dest="SCANMODE",
                     default=False,
                     help = "Turn on line scan sampling.")
                     # help = "rather than scan randomly, treat param ranges"
                            # " as being endpoints of a straight, uniformly"
                            # " sampled line in param space. Requires at least"
                            # " 2 runs to work, and more to really make sense."
                            # " Used to verify MC behaviour around a proposed"
                            # " optimum and to compare systematically to other"
                            # " tunes.")
scangroup.add_option("--scancenter", dest="SCANCENTER", default=None,
                     help = "Define the center for line scanning:"
                            " Either a text file with parameter values or"
                            " a result list file with the comma separated"
                            " index of the MinimizationResult that defines"
                            " the directions" " for --direction 'steep' or"
                            " 'shallow'. E.g. center.params OR"
                            " results.pkl,10")
scangroup.add_option("--direction", dest="DIRECTION",
                     default="diagonal",
                     help = "the direction of line scan. Can be 'diagonal',"
                            " 'steep' or 'shallow'. 'steep' and 'shallow'"
                            " require a MinimisationResult given via"
                            " --scancenter  and they allow an additional"
                            " ':sym' to make the line scan symmetric around"
                            " the minimisation result. [default: %default]")
scangroup.add_option("--excess", dest="EXCESS", type="float",
                     default=0.,
                     help = "symmetrically stretch scanline by this fraction")
parser.add_option_group(scangroup)

refgroup = OptionGroup(parser, "Reference data")
refgroup.add_option("-R", "--fake-reference", action="store_true", dest="MKREF",
                    default=False,
                    help = "make an extra run as a fake reference point")
refgroup.add_option("--ref-range", dest="REFRANGE", type=float,
                    default=0.5,
                    help = "specify central fraction of the param range from"
                           " which to sample the fake reference")
parser.add_option_group(refgroup)

prof.addOutputCLOptions(parser)
prof.addLoggingCLOptions(parser)
opts, args = parser.parse_args()

prof.log.setPriority(opts)
prof.writeGuideLine()


## Check if specified outdir exists and create it otherwise.
outdir = prof.getOutputDirectory(opts, "mc")
if not outdir:
    outdir = "./mc"
prof.log.debug("Using %s for sampling output." % outdir)
prof.io.makeDir(outdir)

## Add timestamp to output dir name
if opts.TIMESTAMP:
    outname = os.path.basename(outdir)
    outparent = os.path.dirname(outdir)
    timestamp = time.strftime("%Y-%m-%d")
    outdir = os.path.join(outparent, timestamp + "-" + outname)


## Read the params files to get ranges
if len(args) == 1:
    paramranges = prof.ParameterRange.mkFromFile(args[0])
    paramorder = ParameterCmp.mkFromFile(args[0])
elif len(args) == 2:
    p1 = prof.ParameterPoint.mkFromFile(args[0])
    p2 = prof.ParameterPoint.mkFromFile(args[1])
    paramorder = ParameterCmp.mkFromFile(args[0])
    if p1.names != p2.names:
        sys.exit.write("Parameter range end points must have the same set of parameters.!")
        sys.exit(1)
    paramranges = prof.ParameterRange(p1.names, zip(p1, p2))
    del p1, p2
else:
    prof.log.error("Need to specify at least a parameter range file or two"
                   " parameter point files.")
    sys.exit(1)

## Notify re. run conditions
prof.log.info("Making %d param sets" % opts.NUM_RUNS)

## Make param sets
## map {"runID" => parameter point}
paramsets = {}

### RANDOM SAMPLING
if not opts.SCANMODE:
    ## Initialize RNG
    from professor.tools.pointsampling import RandomPointGenerator
    rpg = RandomPointGenerator(paramranges)
    # TODO: Seed based on run numbers, to provide reproducibility and avoid replication?
    seed = rpg.seed(opts.SEED)

    prof.log.info("Using following random seed: %d" % seed)
    prof.log.info("Sampling randomly from ranges\n%s" % paramranges)

    for i, point in enumerate(rpg.generate(opts.NUM_RUNS)):
        runname = "%03d" % (opts.NUM_FIRST_RUN + i)
        paramsets[runname] = point


### UNIFORM LINE SCAN SAMPLING
else:
    from professor.tools.pointsampling import ScanPointGenerator
    ## Notify that this is scan mode
    prof.log.info("Using linear scan mode: param points will NOT be randomly"
                 " distributed!")
    if opts.MKREF:
        prof.log.warn("Fake refs can't be used in scan mode: skipping fake"
                     " ref command.")
    #############
    ## Create a ScanPointGenerator that will be used to generate the line
    ## scan points.

    ## sampling along body diagonal of hyper-cube defined by argument parameter file(s)
    if opts.SCANCENTER is None:
        prof.log.info("Sampling along diagonal from\n%s" % (paramranges))

        linesampler = ScanPointGenerator.mkDiagonal(paramranges)

    ## sampling along body diagonal of maximal sub-hyper-cube that fits into
    ## parameter ranges from argument(s) and that is centered around
    ## opts.SCANCENTER
    elif opts.DIRECTION == "diagonal":

        # load scan center
        tokens = opts.SCANCENTER.split(",")
        if len(tokens) == 2:
            path = tokens[0]
            idx = int(tokens[1])
            minres = prof.ResultList.mkFromPickle(path)[idx]
            values = minres.values
            msg = ("Sampling from symmetric sub-cube, center defined by"
                   " minimisation result #%i in file %s:\n%s" % (
                       idx, path, values))
        else:
            values = prof.ParameterPoint.mkFromFile(opts.SCANCENTER)
            msg = ("Sampling from symmetric sub-cube, center defined by file"
                   " %s\n%s" % (opts.SCANCENTER, values))
        linesampler = ScanPointGenerator.mkSubRangeDiagonal(paramranges,
                                                            values)
        prof.log.info(msg)
        del msg

    ## sampling along steep/shallow directions of covariance matrix of the given min. result
    else:
        tokens = opts.SCANCENTER.split(",")
        if len(tokens) != 2:
            prof.log.error("Direction mode '%s' only work with --scancenter"
                          " results.pkl,IDX!" % (opts.DIRECTION))
            sys.exit(1)
        minres = prof.ResultList.mkFromPickle(tokens[0])[int(tokens[1])]

        ## Parse direction option if the line should be symmtetric.
        tokens = opts.DIRECTION.split(":")
        direction = tokens[0]
        symmetric = False
        if len(tokens) == 2 and tokens[1].lower().startswith("sym"):
            prof.log.info("Will produce a symmetric line.")
            symmetric = True

        if direction == "steep":
            linesampler = ScanPointGenerator.mkSteep(paramranges, minres,
                                                     symmetric)
        elif direction == "shallow":
            linesampler = ScanPointGenerator.mkShallow(paramranges, minres,
                                                       symmetric)
        else:
            sys.stderr.write("Argument of --direction must be of the form"
                             " '(steep|shallow)[:sym]' or just 'diagonal'!")
            sys.exit(1)
        prof.log.info("Line scanning in %s direction around %s" % (
                        direction, minres.values))

    ## TODO: is anyone using the hypercube.params file? This is also
    ## accessible through <FirstRun>/used_params <LastRun>/used_params
    ## Save hypercube to file
    fname = os.path.join(outdir, "hypercube.params")
    if not os.path.exists(outdir):
        os.mkdir(outdir)
    linesampler._range.writeParamFile(fname)

    ## Create dictionary of paramsets to fill template files with
    for i, point in enumerate(linesampler.generate(opts.NUM_RUNS)):
        runname = "%03d" % (opts.NUM_FIRST_RUN + i)
        paramsets[runname] = point


## Write used_params files and optionally templates.
for run, runparams in paramsets.iteritems():
    runoutdir = os.path.join(outdir, run)
    if not os.path.isdir(runoutdir):
        os.makedirs(runoutdir)
    path = os.path.join(runoutdir, "used_params")
    runparams.writeParamFile(path, key=paramorder)

    for template in opts.TEMPLATES:
        f = open(os.path.join(runoutdir, os.path.basename(template)), "w")
        for line in open(template):
            line = line.replace("<__RUNID__>", "%s" % run);
            for pname in sorted(runparams.keys()):
                line = line.replace("<__%s__>" % pname, "%e" % runparams[pname])
            f.write(line);
        f.close()
